(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all2) => {
    for (var name297 in all2)
      __defProp(target, name297, { get: all2[name297], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format4) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format4, args);
              }
            }
          }
          function error(format4) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format4, args);
              }
            }
          }
          function printWarning(level, format4, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format4 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format4);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign2 = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign2(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef2() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e2) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty3 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty3.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty3.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement2(type, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty3.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign2({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty3.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape2(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape2("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray2(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray2(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy2(ctor) {
            var payload = {
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef2(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name297) {
                  ownName = name297;
                  if (!render.name && !render.displayName) {
                    render.displayName = name297;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo(type, compare) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name297) {
                  ownName = name297;
                  if (!type.name && !type.displayName) {
                    type.displayName = name297;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState2(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect2(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create2, deps);
          }
          function useInsertionEffect(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create2, deps);
          }
          function useLayoutEffect(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create2, deps);
          }
          function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo(create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create2, deps);
          }
          function useImperativeHandle(ref, create2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create2, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name297, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name297;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name297 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name297 ? describeBuiltInComponentFrame(name297) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values2, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty3);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name297 = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name297) {
                return "\n\nCheck the render method of `" + name297 + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray2(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name297 = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name297, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray2(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement2.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children;
          exports.Component = Component2;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef2;
          exports.forwardRef = forwardRef2;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy2;
          exports.memo = memo;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback;
          exports.useContext = useContext;
          exports.useDebugValue = useDebugValue;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect2;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect;
          exports.useMemo = useMemo;
          exports.useReducer = useReducer;
          exports.useRef = useRef;
          exports.useState = useState2;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          }
          function siftUp(heap, node, i) {
            var index = i;
            while (index > 0) {
              var parentIndex = index - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            var halfLength = length >>> 1;
            while (index < halfLength) {
              var leftIndex = (index + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (compare(left, node) < 0) {
                if (rightIndex < length && compare(right, left) < 0) {
                  heap[index] = right;
                  heap[rightIndex] = node;
                  index = rightIndex;
                } else {
                  heap[index] = left;
                  heap[leftIndex] = node;
                  index = leftIndex;
                }
              } else if (rightIndex < length && compare(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime2;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime2 = currentTime + delay;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React3 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format4) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format4, args);
              }
            }
          }
          function error(format4) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format4, args);
              }
            }
          }
          function printWarning(level, format4, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format4 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format4);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment2 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = false;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies298) {
            registerDirectEvent(registrationName, dependencies298);
            registerDirectEvent(registrationName + "Capture", dependencies298);
          }
          function registerDirectEvent(registrationName, dependencies298) {
            {
              if (registrationNameDependencies[registrationName]) {
                error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies298;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i = 0; i < dependencies298.length; i++) {
              allNativeEvents.add(dependencies298[i]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty3 = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e2) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name297, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name297.length > 2 && (name297[0] === "o" || name297[0] === "O") && (name297[1] === "n" || name297[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name297, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name297.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name297, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name297, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name297) {
            return properties2.hasOwnProperty(name297) ? properties2[name297] : null;
          }
          function PropertyInfoRecord(name297, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name297;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties2 = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              RESERVED,
              false,
              name297,
              null,
              false,
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name297 = _ref[0], attributeName = _ref[1];
            properties2[name297] = new PropertyInfoRecord(
              name297,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              BOOLEANISH_STRING,
              false,
              name297.toLowerCase(),
              null,
              false,
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              BOOLEANISH_STRING,
              false,
              name297,
              null,
              false,
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              BOOLEAN,
              false,
              name297.toLowerCase(),
              null,
              false,
              false
            );
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              BOOLEAN,
              true,
              name297,
              null,
              false,
              false
            );
          });
          [
            "capture",
            "download"
          ].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              OVERLOADED_BOOLEAN,
              false,
              name297,
              null,
              false,
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              POSITIVE_NUMERIC,
              false,
              name297,
              null,
              false,
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name297) {
            properties2[name297] = new PropertyInfoRecord(
              name297,
              NUMERIC,
              false,
              name297.toLowerCase(),
              null,
              false,
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name297 = attributeName.replace(CAMELIZE, capitalize);
            properties2[name297] = new PropertyInfoRecord(
              name297,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name297 = attributeName.replace(CAMELIZE, capitalize);
            properties2[name297] = new PropertyInfoRecord(
              name297,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name297 = attributeName.replace(CAMELIZE, capitalize);
            properties2[name297] = new PropertyInfoRecord(
              name297,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties2[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              false,
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties2[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties2[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              true,
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name297, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name297);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name297, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name297, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name297, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name297, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name297)) {
                return;
              }
              if (!node.hasAttribute(name297)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name297);
              {
                checkAttributeStringCoercion(expected, name297);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name297, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name297);
            if (shouldIgnoreAttribute(name297, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name297, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name297)) {
                var _attributeName = name297;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name297);
                  }
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign2 = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name297, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name297;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name297 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name297 ? describeBuiltInComponentFrame(name297) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag2 = fiber.tag, type = fiber.type;
            switch (tag2) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment2:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get2 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get2.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e2) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign2({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || node.value != value) {
                  node.value = toString(value);
                }
              } else if (node.value !== toString(value)) {
                node.value = toString(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name297 = node.name;
            if (name297 !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name297 !== "") {
              node.name = name297;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name297 = props.name;
            if (props.type === "radio" && name297 != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name297, "name");
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name297) + '][type="radio"]');
              for (var i = 0; i < group.length; i++) {
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (type !== "number" || getActiveElement(node.ownerDocument) !== node) {
              if (value == null) {
                node.defaultValue = toString(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString(value)) {
                node.defaultValue = toString(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React3.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a) {
            return isArrayImpl(a);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray2(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options2 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i = 0; _i < options2.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
                if (options2[_i].selected !== selected) {
                  options2[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                if (options2[_i2].value === _selectedValue) {
                  options2[_i2].selected = true;
                  if (setDefaultSelected) {
                    options2[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i2].disabled) {
                  defaultSelected = options2[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign2({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign2({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray2(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name297, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name297) && isUnitlessNumber[name297])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name297);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name297) {
            return name297.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string) {
              return string.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name297) {
              if (warnedStyleNames.hasOwnProperty(name297) && warnedStyleNames[name297]) {
                return;
              }
              warnedStyleNames[name297] = true;
              error(
                "Unsupported style property %s. Did you mean %s?",
                name297,
                camelize(name297.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name297) {
              if (warnedStyleNames.hasOwnProperty(name297) && warnedStyleNames[name297]) {
                return;
              }
              warnedStyleNames[name297] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name297, name297.charAt(0).toUpperCase() + name297.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name297, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name297, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name297, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name297);
            };
            var warnStyleValueIsInfinity = function(name297, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name297);
            };
            warnValidStyle = function(name297, value) {
              if (name297.indexOf("-") > -1) {
                warnHyphenatedStyleName(name297);
              } else if (badVendoredStyleNamePattern.test(name297)) {
                warnBadVendoredStyleName(name297);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name297, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name297, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name297, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var voidElementTags = assign2({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag2, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag2]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag2 + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name297) {
            {
              if (hasOwnProperty3.call(warnedProperties, name297) && warnedProperties[name297]) {
                return true;
              }
              if (rARIACamel.test(name297)) {
                var ariaName = "aria-" + name297.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name297);
                  warnedProperties[name297] = true;
                  return true;
                }
                if (name297 !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name297, correctName);
                  warnedProperties[name297] = true;
                  return true;
                }
              }
              if (rARIA.test(name297)) {
                var lowerCasedName = name297.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name297] = true;
                  return false;
                }
                if (name297 !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name297, standardName);
                  warnedProperties[name297] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name297, value, eventRegistry) {
              if (hasOwnProperty3.call(warnedProperties$1, name297) && warnedProperties$1[name297]) {
                return true;
              }
              var lowerCasedName = name297.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name297] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name297)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name297, registrationName);
                  warnedProperties$1[name297] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name297)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name297);
                  warnedProperties$1[name297] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name297)) {
                if (INVALID_EVENT_NAME_REGEX.test(name297)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name297);
                }
                warnedProperties$1[name297] = true;
                return true;
              }
              if (rARIA$1.test(name297) || rARIACamel$1.test(name297)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name297] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name297] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name297] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name297);
                warnedProperties$1[name297] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name297);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name297) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name297, standardName);
                  warnedProperties$1[name297] = true;
                  return true;
                }
              } else if (!isReserved && name297 !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name297, lowerCasedName);
                warnedProperties$1[name297] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name297, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name297, name297, value, name297);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name297, name297, value, name297, name297, name297);
                }
                warnedProperties$1[name297] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name297, value, propertyInfo, false)) {
                warnedProperties$1[name297] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name297, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name297, value);
                warnedProperties$1[name297] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn, bookkeeping) {
            return fn(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn, a, b) {
            if (isInsideEventHandler) {
              return fn(a, b);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn, a, b);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag2) {
            return tag2 === "button" || tag2 === "input" || tag2 === "select" || tag2 === "textarea";
          }
          function shouldPreventMouseEvent(name297, type, props) {
            switch (name297) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e2) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name297, func, context, a, b, c, d, e2, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name297, func, context, a, b, c, d, e2, f) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name297 ? name297 : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name297, func, context, a, b, c, d, e2, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name297, func, context, a, b, c, d, e2, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var ChildDeletion = 16;
          var ContentReset = 32;
          var Callback = 64;
          var DidCapture = 128;
          var ForceClientRender = 256;
          var Ref = 512;
          var Snapshot = 1024;
          var Passive = 2048;
          var Hydrating = 4096;
          var Visibility = 8192;
          var StoreConsistency = 16384;
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
          var HostEffectMask = 32767;
          var Incomplete = 32768;
          var ShouldCapture = 65536;
          var ForceUpdateForLegacySuspense = 131072;
          var Forked = 1048576;
          var RefStatic = 2097152;
          var LayoutStatic = 4194304;
          var PassiveStatic = 8388608;
          var MountLayoutDev = 16777216;
          var MountPassiveDev = 33554432;
          var BeforeMutationMask = Update | Snapshot | 0;
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a.alternate !== b) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match = findCurrentHostFiberImpl(child);
              if (match !== null) {
                return match;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match !== null) {
                  return match;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign2({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root3, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root3, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root3, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root3.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root3) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root3);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map2 = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index2 = 0; index2 < TotalLanes; index2++) {
                var label = getLabelForLane(lane);
                map2.set(lane, label);
                lane *= 2;
              }
              return map2;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = 0;
          var ConcurrentMode = 1;
          var ProfileMode = 2;
          var StrictLegacyMode = 8;
          var StrictEffectsMode = 16;
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log3 = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log3(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = 0;
          var NoLane = 0;
          var SyncLane = 1;
          var InputContinuousHydrationLane = 2;
          var InputContinuousLane = 4;
          var DefaultHydrationLane = 8;
          var DefaultLane = 16;
          var TransitionHydrationLane = 32;
          var TransitionLanes = 4194240;
          var TransitionLane1 = 64;
          var TransitionLane2 = 128;
          var TransitionLane3 = 256;
          var TransitionLane4 = 512;
          var TransitionLane5 = 1024;
          var TransitionLane6 = 2048;
          var TransitionLane7 = 4096;
          var TransitionLane8 = 8192;
          var TransitionLane9 = 16384;
          var TransitionLane10 = 32768;
          var TransitionLane11 = 65536;
          var TransitionLane12 = 131072;
          var TransitionLane13 = 262144;
          var TransitionLane14 = 524288;
          var TransitionLane15 = 1048576;
          var TransitionLane16 = 2097152;
          var RetryLanes = 130023424;
          var RetryLane1 = 4194304;
          var RetryLane2 = 8388608;
          var RetryLane3 = 16777216;
          var RetryLane4 = 33554432;
          var RetryLane5 = 67108864;
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = 134217728;
          var NonIdleLanes = 268435455;
          var IdleHydrationLane = 268435456;
          var IdleLane = 536870912;
          var OffscreenLane = 1073741824;
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root3, wipLanes) {
            var pendingLanes = root3.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root3.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root3.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index2 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index2;
                nextLanes |= entanglements[index2];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root3, lanes) {
            var eventTimes = root3.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var eventTime = eventTimes[index2];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root3, currentTime) {
            var pendingLanes = root3.pendingLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var expirationTime = expirationTimes[index2];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root3.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root3) {
            return getHighestPriorityLanes(root3.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root3) {
            var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root3, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root3, lanes) {
            return (lanes & root3.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a, b) {
            return a | b;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function intersectLanes(a, b) {
            return a & b;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root3, updateLane, eventTime) {
            root3.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root3.suspendedLanes = NoLanes;
              root3.pingedLanes = NoLanes;
            }
            var eventTimes = root3.eventTimes;
            var index2 = laneToIndex(updateLane);
            eventTimes[index2] = eventTime;
          }
          function markRootSuspended(root3, suspendedLanes) {
            root3.suspendedLanes |= suspendedLanes;
            root3.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root3, pingedLanes, eventTime) {
            root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root3, remainingLanes) {
            var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
            root3.pendingLanes = remainingLanes;
            root3.suspendedLanes = NoLanes;
            root3.pingedLanes = NoLanes;
            root3.expiredLanes &= remainingLanes;
            root3.mutableReadLanes &= remainingLanes;
            root3.entangledLanes &= remainingLanes;
            var entanglements = root3.entanglements;
            var eventTimes = root3.eventTimes;
            var expirationTimes = root3.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] = NoLanes;
              eventTimes[index2] = NoTimestamp;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root3, entangledLanes) {
            var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
            var entanglements = root3.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              if (lane & entangledLanes | entanglements[index2] & entangledLanes) {
                entanglements[index2] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root3, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root3, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root3, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            var memoizedUpdaters = root3.memoizedUpdaters;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root3, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
          }
          function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
          }
          function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root3) {
            var currentState = root3.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn) {
            _attemptSynchronousHydration = fn;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn) {
            getCurrentUpdatePriority$1 = fn;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn) {
            attemptHydrationAtPriority = fn;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag2 = nearestMounted.tag;
                if (tag2 === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag2 === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i = 0;
            for (; i < queuedExplicitHydrationTargets.length; i++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
            if (i === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map2.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag2 = nearestMounted.tag;
                if (tag2 === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag2 === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              passive
            });
            return listener;
          }
          var root2 = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root2 = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root2 = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
              if (startValue[start] !== endValue[start]) {
                break;
              }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root2) {
              return root2.value;
            }
            return root2.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize = Interface[_propName];
                if (normalize) {
                  this[_propName] = normalize(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign2(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              persist: function() {
              },
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign2({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign2({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign2({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign2({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign2({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign2({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign2({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign2({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign2({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign2({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign2({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign2({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from = null;
              to = targetInst;
            }
            if (from === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              var currentKey = keysA[i];
              if (!hasOwnProperty3.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root3, offset) {
            var node = getLeafNode(root3);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                  return {
                    node,
                    offset: offset - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e2) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start = length + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start = length;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start === -1 || end === -1) {
              return null;
            }
            return {
              start,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start = Math.min(offsets.start, length);
            var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
            if (!selection.extend && start > end) {
              var temp = end;
              end = start;
              start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i = 0; i < simpleEventPluginEvents.length; i++) {
              var eventName = simpleEventPluginEvents[i];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
              var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container !== null) {
                        var parentNode = getClosestInstanceFromNode(container);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container = container.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag2 = _instance2.tag;
              if (tag2 === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag2 = _instance3.tag;
              if (tag2 === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag2 = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag2 === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            if (from !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              dialog: true,
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name297) {
                names.push(name297);
              });
              error("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop;
          }
          function setInitialDOMProperties(tag2, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag2 !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement2(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div2 = ownerDocument.createElement("div");
                div2.innerHTML = "<script><\/script>";
                var firstChild = div2.firstChild;
                domElement = div2.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty3.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag2, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag2, rawProps);
            {
              validatePropertiesInDevelopment(tag2, rawProps);
            }
            var props;
            switch (tag2) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag2, props);
            setInitialDOMProperties(tag2, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag2) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag2, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag2, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag2) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag2, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag2, lastRawProps, nextRawProps) {
            if (tag2 === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag2, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag2, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag2) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag2, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag2, rawProps);
              validatePropertiesInDevelopment(tag2, rawProps);
            }
            switch (tag2) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag2, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name297 = attributes[_i].name.toLowerCase();
                switch (name297) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag2);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag2) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag2, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag2, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag2, props) {
            switch (tag2) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag2) {
              var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag: tag2
              };
              if (inScopeTags.indexOf(tag2) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag2) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag2) !== -1 && tag2 !== "address" && tag2 !== "div" && tag2 !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag2 === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag2 === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag2 === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag2 === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag2 === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag2 === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag2 === "dd" || tag2 === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag2, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag2 === "option" || tag2 === "optgroup" || tag2 === "#text";
                case "optgroup":
                  return tag2 === "option" || tag2 === "#text";
                case "option":
                  return tag2 === "#text";
                case "tr":
                  return tag2 === "th" || tag2 === "td" || tag2 === "style" || tag2 === "script" || tag2 === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag2 === "tr" || tag2 === "style" || tag2 === "script" || tag2 === "template";
                case "colgroup":
                  return tag2 === "col" || tag2 === "template";
                case "table":
                  return tag2 === "caption" || tag2 === "colgroup" || tag2 === "tbody" || tag2 === "tfoot" || tag2 === "thead" || tag2 === "style" || tag2 === "script" || tag2 === "template";
                case "head":
                  return tag2 === "base" || tag2 === "basefont" || tag2 === "bgsound" || tag2 === "link" || tag2 === "meta" || tag2 === "title" || tag2 === "noscript" || tag2 === "noframes" || tag2 === "style" || tag2 === "script" || tag2 === "template";
                case "html":
                  return tag2 === "head" || tag2 === "body" || tag2 === "frameset";
                case "frameset":
                  return tag2 === "frame";
                case "#document":
                  return tag2 === "html";
              }
              switch (tag2) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag2, ancestorInfo) {
              switch (tag2) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root3 = rootContainerInstance.documentElement;
                namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement2(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error2) {
            setTimeout(function() {
              throw error2;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
            if (container.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container.parentNode, suspenseInstance);
            } else if (container.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container, suspenseInstance);
            }
            retryIfBlockedOn(container);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
              container.textContent = "";
            } else if (container.nodeType === DOCUMENT_NODE) {
              if (container.documentElement) {
                container.removeChild(container.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values2, location, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty3);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
              fiberStack[index] = null;
            }
            index--;
          }
          function push(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
              fiberStack[index] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name297 = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name297);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name297 = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name297);
              }
              return assign2({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component2 = node.type;
                    if (isContextProvider(Component2)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error2;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index2) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index2 + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length | _id;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number) {
            return 32 - clz32(number);
          }
          function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null)
                    didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null)
                    switch (fiber.tag) {
                      case HostComponent:
                        var _type2 = fiber.type;
                        var _props2 = fiber.pendingProps;
                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                        break;
                      case HostText:
                        var _text2 = fiber.pendingProps;
                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                        break;
                    }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error2) {
            if (hydrationErrors === null) {
              hydrationErrors = [error2];
            } else {
              hydrationErrors.push(error2);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array = [];
              set2.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = assign2({}, baseProps);
              var defaultProps = Component2.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null)
                        ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies298 = workInProgress2.dependencies;
            if (dependencies298 !== null) {
              {
                var firstContext = dependencies298.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies298.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies298.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context)
              ;
            else {
              var contextItem = {
                context,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i = 0; i < concurrentQueues.length; i++) {
                var queue = concurrentQueues[i];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root3 = node.stateNode;
              return root3;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone3 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone3;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root3, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone3 = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone3;
                    } else {
                      newLast.next = clone3;
                      newLast = clone3;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign2({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone3 = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone3;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone3;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null && update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect = effects[i];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var emptyRefsObject = new React3.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name297 = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name297);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name297);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name297);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name297);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name297);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name297);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name297);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name297);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name297);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name297);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name297);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name297);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name297);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name297, name297);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name297, name297);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name297);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name297);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name297);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray2(_state))) {
                error("%s.state: must be set to an object or null", name297);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name297);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = resolvedInst.refs;
                  if (refs === emptyRefsObject) {
                    refs = resolvedInst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init = lazyType._init;
            return init(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone3 = createWorkInProgress(fiber, pendingProps);
              clone3.index = 0;
              clone3.sibling = null;
              return clone3;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment2) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return createChild(returnFiber, init(payload), lanes);
                  }
                }
                if (isArray2(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                  }
                }
                if (isArray2(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                }
                if (isArray2(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init = child._init;
                    warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment2) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
                }
                if (isArray2(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (c === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = 0;
          var HasEffect = 1;
          var Insertion = 2;
          var Layout = 4;
          var Passive$1 = 8;
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root3, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version2 = getVersion(mutableSource._source);
            if (root3.mutableSourceEagerHydrationData == null) {
              root3.mutableSourceEagerHydrationData = [mutableSource, version2];
            } else {
              root3.mutableSourceEagerHydrationData.push(mutableSource, version2);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray2(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component2(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component2(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {
                error("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== void 0) {
              initialState = init(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone3 = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone3;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone3;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag2, create2, destroy, deps) {
            var effect = {
              tag: tag2,
              create: create2,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create2, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, destroy, nextDeps);
          }
          function mountEffect(create2, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create2, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create2, deps);
            }
          }
          function updateEffect(create2, deps) {
            return updateEffectImpl(Passive, Passive$1, create2, deps);
          }
          function mountInsertionEffect(create2, deps) {
            return mountEffectImpl(Update, Insertion, create2, deps);
          }
          function updateInsertionEffect(create2, deps) {
            return updateEffectImpl(Update, Insertion, create2, deps);
          }
          function mountLayoutEffect(create2, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create2, deps);
          }
          function updateLayoutEffect(create2, deps) {
            return updateEffectImpl(Update, Layout, create2, deps);
          }
          function imperativeHandleEffect(create2, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create2();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create2();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create2, deps) {
            {
              if (typeof create2 !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create2, deps) {
            {
              if (typeof create2 !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback, options2) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start;
            return [isPending, start];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root3 = getWorkInProgressRoot();
            var identifierPrefix = root3.identifierPrefix;
            var id;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id += "H" + localId.toString(32);
              }
              id += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id;
            return id;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id = hook.memoizedState;
            return id;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root3, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create2, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create2, deps);
              },
              useImperativeHandle: function(ref, create2, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create2, deps);
              },
              useInsertionEffect: function(create2, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create2, deps);
              },
              useLayoutEffect: function(create2, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create2, deps);
              },
              useMemo: function(create2, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create2, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    root3.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    if (root3 !== null) {
                      root3.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error2 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error2 != null && error2._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error2);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error2);
              }
            } catch (e2) {
              setTimeout(function() {
                throw e2;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error2);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root3, wakeable, lanes) {
            var pingCache = root3.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root3.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root3, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag2 = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag2 === FunctionComponent || tag2 === ForwardRef || tag2 === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root3, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root3, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var render2 = Component2.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component2.type;
              if (isSimpleFunctionComponent(type) && Component2.compare === null && Component2.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component2.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component2.compare;
              compare = compare !== null ? compare : shallowEqual;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    outerMemoType = init(payload);
                  } catch (x) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component2, nextProps);
              mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component2, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component2, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root3 = workInProgress2.stateNode;
            if (root3.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
            } else if (root3.context) {
              pushTopLevelContextObject(workInProgress2, root3.context, false);
            }
            pushHostContainer(workInProgress2, root3.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root3 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component2 = init(payload);
            workInProgress2.type = Component2;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
            var resolvedProps = resolveDefaultProps(Component2, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component2);
                  workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
                }
                child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
                }
                child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
                }
                child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        "prop",
                        getComponentNameFromType(Component2)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component2,
                  resolveDefaultProps(Component2.type, resolvedProps),
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component2)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component2, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error2;
                if (message) {
                  error2 = new Error(message);
                } else {
                  error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error2, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root3 = getWorkInProgressRoot();
                if (root3 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index2) {
            {
              var isAnArray = isArray2(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray2(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    _tail,
                    null,
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    null,
                    null,
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root3 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  if (state.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component2 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultProps(Component2, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component2, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment2:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment2:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root3 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root3 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error2) {
            {
              invokeGuardedCallback(null, function() {
                throw error2;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error2) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root3, firstChild) {
            focusedInstanceHandle = prepareForCommit(root3.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root3 = finishedWork.stateNode;
                    clearContainer(root3.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create2 = effect.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect.destroy = create2();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root3 = parentFiber.stateNode;
                            root3.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer:
                        while (parentFiber !== null) {
                          switch (parentFiber.tag) {
                            case HostRoot:
                              var root3 = parentFiber.stateNode;
                              root3.effectDuration += effectDuration;
                              break outer;
                            case Profiler:
                              var parentStateNode = parentFiber.stateNode;
                              parentStateNode.effectDuration += effectDuration;
                              break outer;
                          }
                          parentFiber = parentFiber.return;
                        }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag2 = node.tag;
            var isHost = tag2 === HostComponent || tag2 === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag2 === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag2 = node.tag;
            var isHost = tag2 === HostComponent || tag2 === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag2 === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root3, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent:
                while (parent !== null) {
                  switch (parent.tag) {
                    case HostComponent: {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break findParent;
                    }
                    case HostRoot: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                    case HostPortal: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                  }
                  parent = parent.return;
                }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect = firstEffect;
                      do {
                        var _effect = effect, destroy = _effect.destroy, tag2 = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag2 & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag2 & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect = effect.next;
                      } while (effect !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (deletedFiber.mode & ConcurrentMode) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root3, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root3);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                try {
                  commitDeletionEffects(root3, parentFiber, childToDelete);
                } catch (error2) {
                  captureCommitPhaseError(childToDelete, parentFiber, error2);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root3);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root3.containerInfo);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (finishedWork.mode & ConcurrentMode) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root3, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root3, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      root3,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i = 0; i < deletions.length; i++) {
                    var fiberToDelete = deletions[i];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil2 = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = 0;
          var BatchedContext = 1;
          var RenderContext = 2;
          var CommitContext = 4;
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root3, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root3, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root3 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root3, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root3, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
            var current2 = root3.current;
            current2.lanes = lane;
            markRootUpdated(root3, lane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (executionContext & RenderContext) !== NoContext;
          }
          function ensureRootIsScheduled(root3, currentTime) {
            var existingCallbackNode = root3.callbackNode;
            markStarvedLanesAsExpired(root3, currentTime);
            var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root3.callbackNode = null;
              root3.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root3.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root3.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
            }
            root3.callbackPriority = newCallbackPriority;
            root3.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root3, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root3.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root3.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root3, NoLanes);
                markRootSuspended$1(root3, lanes);
                ensureRootIsScheduled(root3, now());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root3, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root3, lanes);
                var finishedWork = root3.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root3, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root3, NoLanes);
                    markRootSuspended$1(root3, lanes);
                    ensureRootIsScheduled(root3, now());
                    throw _fatalError;
                  }
                }
                root3.finishedWork = finishedWork;
                root3.finishedLanes = lanes;
                finishConcurrentRender(root3, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root3, now());
            if (root3.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root3);
            }
            return null;
          }
          function recoverFromConcurrentError(root3, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root3)) {
              var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root3.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root3, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root3, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root3, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root3.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root3, suspendedLanes);
                      break;
                    }
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i = 0; i < checks.length; i++) {
                      var check = checks[i];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error2) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root3, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root3, suspendedLanes);
          }
          function performSyncWorkOnRoot(root3) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root3, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root3, now());
              return null;
            }
            var exitStatus = renderRootSync(root3, lanes);
            if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root3, NoLanes);
              markRootSuspended$1(root3, lanes);
              ensureRootIsScheduled(root3, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root3.current.alternate;
            root3.finishedWork = finishedWork;
            root3.finishedLanes = lanes;
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root3, now());
            return null;
          }
          function flushRoot(root3, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root3, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root3, now());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn, a, b, c, d) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn(a, b, c, d);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync(fn) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn) {
                return fn();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root3, lanes) {
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            var timeoutHandle = root3.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root3.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root3;
            var rootWorkInProgress = createWorkInProgress(root3.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root3, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error2) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error2];
            } else {
              workInProgressRootConcurrentErrors.push(error2);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root3, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root3.finishedWork;
            var lanes = root3.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            if (finishedWork === root3.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root3.callbackNode = null;
            root3.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root3, remainingLanes);
            if (root3 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root3, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root3, finishedWork, lanes);
              resetAfterCommit(root3.containerInfo);
              root3.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root3, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root3.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root3;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root3.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root3.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root3.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root3, now());
            if (recoverableErrors !== null) {
              var onRecoverableError = root3.onRecoverableError;
              for (var i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root3.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root3 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root3;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root3 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root3.current);
            commitPassiveMountEffects(root3, root3.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i = 0; i < profilerEffects.length; i++) {
                var _fiber = profilerEffects[i];
                commitPassiveEffectDurations(root3, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root3.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root3 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root3;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root3);
            {
              var stateNode = root3.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root3 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root3 !== null) {
              markRootUpdated(root3, SyncLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root3 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root3 !== null) {
                    markRootUpdated(root3, SyncLane, eventTime);
                    ensureRootIsScheduled(root3, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root3, wakeable, pingedLanes) {
            var pingCache = root3.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root3, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
            if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root3, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root3, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root3 !== null) {
              markRootUpdated(root3, retryLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil2(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag2 = fiber.tag;
              if (tag2 !== IndeterminateComponent && tag2 !== HostRoot && tag2 !== ClassComponent && tag2 !== FunctionComponent && tag2 !== ForwardRef && tag2 !== MemoComponent && tag2 !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root3, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root3, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
            {
              if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root3, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root3, element) {
            {
              if (root3.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root3, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag2 = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag2) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag2 === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root3, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root3.current, types, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag2 = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag2) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e2) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag2, pendingProps, key, mode) {
            this.tag = tag2;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag2, pendingProps, key, mode) {
            return new FiberNode(tag2, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component2) {
            if (typeof Component2 === "function") {
              return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
            } else if (Component2 !== void 0 && Component2 !== null) {
              var $$typeof = Component2.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag2, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag2 === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictLegacyMode;
                    if ((mode & ConcurrentMode) !== NoMode) {
                      mode |= StrictEffectsMode;
                    }
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                  case REACT_SCOPE_TYPE:
                  case REACT_CACHE_TYPE:
                  case REACT_TRACING_MARKER_TYPE:
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment2, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag2, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag2;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag2) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag2, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root3 = new FiberRootNode(containerInfo, tag2, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag2, isStrictMode);
            root3.current = uninitializedFiber;
            uninitializedFiber.stateNode = root3;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root3;
          }
          var ReactVersion = "18.2.0";
          function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component2 = fiber.type;
              if (isContextProvider(Component2)) {
                return processChildContext(fiber, Component2, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag2, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag2, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag2, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root3 = createFiberRoot(containerInfo, tag2, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root3.context = getContextForSubtree(null);
            var current2 = root3.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root3, lane, eventTime);
            return root3;
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context;
            } else {
              container.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            var root3 = enqueueUpdate(current$1, update, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
              entangleTransitions(root3, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root3 = fiber.stateNode;
                if (isRootDehydrated(root3)) {
                  var lanes = getHighestPriorityPendingLanes(root3);
                  flushRoot(root3, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync(function() {
                  var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root4 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index2) {
              var key = path[index2];
              var updated = isArray2(obj) ? obj.slice() : assign2({}, obj);
              if (index2 + 1 === path.length) {
                if (isArray2(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
              var oldKey = oldPath[index2];
              var updated = isArray2(obj) ? obj.slice() : assign2({}, obj);
              if (index2 + 1 === oldPath.length) {
                var newKey = newPath[index2];
                updated[newKey] = updated[oldKey];
                if (isArray2(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index2 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index2, value) {
              if (index2 >= path.length) {
                return value;
              }
              var key = path[index2];
              var updated = isArray2(obj) ? obj.slice() : assign2({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id, path, value) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id, path) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: getCurrentFiberForDevTools,
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? reportError : function(error2) {
            console["error"](error2);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root3 = this._internalRoot;
            if (root3 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container = root3.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root3.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root3, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root3 = this._internalRoot;
            if (root3 !== null) {
              this._internalRoot = null;
              var container = root3.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync(function() {
                updateContainer(null, root3, null, null);
              });
              unmarkContainerAsRoot(container);
            }
          };
          function createRoot2(container, options2) {
            if (!isValidContainer(container)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options2 !== null && options2 !== void 0) {
              {
                if (options2.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                    error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
              if (options2.transitionCallbacks !== void 0) {
                transitionCallbacks = options2.transitionCallbacks;
              }
            }
            var root3 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root3);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container, initialChildren, options2) {
            if (!isValidContainer(container)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            {
              if (initialChildren === void 0) {
                error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options2 != null ? options2 : null;
            var mutableSources = options2 != null && options2.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options2 !== null && options2 !== void 0) {
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
            }
            var root3 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container);
            listenToAllSupportedEvents(container);
            if (mutableSources) {
              for (var i = 0; i < mutableSources.length; i++) {
                var mutableSource = mutableSources[i];
                registerMutableSourceForHydration(root3, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root3);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container) {
            {
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container)) {
                if (container._reactRootContainer) {
                  error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              var root3 = createHydrationContainer(
                initialChildren,
                callback,
                container,
                LegacyRoot,
                null,
                false,
                false,
                "",
                noopOnRecoverableError
              );
              container._reactRootContainer = root3;
              markContainerAsRoot(root3.current, container);
              var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync();
              return root3;
            } else {
              var rootSibling;
              while (rootSibling = container.lastChild) {
                container.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container,
                LegacyRoot,
                null,
                false,
                false,
                "",
                noopOnRecoverableError
              );
              container._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container);
              var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync(function() {
                updateContainer(initialChildren, _root, parentComponent, callback);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container._reactRootContainer;
            var root3;
            if (!maybeRoot) {
              root3 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
            } else {
              root3 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root3, parentComponent, callback);
            }
            return getPublicRootInstance(root3);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container, callback) {
            {
              error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render(element, container, callback) {
            {
              error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container) {
            if (!isValidContainerLegacy(container)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
          function createPortal$1(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal(children, container, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot2(container, options2);
          }
          function hydrateRoot$1(container, initialChildren, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container, initialChildren, options2);
          }
          function flushSync$1(fn) {
            {
              if (isAlreadyRendering()) {
                error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync(fn);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m = require_react_dom();
      if (false) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // node_modules/typed-function/lib/umd/typed-function.js
  var require_typed_function = __commonJS({
    "node_modules/typed-function/lib/umd/typed-function.js"(exports, module) {
      (function(global, factory2) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.typed = factory2());
      })(exports, function() {
        "use strict";
        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
              if (it)
                o = it;
              var i = 0;
              var F = function F2() {
              };
              return { s: F, n: function n() {
                if (i >= o.length)
                  return { done: true };
                return { done: false, value: o[i++] };
              }, e: function e2(_e) {
                throw _e;
              }, f: F };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var normalCompletion = true, didErr = false, err;
          return { s: function s() {
            it = it.call(o);
          }, n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          }, e: function e2(_e2) {
            didErr = true;
            err = _e2;
          }, f: function f() {
            try {
              if (!normalCompletion && it.return != null)
                it.return();
            } finally {
              if (didErr)
                throw err;
            }
          } };
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof(obj);
        }
        function ok() {
          return true;
        }
        function notOk() {
          return false;
        }
        function undef() {
          return void 0;
        }
        var NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
        function create2() {
          function isPlainObject2(x) {
            return _typeof(x) === "object" && x !== null && x.constructor === Object;
          }
          var _types = [{
            name: "number",
            test: function test(x) {
              return typeof x === "number";
            }
          }, {
            name: "string",
            test: function test(x) {
              return typeof x === "string";
            }
          }, {
            name: "boolean",
            test: function test(x) {
              return typeof x === "boolean";
            }
          }, {
            name: "Function",
            test: function test(x) {
              return typeof x === "function";
            }
          }, {
            name: "Array",
            test: Array.isArray
          }, {
            name: "Date",
            test: function test(x) {
              return x instanceof Date;
            }
          }, {
            name: "RegExp",
            test: function test(x) {
              return x instanceof RegExp;
            }
          }, {
            name: "Object",
            test: isPlainObject2
          }, {
            name: "null",
            test: function test(x) {
              return x === null;
            }
          }, {
            name: "undefined",
            test: function test(x) {
              return x === void 0;
            }
          }];
          var anyType = {
            name: "any",
            test: ok,
            isAny: true
          };
          var typeMap;
          var typeList;
          var nConversions = 0;
          var typed = {
            createCount: 0
          };
          function findType(typeName) {
            var type = typeMap.get(typeName);
            if (type) {
              return type;
            }
            var message = 'Unknown type "' + typeName + '"';
            var name297 = typeName.toLowerCase();
            var otherName;
            var _iterator = _createForOfIteratorHelper(typeList), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                otherName = _step.value;
                if (otherName.toLowerCase() === name297) {
                  message += '. Did you mean "' + otherName + '" ?';
                  break;
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            throw new TypeError(message);
          }
          function addTypes(types) {
            var beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
            var beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
            var newTypes = [];
            for (var i = 0; i < types.length; ++i) {
              if (!types[i] || typeof types[i].name !== "string" || typeof types[i].test !== "function") {
                throw new TypeError("Object with properties {name: string, test: function} expected");
              }
              var typeName = types[i].name;
              if (typeMap.has(typeName)) {
                throw new TypeError('Duplicate type name "' + typeName + '"');
              }
              newTypes.push(typeName);
              typeMap.set(typeName, {
                name: typeName,
                test: types[i].test,
                isAny: types[i].isAny,
                index: beforeIndex + i,
                conversionsTo: []
              });
            }
            var affectedTypes = typeList.slice(beforeIndex);
            typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
            for (var _i = beforeIndex + newTypes.length; _i < typeList.length; ++_i) {
              typeMap.get(typeList[_i]).index = _i;
            }
          }
          function clear() {
            typeMap = /* @__PURE__ */ new Map();
            typeList = [];
            nConversions = 0;
            addTypes([anyType], false);
          }
          clear();
          addTypes(_types);
          function clearConversions() {
            var typeName;
            var _iterator2 = _createForOfIteratorHelper(typeList), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                typeName = _step2.value;
                typeMap.get(typeName).conversionsTo = [];
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            nConversions = 0;
          }
          function findTypeNames(value) {
            var matches = typeList.filter(function(name297) {
              var type = typeMap.get(name297);
              return !type.isAny && type.test(value);
            });
            if (matches.length) {
              return matches;
            }
            return ["any"];
          }
          function isTypedFunction(entity) {
            return entity && typeof entity === "function" && "_typedFunctionData" in entity;
          }
          function findSignature(fn, signature, options) {
            if (!isTypedFunction(fn)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            var exact = options && options.exact;
            var stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
            var params = parseSignature(stringSignature);
            var canonicalSignature = stringifyParams(params);
            if (!exact || canonicalSignature in fn.signatures) {
              var match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
              if (match) {
                return match;
              }
            }
            var nParams = params.length;
            var remainingSignatures;
            if (exact) {
              remainingSignatures = [];
              var name297;
              for (name297 in fn.signatures) {
                remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name297));
              }
            } else {
              remainingSignatures = fn._typedFunctionData.signatures;
            }
            for (var i = 0; i < nParams; ++i) {
              var want = params[i];
              var filteredSignatures = [];
              var possibility = void 0;
              var _iterator3 = _createForOfIteratorHelper(remainingSignatures), _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                  possibility = _step3.value;
                  var have = getParamAtIndex(possibility.params, i);
                  if (!have || want.restParam && !have.restParam) {
                    continue;
                  }
                  if (!have.hasAny) {
                    var _ret = function() {
                      var haveTypes = paramTypeSet(have);
                      if (want.types.some(function(wtype) {
                        return !haveTypes.has(wtype.name);
                      })) {
                        return "continue";
                      }
                    }();
                    if (_ret === "continue")
                      continue;
                  }
                  filteredSignatures.push(possibility);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              remainingSignatures = filteredSignatures;
              if (remainingSignatures.length === 0)
                break;
            }
            var candidate;
            var _iterator4 = _createForOfIteratorHelper(remainingSignatures), _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                candidate = _step4.value;
                if (candidate.params.length <= nParams) {
                  return candidate;
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
          }
          function find(fn, signature, options) {
            return findSignature(fn, signature, options).implementation;
          }
          function convert(value, typeName) {
            var type = findType(typeName);
            if (type.test(value)) {
              return value;
            }
            var conversions = type.conversionsTo;
            if (conversions.length === 0) {
              throw new Error("There are no conversions to " + typeName + " defined.");
            }
            for (var i = 0; i < conversions.length; i++) {
              var fromType = findType(conversions[i].from);
              if (fromType.test(value)) {
                return conversions[i].convert(value);
              }
            }
            throw new Error("Cannot convert " + value + " to " + typeName);
          }
          function stringifyParams(params) {
            var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
            return params.map(function(p) {
              return p.name;
            }).join(separator);
          }
          function parseParam(param) {
            var restParam = param.indexOf("...") === 0;
            var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
            var typeDefs = types.split("|").map(function(s) {
              return findType(s.trim());
            });
            var hasAny = false;
            var paramName = restParam ? "..." : "";
            var exactTypes = typeDefs.map(function(type) {
              hasAny = type.isAny || hasAny;
              paramName += type.name + "|";
              return {
                name: type.name,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion: null,
                conversionIndex: -1
              };
            });
            return {
              types: exactTypes,
              name: paramName.slice(0, -1),
              hasAny,
              hasConversion: false,
              restParam
            };
          }
          function expandParam(param) {
            var typeNames = param.types.map(function(t) {
              return t.name;
            });
            var matchingConversions = availableConversions(typeNames);
            var hasAny = param.hasAny;
            var newName = param.name;
            var convertibleTypes = matchingConversions.map(function(conversion) {
              var type = findType(conversion.from);
              hasAny = type.isAny || hasAny;
              newName += "|" + conversion.from;
              return {
                name: conversion.from,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion,
                conversionIndex: conversion.index
              };
            });
            return {
              types: param.types.concat(convertibleTypes),
              name: newName,
              hasAny,
              hasConversion: convertibleTypes.length > 0,
              restParam: param.restParam
            };
          }
          function paramTypeSet(param) {
            if (!param.typeSet) {
              param.typeSet = /* @__PURE__ */ new Set();
              param.types.forEach(function(type) {
                return param.typeSet.add(type.name);
              });
            }
            return param.typeSet;
          }
          function parseSignature(rawSignature) {
            var params = [];
            if (typeof rawSignature !== "string") {
              throw new TypeError("Signatures must be strings");
            }
            var signature = rawSignature.trim();
            if (signature === "") {
              return params;
            }
            var rawParams = signature.split(",");
            for (var i = 0; i < rawParams.length; ++i) {
              var parsedParam = parseParam(rawParams[i].trim());
              if (parsedParam.restParam && i !== rawParams.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + rawParams[i] + '": only allowed for the last parameter');
              }
              if (parsedParam.types.length === 0) {
                return null;
              }
              params.push(parsedParam);
            }
            return params;
          }
          function hasRestParam(params) {
            var param = last(params);
            return param ? param.restParam : false;
          }
          function compileTest(param) {
            if (!param || param.types.length === 0) {
              return ok;
            } else if (param.types.length === 1) {
              return findType(param.types[0].name).test;
            } else if (param.types.length === 2) {
              var test0 = findType(param.types[0].name).test;
              var test1 = findType(param.types[1].name).test;
              return function or(x) {
                return test0(x) || test1(x);
              };
            } else {
              var tests = param.types.map(function(type) {
                return findType(type.name).test;
              });
              return function or(x) {
                for (var i = 0; i < tests.length; i++) {
                  if (tests[i](x)) {
                    return true;
                  }
                }
                return false;
              };
            }
          }
          function compileTests(params) {
            var tests, test0, test1;
            if (hasRestParam(params)) {
              tests = initial(params).map(compileTest);
              var varIndex = tests.length;
              var lastTest = compileTest(last(params));
              var testRestParam = function testRestParam2(args) {
                for (var i = varIndex; i < args.length; i++) {
                  if (!lastTest(args[i])) {
                    return false;
                  }
                }
                return true;
              };
              return function testArgs(args) {
                for (var i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return testRestParam(args) && args.length >= varIndex + 1;
              };
            } else {
              if (params.length === 0) {
                return function testArgs(args) {
                  return args.length === 0;
                };
              } else if (params.length === 1) {
                test0 = compileTest(params[0]);
                return function testArgs(args) {
                  return test0(args[0]) && args.length === 1;
                };
              } else if (params.length === 2) {
                test0 = compileTest(params[0]);
                test1 = compileTest(params[1]);
                return function testArgs(args) {
                  return test0(args[0]) && test1(args[1]) && args.length === 2;
                };
              } else {
                tests = params.map(compileTest);
                return function testArgs(args) {
                  for (var i = 0; i < tests.length; i++) {
                    if (!tests[i](args[i])) {
                      return false;
                    }
                  }
                  return args.length === tests.length;
                };
              }
            }
          }
          function getParamAtIndex(params, index) {
            return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;
          }
          function getTypeSetAtIndex(params, index) {
            var param = getParamAtIndex(params, index);
            if (!param) {
              return /* @__PURE__ */ new Set();
            }
            return paramTypeSet(param);
          }
          function isExactType(type) {
            return type.conversion === null || type.conversion === void 0;
          }
          function mergeExpectedParams(signatures, index) {
            var typeSet = /* @__PURE__ */ new Set();
            signatures.forEach(function(signature) {
              var paramSet = getTypeSetAtIndex(signature.params, index);
              var name297;
              var _iterator5 = _createForOfIteratorHelper(paramSet), _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                  name297 = _step5.value;
                  typeSet.add(name297);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            });
            return typeSet.has("any") ? ["any"] : Array.from(typeSet);
          }
          function createError(name297, args, signatures) {
            var err, expected;
            var _name = name297 || "unnamed";
            var matchingSignatures = signatures;
            var index;
            var _loop = function _loop2() {
              var nextMatchingDefs = [];
              matchingSignatures.forEach(function(signature) {
                var param = getParamAtIndex(signature.params, index);
                var test = compileTest(param);
                if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {
                  nextMatchingDefs.push(signature);
                }
              });
              if (nextMatchingDefs.length === 0) {
                expected = mergeExpectedParams(matchingSignatures, index);
                if (expected.length > 0) {
                  var actualTypes = findTypeNames(args[index]);
                  err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index + ")");
                  err.data = {
                    category: "wrongType",
                    fn: _name,
                    index,
                    actual: actualTypes,
                    expected
                  };
                  return {
                    v: err
                  };
                }
              } else {
                matchingSignatures = nextMatchingDefs;
              }
            };
            for (index = 0; index < args.length; index++) {
              var _ret2 = _loop();
              if (_typeof(_ret2) === "object")
                return _ret2.v;
            }
            var lengths = matchingSignatures.map(function(signature) {
              return hasRestParam(signature.params) ? Infinity : signature.params.length;
            });
            if (args.length < Math.min.apply(null, lengths)) {
              expected = mergeExpectedParams(matchingSignatures, index);
              err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
              err.data = {
                category: "tooFewArgs",
                fn: _name,
                index: args.length,
                expected
              };
              return err;
            }
            var maxLength = Math.max.apply(null, lengths);
            if (args.length > maxLength) {
              err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
              err.data = {
                category: "tooManyArgs",
                fn: _name,
                index: args.length,
                expectedLength: maxLength
              };
              return err;
            }
            var argTypes = [];
            for (var i = 0; i < args.length; ++i) {
              argTypes.push(findTypeNames(args[i]).join("|"));
            }
            err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
            err.data = {
              category: "mismatch",
              actual: argTypes
            };
            return err;
          }
          function getLowestTypeIndex(param) {
            var min2 = typeList.length + 1;
            for (var i = 0; i < param.types.length; i++) {
              if (isExactType(param.types[i])) {
                min2 = Math.min(min2, param.types[i].typeIndex);
              }
            }
            return min2;
          }
          function getLowestConversionIndex(param) {
            var min2 = nConversions + 1;
            for (var i = 0; i < param.types.length; i++) {
              if (!isExactType(param.types[i])) {
                min2 = Math.min(min2, param.types[i].conversionIndex);
              }
            }
            return min2;
          }
          function compareParams(param1, param2) {
            if (param1.hasAny) {
              if (!param2.hasAny) {
                return 1;
              }
            } else if (param2.hasAny) {
              return -1;
            }
            if (param1.restParam) {
              if (!param2.restParam) {
                return 1;
              }
            } else if (param2.restParam) {
              return -1;
            }
            if (param1.hasConversion) {
              if (!param2.hasConversion) {
                return 1;
              }
            } else if (param2.hasConversion) {
              return -1;
            }
            var typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
            if (typeDiff < 0) {
              return -1;
            }
            if (typeDiff > 0) {
              return 1;
            }
            var convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
            if (convDiff < 0) {
              return -1;
            }
            if (convDiff > 0) {
              return 1;
            }
            return 0;
          }
          function compareSignatures(signature1, signature2) {
            var pars1 = signature1.params;
            var pars2 = signature2.params;
            var last1 = last(pars1);
            var last2 = last(pars2);
            var hasRest1 = hasRestParam(pars1);
            var hasRest2 = hasRestParam(pars2);
            if (hasRest1 && last1.hasAny) {
              if (!hasRest2 || !last2.hasAny) {
                return 1;
              }
            } else if (hasRest2 && last2.hasAny) {
              return -1;
            }
            var any1 = 0;
            var conv1 = 0;
            var par;
            var _iterator6 = _createForOfIteratorHelper(pars1), _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                par = _step6.value;
                if (par.hasAny)
                  ++any1;
                if (par.hasConversion)
                  ++conv1;
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            var any2 = 0;
            var conv2 = 0;
            var _iterator7 = _createForOfIteratorHelper(pars2), _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                par = _step7.value;
                if (par.hasAny)
                  ++any2;
                if (par.hasConversion)
                  ++conv2;
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            if (any1 !== any2) {
              return any1 - any2;
            }
            if (hasRest1 && last1.hasConversion) {
              if (!hasRest2 || !last2.hasConversion) {
                return 1;
              }
            } else if (hasRest2 && last2.hasConversion) {
              return -1;
            }
            if (conv1 !== conv2) {
              return conv1 - conv2;
            }
            if (hasRest1) {
              if (!hasRest2) {
                return 1;
              }
            } else if (hasRest2) {
              return -1;
            }
            var lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
            if (lengthCriterion !== 0) {
              return lengthCriterion;
            }
            var comparisons = [];
            var tc = 0;
            for (var i = 0; i < pars1.length; ++i) {
              var thisComparison = compareParams(pars1[i], pars2[i]);
              comparisons.push(thisComparison);
              tc += thisComparison;
            }
            if (tc !== 0) {
              return tc;
            }
            var c;
            for (var _i2 = 0, _comparisons = comparisons; _i2 < _comparisons.length; _i2++) {
              c = _comparisons[_i2];
              if (c !== 0) {
                return c;
              }
            }
            return 0;
          }
          function availableConversions(typeNames) {
            if (typeNames.length === 0) {
              return [];
            }
            var types = typeNames.map(findType);
            if (typeNames.length > 1) {
              types.sort(function(t1, t2) {
                return t1.index - t2.index;
              });
            }
            var matches = types[0].conversionsTo;
            if (typeNames.length === 1) {
              return matches;
            }
            matches = matches.concat([]);
            var knownTypes = new Set(typeNames);
            for (var i = 1; i < types.length; ++i) {
              var newMatch = void 0;
              var _iterator8 = _createForOfIteratorHelper(types[i].conversionsTo), _step8;
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                  newMatch = _step8.value;
                  if (!knownTypes.has(newMatch.from)) {
                    matches.push(newMatch);
                    knownTypes.add(newMatch.from);
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }
            return matches;
          }
          function compileArgsPreprocessing(params, fn) {
            var fnConvert = fn;
            if (params.some(function(p) {
              return p.hasConversion;
            })) {
              var restParam = hasRestParam(params);
              var compiledConversions = params.map(compileArgConversion);
              fnConvert = function convertArgs() {
                var args = [];
                var last2 = restParam ? arguments.length - 1 : arguments.length;
                for (var i = 0; i < last2; i++) {
                  args[i] = compiledConversions[i](arguments[i]);
                }
                if (restParam) {
                  args[last2] = arguments[last2].map(compiledConversions[last2]);
                }
                return fn.apply(this, args);
              };
            }
            var fnPreprocess = fnConvert;
            if (hasRestParam(params)) {
              var offset = params.length - 1;
              fnPreprocess = function preprocessRestParams() {
                return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
              };
            }
            return fnPreprocess;
          }
          function compileArgConversion(param) {
            var test0, test1, conversion0, conversion1;
            var tests = [];
            var conversions = [];
            param.types.forEach(function(type) {
              if (type.conversion) {
                tests.push(findType(type.conversion.from).test);
                conversions.push(type.conversion.convert);
              }
            });
            switch (conversions.length) {
              case 0:
                return function convertArg(arg) {
                  return arg;
                };
              case 1:
                test0 = tests[0];
                conversion0 = conversions[0];
                return function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  return arg;
                };
              case 2:
                test0 = tests[0];
                test1 = tests[1];
                conversion0 = conversions[0];
                conversion1 = conversions[1];
                return function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  if (test1(arg)) {
                    return conversion1(arg);
                  }
                  return arg;
                };
              default:
                return function convertArg(arg) {
                  for (var i = 0; i < conversions.length; i++) {
                    if (tests[i](arg)) {
                      return conversions[i](arg);
                    }
                  }
                  return arg;
                };
            }
          }
          function splitParams(params) {
            function _splitParams(params2, index, paramsSoFar) {
              if (index < params2.length) {
                var param = params2[index];
                var resultingParams = [];
                if (param.restParam) {
                  var exactTypes = param.types.filter(isExactType);
                  if (exactTypes.length < param.types.length) {
                    resultingParams.push({
                      types: exactTypes,
                      name: "..." + exactTypes.map(function(t) {
                        return t.name;
                      }).join("|"),
                      hasAny: exactTypes.some(function(t) {
                        return t.isAny;
                      }),
                      hasConversion: false,
                      restParam: true
                    });
                  }
                  resultingParams.push(param);
                } else {
                  resultingParams = param.types.map(function(type) {
                    return {
                      types: [type],
                      name: type.name,
                      hasAny: type.isAny,
                      hasConversion: type.conversion,
                      restParam: false
                    };
                  });
                }
                return flatMap(resultingParams, function(nextParam) {
                  return _splitParams(params2, index + 1, paramsSoFar.concat([nextParam]));
                });
              } else {
                return [paramsSoFar];
              }
            }
            return _splitParams(params, 0, []);
          }
          function conflicting(params1, params2) {
            var ii = Math.max(params1.length, params2.length);
            for (var i = 0; i < ii; i++) {
              var typeSet1 = getTypeSetAtIndex(params1, i);
              var typeSet2 = getTypeSetAtIndex(params2, i);
              var overlap = false;
              var name297 = void 0;
              var _iterator9 = _createForOfIteratorHelper(typeSet2), _step9;
              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                  name297 = _step9.value;
                  if (typeSet1.has(name297)) {
                    overlap = true;
                    break;
                  }
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
              if (!overlap) {
                return false;
              }
            }
            var len1 = params1.length;
            var len2 = params2.length;
            var restParam1 = hasRestParam(params1);
            var restParam2 = hasRestParam(params2);
            return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
          }
          function clearResolutions(functionList) {
            return functionList.map(function(fn) {
              if (isReferToSelf(fn)) {
                return referToSelf(fn.referToSelf.callback);
              }
              if (isReferTo(fn)) {
                return makeReferTo(fn.referTo.references, fn.referTo.callback);
              }
              return fn;
            });
          }
          function collectResolutions(references, functionList, signatureMap) {
            var resolvedReferences = [];
            var reference;
            var _iterator10 = _createForOfIteratorHelper(references), _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                reference = _step10.value;
                var resolution = signatureMap[reference];
                if (typeof resolution !== "number") {
                  throw new TypeError('No definition for referenced signature "' + reference + '"');
                }
                resolution = functionList[resolution];
                if (typeof resolution !== "function") {
                  return false;
                }
                resolvedReferences.push(resolution);
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            return resolvedReferences;
          }
          function resolveReferences(functionList, signatureMap, self2) {
            var resolvedFunctions = clearResolutions(functionList);
            var isResolved = new Array(resolvedFunctions.length).fill(false);
            var leftUnresolved = true;
            while (leftUnresolved) {
              leftUnresolved = false;
              var nothingResolved = true;
              for (var i = 0; i < resolvedFunctions.length; ++i) {
                if (isResolved[i])
                  continue;
                var fn = resolvedFunctions[i];
                if (isReferToSelf(fn)) {
                  resolvedFunctions[i] = fn.referToSelf.callback(self2);
                  resolvedFunctions[i].referToSelf = fn.referToSelf;
                  isResolved[i] = true;
                  nothingResolved = false;
                } else if (isReferTo(fn)) {
                  var resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
                  if (resolvedReferences) {
                    resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences);
                    resolvedFunctions[i].referTo = fn.referTo;
                    isResolved[i] = true;
                    nothingResolved = false;
                  } else {
                    leftUnresolved = true;
                  }
                }
              }
              if (nothingResolved && leftUnresolved) {
                throw new SyntaxError("Circular reference detected in resolving typed.referTo");
              }
            }
            return resolvedFunctions;
          }
          function validateDeprecatedThis(signaturesMap) {
            var deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
            Object.keys(signaturesMap).forEach(function(signature) {
              var fn = signaturesMap[signature];
              if (deprecatedThisRegex.test(fn.toString())) {
                throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
              }
            });
          }
          function createTypedFunction(name297, rawSignaturesMap) {
            typed.createCount++;
            if (Object.keys(rawSignaturesMap).length === 0) {
              throw new SyntaxError("No signatures provided");
            }
            if (typed.warnAgainstDeprecatedThis) {
              validateDeprecatedThis(rawSignaturesMap);
            }
            var parsedParams = [];
            var originalFunctions = [];
            var signaturesMap = {};
            var preliminarySignatures = [];
            var signature;
            var _loop2 = function _loop22() {
              if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
                return "continue";
              }
              var params = parseSignature(signature);
              if (!params)
                return "continue";
              parsedParams.forEach(function(pp) {
                if (conflicting(pp, params)) {
                  throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
                }
              });
              parsedParams.push(params);
              var functionIndex = originalFunctions.length;
              originalFunctions.push(rawSignaturesMap[signature]);
              var conversionParams = params.map(expandParam);
              var sp = void 0;
              var _iterator11 = _createForOfIteratorHelper(splitParams(conversionParams)), _step11;
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                  sp = _step11.value;
                  var spName = stringifyParams(sp);
                  preliminarySignatures.push({
                    params: sp,
                    name: spName,
                    fn: functionIndex
                  });
                  if (sp.every(function(p) {
                    return !p.hasConversion;
                  })) {
                    signaturesMap[spName] = functionIndex;
                  }
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
            };
            for (signature in rawSignaturesMap) {
              var _ret3 = _loop2();
              if (_ret3 === "continue")
                continue;
            }
            preliminarySignatures.sort(compareSignatures);
            var resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
            var s;
            for (s in signaturesMap) {
              if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
                signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
              }
            }
            var signatures = [];
            var internalSignatureMap = /* @__PURE__ */ new Map();
            for (var _i3 = 0, _preliminarySignature = preliminarySignatures; _i3 < _preliminarySignature.length; _i3++) {
              s = _preliminarySignature[_i3];
              if (!internalSignatureMap.has(s.name)) {
                s.fn = resolvedFunctions[s.fn];
                signatures.push(s);
                internalSignatureMap.set(s.name, s);
              }
            }
            var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
            var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
            var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
            var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
            var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
            var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
            var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
            for (var i = 0; i < signatures.length; ++i) {
              signatures[i].test = compileTests(signatures[i].params);
            }
            var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
            var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
            var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
            var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
            var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
            var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
            var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
            var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
            var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
            var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
            var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
            var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
            for (var _i4 = 0; _i4 < signatures.length; ++_i4) {
              signatures[_i4].implementation = compileArgsPreprocessing(signatures[_i4].params, signatures[_i4].fn);
            }
            var fn0 = ok0 ? signatures[0].implementation : undef;
            var fn1 = ok1 ? signatures[1].implementation : undef;
            var fn2 = ok2 ? signatures[2].implementation : undef;
            var fn3 = ok3 ? signatures[3].implementation : undef;
            var fn4 = ok4 ? signatures[4].implementation : undef;
            var fn5 = ok5 ? signatures[5].implementation : undef;
            var len0 = ok0 ? signatures[0].params.length : -1;
            var len1 = ok1 ? signatures[1].params.length : -1;
            var len2 = ok2 ? signatures[2].params.length : -1;
            var len3 = ok3 ? signatures[3].params.length : -1;
            var len4 = ok4 ? signatures[4].params.length : -1;
            var len5 = ok5 ? signatures[5].params.length : -1;
            var iStart = allOk ? 6 : 0;
            var iEnd = signatures.length;
            var tests = signatures.map(function(s2) {
              return s2.test;
            });
            var fns = signatures.map(function(s2) {
              return s2.implementation;
            });
            var generic = function generic2() {
              for (var _i5 = iStart; _i5 < iEnd; _i5++) {
                if (tests[_i5](arguments)) {
                  return fns[_i5].apply(this, arguments);
                }
              }
              return typed.onMismatch(name297, arguments, signatures);
            };
            function theTypedFn(arg0, arg1) {
              if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                return fn0.apply(this, arguments);
              }
              if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                return fn1.apply(this, arguments);
              }
              if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                return fn2.apply(this, arguments);
              }
              if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                return fn3.apply(this, arguments);
              }
              if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                return fn4.apply(this, arguments);
              }
              if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                return fn5.apply(this, arguments);
              }
              return generic.apply(this, arguments);
            }
            try {
              Object.defineProperty(theTypedFn, "name", {
                value: name297
              });
            } catch (err) {
            }
            theTypedFn.signatures = signaturesMap;
            theTypedFn._typedFunctionData = {
              signatures,
              signatureMap: internalSignatureMap
            };
            return theTypedFn;
          }
          function _onMismatch(name297, args, signatures) {
            throw createError(name297, args, signatures);
          }
          function initial(arr) {
            return slice(arr, 0, arr.length - 1);
          }
          function last(arr) {
            return arr[arr.length - 1];
          }
          function slice(arr, start, end) {
            return Array.prototype.slice.call(arr, start, end);
          }
          function findInArray(arr, test) {
            for (var i = 0; i < arr.length; i++) {
              if (test(arr[i])) {
                return arr[i];
              }
            }
            return void 0;
          }
          function flatMap(arr, callback) {
            return Array.prototype.concat.apply([], arr.map(callback));
          }
          function referTo() {
            var references = initial(arguments).map(function(s) {
              return stringifyParams(parseSignature(s));
            });
            var callback = last(arguments);
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as last argument");
            }
            return makeReferTo(references, callback);
          }
          function makeReferTo(references, callback) {
            return {
              referTo: {
                references,
                callback
              }
            };
          }
          function referToSelf(callback) {
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as first argument");
            }
            return {
              referToSelf: {
                callback
              }
            };
          }
          function isReferTo(objectOrFn) {
            return objectOrFn && _typeof(objectOrFn.referTo) === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
          }
          function isReferToSelf(objectOrFn) {
            return objectOrFn && _typeof(objectOrFn.referToSelf) === "object" && typeof objectOrFn.referToSelf.callback === "function";
          }
          function checkName(nameSoFar, newName) {
            if (!nameSoFar) {
              return newName;
            }
            if (newName && newName !== nameSoFar) {
              var err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
              err.data = {
                actual: newName,
                expected: nameSoFar
              };
              throw err;
            }
            return nameSoFar;
          }
          function getObjectName(obj) {
            var name297;
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
                name297 = checkName(name297, obj[key].name);
              }
            }
            return name297;
          }
          function mergeSignatures(dest, source) {
            var key;
            for (key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (key in dest) {
                  if (source[key] !== dest[key]) {
                    var err = new Error('Signature "' + key + '" is defined twice');
                    err.data = {
                      signature: key,
                      sourceFunction: source[key],
                      destFunction: dest[key]
                    };
                    throw err;
                  }
                }
                dest[key] = source[key];
              }
            }
          }
          var saveTyped = typed;
          typed = function typed2(maybeName) {
            var named = typeof maybeName === "string";
            var start = named ? 1 : 0;
            var name297 = named ? maybeName : "";
            var allSignatures = {};
            for (var i = start; i < arguments.length; ++i) {
              var item = arguments[i];
              var theseSignatures = {};
              var thisName = void 0;
              if (typeof item === "function") {
                thisName = item.name;
                if (typeof item.signature === "string") {
                  theseSignatures[item.signature] = item;
                } else if (isTypedFunction(item)) {
                  theseSignatures = item.signatures;
                }
              } else if (isPlainObject2(item)) {
                theseSignatures = item;
                if (!named) {
                  thisName = getObjectName(item);
                }
              }
              if (Object.keys(theseSignatures).length === 0) {
                var err = new TypeError("Argument to 'typed' at index " + i + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
                err.data = {
                  index: i,
                  argument: item
                };
                throw err;
              }
              if (!named) {
                name297 = checkName(name297, thisName);
              }
              mergeSignatures(allSignatures, theseSignatures);
            }
            return createTypedFunction(name297 || "", allSignatures);
          };
          typed.create = create2;
          typed.createCount = saveTyped.createCount;
          typed.onMismatch = _onMismatch;
          typed.throwMismatchError = _onMismatch;
          typed.createError = createError;
          typed.clear = clear;
          typed.clearConversions = clearConversions;
          typed.addTypes = addTypes;
          typed._findType = findType;
          typed.referTo = referTo;
          typed.referToSelf = referToSelf;
          typed.convert = convert;
          typed.findSignature = findSignature;
          typed.find = find;
          typed.isTypedFunction = isTypedFunction;
          typed.warnAgainstDeprecatedThis = true;
          typed.addType = function(type, beforeObjectTest) {
            var before = "any";
            if (beforeObjectTest !== false && typeMap.has("Object")) {
              before = "Object";
            }
            typed.addTypes([type], before);
          };
          function _validateConversion(conversion) {
            if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
              throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
            }
            if (conversion.to === conversion.from) {
              throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
            }
          }
          typed.addConversion = function(conversion) {
            _validateConversion(conversion);
            var to = findType(conversion.to);
            if (to.conversionsTo.every(function(other) {
              return other.from !== conversion.from;
            })) {
              to.conversionsTo.push({
                from: conversion.from,
                convert: conversion.convert,
                index: nConversions++
              });
            } else {
              throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to.name + '"');
            }
          };
          typed.addConversions = function(conversions) {
            conversions.forEach(typed.addConversion);
          };
          typed.removeConversion = function(conversion) {
            _validateConversion(conversion);
            var to = findType(conversion.to);
            var existingConversion = findInArray(to.conversionsTo, function(c) {
              return c.from === conversion.from;
            });
            if (!existingConversion) {
              throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
            }
            if (existingConversion.convert !== conversion.convert) {
              throw new Error("Conversion to remove does not match existing conversion");
            }
            var index = to.conversionsTo.indexOf(existingConversion);
            to.conversionsTo.splice(index, 1);
          };
          typed.resolve = function(tf, argList) {
            if (!isTypedFunction(tf)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            var sigs = tf._typedFunctionData.signatures;
            for (var i = 0; i < sigs.length; ++i) {
              if (sigs[i].test(argList)) {
                return sigs[i];
              }
            }
            return null;
          };
          return typed;
        }
        var typedFunction3 = create2();
        return typedFunction3;
      });
    }
  });

  // node_modules/complex.js/complex.js
  var require_complex = __commonJS({
    "node_modules/complex.js/complex.js"(exports, module) {
      (function(root2) {
        "use strict";
        var cosh3 = Math.cosh || function(x) {
          return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
        };
        var sinh3 = Math.sinh || function(x) {
          return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
        };
        var cosm1 = function(x) {
          var b = Math.PI / 4;
          if (-b > x || x > b) {
            return Math.cos(x) - 1;
          }
          var xx = x * x;
          return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
        };
        var hypot2 = function(x, y) {
          var a = Math.abs(x);
          var b = Math.abs(y);
          if (a < 3e3 && b < 3e3) {
            return Math.sqrt(a * a + b * b);
          }
          if (a < b) {
            a = b;
            b = x / y;
          } else {
            b = y / x;
          }
          return a * Math.sqrt(1 + b * b);
        };
        var parser_exit = function() {
          throw SyntaxError("Invalid Param");
        };
        function logHypot(a, b) {
          var _a = Math.abs(a);
          var _b = Math.abs(b);
          if (a === 0) {
            return Math.log(_b);
          }
          if (b === 0) {
            return Math.log(_a);
          }
          if (_a < 3e3 && _b < 3e3) {
            return Math.log(a * a + b * b) * 0.5;
          }
          a = a / 2;
          b = b / 2;
          return 0.5 * Math.log(a * a + b * b) + Math.LN2;
        }
        var parse = function(a, b) {
          var z = { "re": 0, "im": 0 };
          if (a === void 0 || a === null) {
            z["re"] = z["im"] = 0;
          } else if (b !== void 0) {
            z["re"] = a;
            z["im"] = b;
          } else
            switch (typeof a) {
              case "object":
                if ("im" in a && "re" in a) {
                  z["re"] = a["re"];
                  z["im"] = a["im"];
                } else if ("abs" in a && "arg" in a) {
                  if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                    return Complex2["INFINITY"];
                  }
                  z["re"] = a["abs"] * Math.cos(a["arg"]);
                  z["im"] = a["abs"] * Math.sin(a["arg"]);
                } else if ("r" in a && "phi" in a) {
                  if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                    return Complex2["INFINITY"];
                  }
                  z["re"] = a["r"] * Math.cos(a["phi"]);
                  z["im"] = a["r"] * Math.sin(a["phi"]);
                } else if (a.length === 2) {
                  z["re"] = a[0];
                  z["im"] = a[1];
                } else {
                  parser_exit();
                }
                break;
              case "string":
                z["im"] = z["re"] = 0;
                var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
                var plus = 1;
                var minus = 0;
                if (tokens === null) {
                  parser_exit();
                }
                for (var i = 0; i < tokens.length; i++) {
                  var c = tokens[i];
                  if (c === " " || c === "	" || c === "\n") {
                  } else if (c === "+") {
                    plus++;
                  } else if (c === "-") {
                    minus++;
                  } else if (c === "i" || c === "I") {
                    if (plus + minus === 0) {
                      parser_exit();
                    }
                    if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                      i++;
                    } else {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                    }
                    plus = minus = 0;
                  } else {
                    if (plus + minus === 0 || isNaN(c)) {
                      parser_exit();
                    }
                    if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                      i++;
                    } else {
                      z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                    }
                    plus = minus = 0;
                  }
                }
                if (plus + minus > 0) {
                  parser_exit();
                }
                break;
              case "number":
                z["im"] = 0;
                z["re"] = a;
                break;
              default:
                parser_exit();
            }
          if (isNaN(z["re"]) || isNaN(z["im"])) {
          }
          return z;
        };
        function Complex2(a, b) {
          if (!(this instanceof Complex2)) {
            return new Complex2(a, b);
          }
          var z = parse(a, b);
          this["re"] = z["re"];
          this["im"] = z["im"];
        }
        Complex2.prototype = {
          "re": 0,
          "im": 0,
          "sign": function() {
            var abs2 = this["abs"]();
            return new Complex2(
              this["re"] / abs2,
              this["im"] / abs2
            );
          },
          "add": function(a, b) {
            var z = new Complex2(a, b);
            if (this["isInfinite"]() && z["isInfinite"]()) {
              return Complex2["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex2["INFINITY"];
            }
            return new Complex2(
              this["re"] + z["re"],
              this["im"] + z["im"]
            );
          },
          "sub": function(a, b) {
            var z = new Complex2(a, b);
            if (this["isInfinite"]() && z["isInfinite"]()) {
              return Complex2["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex2["INFINITY"];
            }
            return new Complex2(
              this["re"] - z["re"],
              this["im"] - z["im"]
            );
          },
          "mul": function(a, b) {
            var z = new Complex2(a, b);
            if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
              return Complex2["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex2["INFINITY"];
            }
            if (z["im"] === 0 && this["im"] === 0) {
              return new Complex2(this["re"] * z["re"], 0);
            }
            return new Complex2(
              this["re"] * z["re"] - this["im"] * z["im"],
              this["re"] * z["im"] + this["im"] * z["re"]
            );
          },
          "div": function(a, b) {
            var z = new Complex2(a, b);
            if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
              return Complex2["NAN"];
            }
            if (this["isInfinite"]() || z["isZero"]()) {
              return Complex2["INFINITY"];
            }
            if (this["isZero"]() || z["isInfinite"]()) {
              return Complex2["ZERO"];
            }
            a = this["re"];
            b = this["im"];
            var c = z["re"];
            var d = z["im"];
            var t, x;
            if (0 === d) {
              return new Complex2(a / c, b / c);
            }
            if (Math.abs(c) < Math.abs(d)) {
              x = c / d;
              t = c * x + d;
              return new Complex2(
                (a * x + b) / t,
                (b * x - a) / t
              );
            } else {
              x = d / c;
              t = d * x + c;
              return new Complex2(
                (a + b * x) / t,
                (b - a * x) / t
              );
            }
          },
          "pow": function(a, b) {
            var z = new Complex2(a, b);
            a = this["re"];
            b = this["im"];
            if (z["isZero"]()) {
              return Complex2["ONE"];
            }
            if (z["im"] === 0) {
              if (b === 0 && a > 0) {
                return new Complex2(Math.pow(a, z["re"]), 0);
              } else if (a === 0) {
                switch ((z["re"] % 4 + 4) % 4) {
                  case 0:
                    return new Complex2(Math.pow(b, z["re"]), 0);
                  case 1:
                    return new Complex2(0, Math.pow(b, z["re"]));
                  case 2:
                    return new Complex2(-Math.pow(b, z["re"]), 0);
                  case 3:
                    return new Complex2(0, -Math.pow(b, z["re"]));
                }
              }
            }
            if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
              return Complex2["ZERO"];
            }
            var arg = Math.atan2(b, a);
            var loh = logHypot(a, b);
            a = Math.exp(z["re"] * loh - z["im"] * arg);
            b = z["im"] * loh + z["re"] * arg;
            return new Complex2(
              a * Math.cos(b),
              a * Math.sin(b)
            );
          },
          "sqrt": function() {
            var a = this["re"];
            var b = this["im"];
            var r = this["abs"]();
            var re, im;
            if (a >= 0) {
              if (b === 0) {
                return new Complex2(Math.sqrt(a), 0);
              }
              re = 0.5 * Math.sqrt(2 * (r + a));
            } else {
              re = Math.abs(b) / Math.sqrt(2 * (r - a));
            }
            if (a <= 0) {
              im = 0.5 * Math.sqrt(2 * (r - a));
            } else {
              im = Math.abs(b) / Math.sqrt(2 * (r + a));
            }
            return new Complex2(re, b < 0 ? -im : im);
          },
          "exp": function() {
            var tmp = Math.exp(this["re"]);
            if (this["im"] === 0) {
            }
            return new Complex2(
              tmp * Math.cos(this["im"]),
              tmp * Math.sin(this["im"])
            );
          },
          "expm1": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex2(
              Math.expm1(a) * Math.cos(b) + cosm1(b),
              Math.exp(a) * Math.sin(b)
            );
          },
          "log": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0 && a > 0) {
            }
            return new Complex2(
              logHypot(a, b),
              Math.atan2(b, a)
            );
          },
          "abs": function() {
            return hypot2(this["re"], this["im"]);
          },
          "arg": function() {
            return Math.atan2(this["im"], this["re"]);
          },
          "sin": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex2(
              Math.sin(a) * cosh3(b),
              Math.cos(a) * sinh3(b)
            );
          },
          "cos": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex2(
              Math.cos(a) * cosh3(b),
              -Math.sin(a) * sinh3(b)
            );
          },
          "tan": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = Math.cos(a) + cosh3(b);
            return new Complex2(
              Math.sin(a) / d,
              sinh3(b) / d
            );
          },
          "cot": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = Math.cos(a) - cosh3(b);
            return new Complex2(
              -Math.sin(a) / d,
              sinh3(b) / d
            );
          },
          "sec": function() {
            var a = this["re"];
            var b = this["im"];
            var d = 0.5 * cosh3(2 * b) + 0.5 * Math.cos(2 * a);
            return new Complex2(
              Math.cos(a) * cosh3(b) / d,
              Math.sin(a) * sinh3(b) / d
            );
          },
          "csc": function() {
            var a = this["re"];
            var b = this["im"];
            var d = 0.5 * cosh3(2 * b) - 0.5 * Math.cos(2 * a);
            return new Complex2(
              Math.sin(a) * cosh3(b) / d,
              -Math.cos(a) * sinh3(b) / d
            );
          },
          "asin": function() {
            var a = this["re"];
            var b = this["im"];
            var t1 = new Complex2(
              b * b - a * a + 1,
              -2 * a * b
            )["sqrt"]();
            var t2 = new Complex2(
              t1["re"] - b,
              t1["im"] + a
            )["log"]();
            return new Complex2(t2["im"], -t2["re"]);
          },
          "acos": function() {
            var a = this["re"];
            var b = this["im"];
            var t1 = new Complex2(
              b * b - a * a + 1,
              -2 * a * b
            )["sqrt"]();
            var t2 = new Complex2(
              t1["re"] - b,
              t1["im"] + a
            )["log"]();
            return new Complex2(Math.PI / 2 - t2["im"], t2["re"]);
          },
          "atan": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0) {
              if (b === 1) {
                return new Complex2(0, Infinity);
              }
              if (b === -1) {
                return new Complex2(0, -Infinity);
              }
            }
            var d = a * a + (1 - b) * (1 - b);
            var t1 = new Complex2(
              (1 - b * b - a * a) / d,
              -2 * a / d
            ).log();
            return new Complex2(-0.5 * t1["im"], 0.5 * t1["re"]);
          },
          "acot": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0) {
              return new Complex2(Math.atan2(1, a), 0);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex2(
              a / d,
              -b / d
            ).atan() : new Complex2(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).atan();
          },
          "asec": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex2(0, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex2(
              a / d,
              -b / d
            ).acos() : new Complex2(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).acos();
          },
          "acsc": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex2(Math.PI / 2, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex2(
              a / d,
              -b / d
            ).asin() : new Complex2(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).asin();
          },
          "sinh": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex2(
              sinh3(a) * Math.cos(b),
              cosh3(a) * Math.sin(b)
            );
          },
          "cosh": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex2(
              cosh3(a) * Math.cos(b),
              sinh3(a) * Math.sin(b)
            );
          },
          "tanh": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = cosh3(a) + Math.cos(b);
            return new Complex2(
              sinh3(a) / d,
              Math.sin(b) / d
            );
          },
          "coth": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = cosh3(a) - Math.cos(b);
            return new Complex2(
              sinh3(a) / d,
              -Math.sin(b) / d
            );
          },
          "csch": function() {
            var a = this["re"];
            var b = this["im"];
            var d = Math.cos(2 * b) - cosh3(2 * a);
            return new Complex2(
              -2 * sinh3(a) * Math.cos(b) / d,
              2 * cosh3(a) * Math.sin(b) / d
            );
          },
          "sech": function() {
            var a = this["re"];
            var b = this["im"];
            var d = Math.cos(2 * b) + cosh3(2 * a);
            return new Complex2(
              2 * cosh3(a) * Math.cos(b) / d,
              -2 * sinh3(a) * Math.sin(b) / d
            );
          },
          "asinh": function() {
            var tmp = this["im"];
            this["im"] = -this["re"];
            this["re"] = tmp;
            var res = this["asin"]();
            this["re"] = -this["im"];
            this["im"] = tmp;
            tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
            return res;
          },
          "acosh": function() {
            var res = this["acos"]();
            if (res["im"] <= 0) {
              var tmp = res["re"];
              res["re"] = -res["im"];
              res["im"] = tmp;
            } else {
              var tmp = res["im"];
              res["im"] = -res["re"];
              res["re"] = tmp;
            }
            return res;
          },
          "atanh": function() {
            var a = this["re"];
            var b = this["im"];
            var noIM = a > 1 && b === 0;
            var oneMinus = 1 - a;
            var onePlus = 1 + a;
            var d = oneMinus * oneMinus + b * b;
            var x = d !== 0 ? new Complex2(
              (onePlus * oneMinus - b * b) / d,
              (b * oneMinus + onePlus * b) / d
            ) : new Complex2(
              a !== -1 ? a / 0 : 0,
              b !== 0 ? b / 0 : 0
            );
            var temp = x["re"];
            x["re"] = logHypot(x["re"], x["im"]) / 2;
            x["im"] = Math.atan2(x["im"], temp) / 2;
            if (noIM) {
              x["im"] = -x["im"];
            }
            return x;
          },
          "acoth": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex2(0, Math.PI / 2);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex2(
              a / d,
              -b / d
            ).atanh() : new Complex2(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).atanh();
          },
          "acsch": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0) {
              return new Complex2(
                a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
                0
              );
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex2(
              a / d,
              -b / d
            ).asinh() : new Complex2(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).asinh();
          },
          "asech": function() {
            var a = this["re"];
            var b = this["im"];
            if (this["isZero"]()) {
              return Complex2["INFINITY"];
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex2(
              a / d,
              -b / d
            ).acosh() : new Complex2(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).acosh();
          },
          "inverse": function() {
            if (this["isZero"]()) {
              return Complex2["INFINITY"];
            }
            if (this["isInfinite"]()) {
              return Complex2["ZERO"];
            }
            var a = this["re"];
            var b = this["im"];
            var d = a * a + b * b;
            return new Complex2(a / d, -b / d);
          },
          "conjugate": function() {
            return new Complex2(this["re"], -this["im"]);
          },
          "neg": function() {
            return new Complex2(-this["re"], -this["im"]);
          },
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex2(
              Math.ceil(this["re"] * places) / places,
              Math.ceil(this["im"] * places) / places
            );
          },
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex2(
              Math.floor(this["re"] * places) / places,
              Math.floor(this["im"] * places) / places
            );
          },
          "round": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex2(
              Math.round(this["re"] * places) / places,
              Math.round(this["im"] * places) / places
            );
          },
          "equals": function(a, b) {
            var z = new Complex2(a, b);
            return Math.abs(z["re"] - this["re"]) <= Complex2["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex2["EPSILON"];
          },
          "clone": function() {
            return new Complex2(this["re"], this["im"]);
          },
          "toString": function() {
            var a = this["re"];
            var b = this["im"];
            var ret = "";
            if (this["isNaN"]()) {
              return "NaN";
            }
            if (this["isInfinite"]()) {
              return "Infinity";
            }
            if (Math.abs(a) < Complex2["EPSILON"]) {
              a = 0;
            }
            if (Math.abs(b) < Complex2["EPSILON"]) {
              b = 0;
            }
            if (b === 0) {
              return ret + a;
            }
            if (a !== 0) {
              ret += a;
              ret += " ";
              if (b < 0) {
                b = -b;
                ret += "-";
              } else {
                ret += "+";
              }
              ret += " ";
            } else if (b < 0) {
              b = -b;
              ret += "-";
            }
            if (1 !== b) {
              ret += b;
            }
            return ret + "i";
          },
          "toVector": function() {
            return [this["re"], this["im"]];
          },
          "valueOf": function() {
            if (this["im"] === 0) {
              return this["re"];
            }
            return null;
          },
          "isNaN": function() {
            return isNaN(this["re"]) || isNaN(this["im"]);
          },
          "isZero": function() {
            return this["im"] === 0 && this["re"] === 0;
          },
          "isFinite": function() {
            return isFinite(this["re"]) && isFinite(this["im"]);
          },
          "isInfinite": function() {
            return !(this["isNaN"]() || this["isFinite"]());
          }
        };
        Complex2["ZERO"] = new Complex2(0, 0);
        Complex2["ONE"] = new Complex2(1, 0);
        Complex2["I"] = new Complex2(0, 1);
        Complex2["PI"] = new Complex2(Math.PI, 0);
        Complex2["E"] = new Complex2(Math.E, 0);
        Complex2["INFINITY"] = new Complex2(Infinity, Infinity);
        Complex2["NAN"] = new Complex2(NaN, NaN);
        Complex2["EPSILON"] = 1e-15;
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Complex2;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Complex2, "__esModule", { "value": true });
          Complex2["default"] = Complex2;
          Complex2["Complex"] = Complex2;
          module["exports"] = Complex2;
        } else {
          root2["Complex"] = Complex2;
        }
      })(exports);
    }
  });

  // node_modules/fraction.js/fraction.js
  var require_fraction = __commonJS({
    "node_modules/fraction.js/fraction.js"(exports, module) {
      (function(root2) {
        "use strict";
        var MAX_CYCLE_LEN = 2e3;
        var P3 = {
          "s": 1,
          "n": 0,
          "d": 1
        };
        function assign2(n, s) {
          if (isNaN(n = parseInt(n, 10))) {
            throw Fraction2["InvalidParameter"];
          }
          return n * s;
        }
        function newFraction(n, d) {
          if (d === 0) {
            throw Fraction2["DivisionByZero"];
          }
          var f = Object.create(Fraction2.prototype);
          f["s"] = n < 0 ? -1 : 1;
          n = n < 0 ? -n : n;
          var a = gcd(n, d);
          f["n"] = n / a;
          f["d"] = d / a;
          return f;
        }
        function factorize(num) {
          var factors = {};
          var n = num;
          var i = 2;
          var s = 4;
          while (s <= n) {
            while (n % i === 0) {
              n /= i;
              factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
          }
          if (n !== num) {
            if (n > 1)
              factors[n] = (factors[n] || 0) + 1;
          } else {
            factors[num] = (factors[num] || 0) + 1;
          }
          return factors;
        }
        var parse = function(p1, p2) {
          var n = 0, d = 1, s = 1;
          var v = 0, w = 0, x = 0, y = 1, z = 1;
          var A = 0, B = 1;
          var C = 1, D = 1;
          var N = 1e7;
          var M;
          if (p1 === void 0 || p1 === null) {
          } else if (p2 !== void 0) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
              throw Fraction2["NonIntegerParameter"];
            }
          } else
            switch (typeof p1) {
              case "object": {
                if ("d" in p1 && "n" in p1) {
                  n = p1["n"];
                  d = p1["d"];
                  if ("s" in p1)
                    n *= p1["s"];
                } else if (0 in p1) {
                  n = p1[0];
                  if (1 in p1)
                    d = p1[1];
                } else {
                  throw Fraction2["InvalidParameter"];
                }
                s = n * d;
                break;
              }
              case "number": {
                if (p1 < 0) {
                  s = p1;
                  p1 = -p1;
                }
                if (p1 % 1 === 0) {
                  n = p1;
                } else if (p1 > 0) {
                  if (p1 >= 1) {
                    z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                    p1 /= z;
                  }
                  while (B <= N && D <= N) {
                    M = (A + C) / (B + D);
                    if (p1 === M) {
                      if (B + D <= N) {
                        n = A + C;
                        d = B + D;
                      } else if (D > B) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                      break;
                    } else {
                      if (p1 > M) {
                        A += C;
                        B += D;
                      } else {
                        C += A;
                        D += B;
                      }
                      if (B > N) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                    }
                  }
                  n *= z;
                } else if (isNaN(p1) || isNaN(p2)) {
                  d = n = NaN;
                }
                break;
              }
              case "string": {
                B = p1.match(/\d+|./g);
                if (B === null)
                  throw Fraction2["InvalidParameter"];
                if (B[A] === "-") {
                  s = -1;
                  A++;
                } else if (B[A] === "+") {
                  A++;
                }
                if (B.length === A + 1) {
                  w = assign2(B[A++], s);
                } else if (B[A + 1] === "." || B[A] === ".") {
                  if (B[A] !== ".") {
                    v = assign2(B[A++], s);
                  }
                  A++;
                  if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                    w = assign2(B[A], s);
                    y = Math.pow(10, B[A].length);
                    A++;
                  }
                  if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                    x = assign2(B[A + 1], s);
                    z = Math.pow(10, B[A + 1].length) - 1;
                    A += 3;
                  }
                } else if (B[A + 1] === "/" || B[A + 1] === ":") {
                  w = assign2(B[A], s);
                  y = assign2(B[A + 2], 1);
                  A += 3;
                } else if (B[A + 3] === "/" && B[A + 1] === " ") {
                  v = assign2(B[A], s);
                  w = assign2(B[A + 2], s);
                  y = assign2(B[A + 4], 1);
                  A += 5;
                }
                if (B.length <= A) {
                  d = y * z;
                  s = n = x + d * v + z * w;
                  break;
                }
              }
              default:
                throw Fraction2["InvalidParameter"];
            }
          if (d === 0) {
            throw Fraction2["DivisionByZero"];
          }
          P3["s"] = s < 0 ? -1 : 1;
          P3["n"] = Math.abs(n);
          P3["d"] = Math.abs(d);
        };
        function modpow(b, e2, m) {
          var r = 1;
          for (; e2 > 0; b = b * b % m, e2 >>= 1) {
            if (e2 & 1) {
              r = r * b % m;
            }
          }
          return r;
        }
        function cycleLen(n, d) {
          for (; d % 2 === 0; d /= 2) {
          }
          for (; d % 5 === 0; d /= 5) {
          }
          if (d === 1)
            return 0;
          var rem = 10 % d;
          var t = 1;
          for (; rem !== 1; t++) {
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN)
              return 0;
          }
          return t;
        }
        function cycleStart(n, d, len) {
          var rem1 = 1;
          var rem2 = modpow(10, len, d);
          for (var t = 0; t < 300; t++) {
            if (rem1 === rem2)
              return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
          }
          return 0;
        }
        function gcd(a, b) {
          if (!a)
            return b;
          if (!b)
            return a;
          while (1) {
            a %= b;
            if (!a)
              return b;
            b %= a;
            if (!b)
              return a;
          }
        }
        ;
        function Fraction2(a, b) {
          parse(a, b);
          if (this instanceof Fraction2) {
            a = gcd(P3["d"], P3["n"]);
            this["s"] = P3["s"];
            this["n"] = P3["n"] / a;
            this["d"] = P3["d"] / a;
          } else {
            return newFraction(P3["s"] * P3["n"], P3["d"]);
          }
        }
        Fraction2["DivisionByZero"] = new Error("Division by Zero");
        Fraction2["InvalidParameter"] = new Error("Invalid argument");
        Fraction2["NonIntegerParameter"] = new Error("Parameters must be integer");
        Fraction2.prototype = {
          "s": 1,
          "n": 0,
          "d": 1,
          "abs": function() {
            return newFraction(this["n"], this["d"]);
          },
          "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
          },
          "add": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * this["n"] * P3["d"] + P3["s"] * this["d"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          "sub": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * this["n"] * P3["d"] - P3["s"] * this["d"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          "mul": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * P3["s"] * this["n"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          "div": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * P3["s"] * this["n"] * P3["d"],
              this["d"] * P3["n"]
            );
          },
          "clone": function() {
            return newFraction(this["s"] * this["n"], this["d"]);
          },
          "mod": function(a, b) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction2(NaN);
            }
            if (a === void 0) {
              return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P3["n"] && 0 === this["d"]) {
              throw Fraction2["DivisionByZero"];
            }
            return newFraction(
              this["s"] * (P3["d"] * this["n"]) % (P3["n"] * this["d"]),
              P3["d"] * this["d"]
            );
          },
          "gcd": function(a, b) {
            parse(a, b);
            return newFraction(gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]), P3["d"] * this["d"]);
          },
          "lcm": function(a, b) {
            parse(a, b);
            if (P3["n"] === 0 && this["n"] === 0) {
              return newFraction(0, 1);
            }
            return newFraction(P3["n"] * this["n"], gcd(P3["n"], this["n"]) * gcd(P3["d"], this["d"]));
          },
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction2(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
          },
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction2(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
          },
          "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction2(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
          },
          "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
          },
          "pow": function(a, b) {
            parse(a, b);
            if (P3["d"] === 1) {
              if (P3["s"] < 0) {
                return newFraction(Math.pow(this["s"] * this["d"], P3["n"]), Math.pow(this["n"], P3["n"]));
              } else {
                return newFraction(Math.pow(this["s"] * this["n"], P3["n"]), Math.pow(this["d"], P3["n"]));
              }
            }
            if (this["s"] < 0)
              return null;
            var N = factorize(this["n"]);
            var D = factorize(this["d"]);
            var n = 1;
            var d = 1;
            for (var k in N) {
              if (k === "1")
                continue;
              if (k === "0") {
                n = 0;
                break;
              }
              N[k] *= P3["n"];
              if (N[k] % P3["d"] === 0) {
                N[k] /= P3["d"];
              } else
                return null;
              n *= Math.pow(k, N[k]);
            }
            for (var k in D) {
              if (k === "1")
                continue;
              D[k] *= P3["n"];
              if (D[k] % P3["d"] === 0) {
                D[k] /= P3["d"];
              } else
                return null;
              d *= Math.pow(k, D[k]);
            }
            if (P3["s"] < 0) {
              return newFraction(d, n);
            }
            return newFraction(n, d);
          },
          "equals": function(a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P3["d"] === P3["s"] * P3["n"] * this["d"];
          },
          "compare": function(a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P3["d"] - P3["s"] * P3["n"] * this["d"];
            return (0 < t) - (t < 0);
          },
          "simplify": function(eps) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return this;
            }
            eps = eps || 1e-3;
            var thisABS = this["abs"]();
            var cont = thisABS["toContinued"]();
            for (var i = 1; i < cont.length; i++) {
              var s = newFraction(cont[i - 1], 1);
              for (var k = i - 2; k >= 0; k--) {
                s = s["inverse"]()["add"](cont[k]);
              }
              if (s["sub"](thisABS)["abs"]().valueOf() < eps) {
                return s["mul"](this["s"]);
              }
            }
            return this;
          },
          "divisible": function(a, b) {
            parse(a, b);
            return !(!(P3["n"] * this["d"]) || this["n"] * P3["d"] % (P3["n"] * this["d"]));
          },
          "valueOf": function() {
            return this["s"] * this["n"] / this["d"];
          },
          "toFraction": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                str += " ";
                n %= d;
              }
              str += n;
              str += "/";
              str += d;
            }
            return str;
          },
          "toLatex": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                n %= d;
              }
              str += "\\frac{";
              str += n;
              str += "}{";
              str += d;
              str += "}";
            }
            return str;
          },
          "toContinued": function() {
            var t;
            var a = this["n"];
            var b = this["d"];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
              return res;
            }
            do {
              res.push(Math.floor(a / b));
              t = a % b;
              a = b;
              b = t;
            } while (a !== 1);
            return res;
          },
          "toString": function(dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
              return "NaN";
            }
            dec = dec || 15;
            var cycLen = cycleLen(N, D);
            var cycOff = cycleStart(N, D, cycLen);
            var str = this["s"] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N)
              str += ".";
            if (cycLen) {
              for (var i = cycOff; i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += "(";
              for (var i = cycLen; i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += ")";
            } else {
              for (var i = dec; N && i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
            }
            return str;
          }
        };
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Fraction2;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Fraction2, "__esModule", { "value": true });
          Fraction2["default"] = Fraction2;
          Fraction2["Fraction"] = Fraction2;
          module["exports"] = Fraction2;
        } else {
          root2["Fraction"] = Fraction2;
        }
      })(exports);
    }
  });

  // node_modules/javascript-natural-sort/naturalSort.js
  var require_naturalSort = __commonJS({
    "node_modules/javascript-natural-sort/naturalSort.js"(exports, module) {
      module.exports = function naturalSort2(a, b) {
        "use strict";
        var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i = function(s) {
          return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
        }, x = i(a).replace(sre, "") || "", y = i(b).replace(sre, "") || "", xN = x.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
        if (yD) {
          if (xD < yD) {
            return -1;
          } else if (xD > yD) {
            return 1;
          }
        }
        for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
          oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
          oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
          if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
            return isNaN(oFxNcL) ? 1 : -1;
          } else if (typeof oFxNcL !== typeof oFyNcL) {
            oFxNcL += "";
            oFyNcL += "";
          }
          if (oFxNcL < oFyNcL) {
            return -1;
          }
          if (oFxNcL > oFyNcL) {
            return 1;
          }
        }
        return 0;
      };
    }
  });

  // node_modules/escape-latex/dist/index.js
  var require_dist = __commonJS({
    "node_modules/escape-latex/dist/index.js"(exports, module) {
      "use strict";
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var defaultEscapes = {
        "{": "\\{",
        "}": "\\}",
        "\\": "\\textbackslash{}",
        "#": "\\#",
        $: "\\$",
        "%": "\\%",
        "&": "\\&",
        "^": "\\textasciicircum{}",
        _: "\\_",
        "~": "\\textasciitilde{}"
      };
      var formatEscapes = {
        "\u2013": "\\--",
        "\u2014": "\\---",
        " ": "~",
        "	": "\\qquad{}",
        "\r\n": "\\newline{}",
        "\n": "\\newline{}"
      };
      var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
        return _extends2({}, defaultEscapes2, formatEscapes2);
      };
      module.exports = function(str) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
        var runningStr = String(str);
        var result = "";
        var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
        var escapeKeys = Object.keys(escapes);
        var _loop = function _loop2() {
          var specialCharFound = false;
          escapeKeys.forEach(function(key, index) {
            if (specialCharFound) {
              return;
            }
            if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
              result += escapes[escapeKeys[index]];
              runningStr = runningStr.slice(key.length, runningStr.length);
              specialCharFound = true;
            }
          });
          if (!specialCharFound) {
            result += runningStr.slice(0, 1);
            runningStr = runningStr.slice(1, runningStr.length);
          }
        };
        while (runningStr) {
          _loop();
        }
        return result;
      };
    }
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = String(data);
            for (var i = 0; i < data.length; i++) {
              n += data.charCodeAt(i);
              var h = 0.02519603282416938 * n;
              n = h >>> 0;
              h -= n;
              h *= n;
              n = h >>> 0;
              h -= n;
              n += h * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        typeof define == "function" && define
      );
    }
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        typeof define == "function" && define
      );
    }
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        typeof define == "function" && define
      );
    }
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8)
              X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j)
              ;
            if (j == 8)
              w = X[7] = -1;
            else
              w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        typeof define == "function" && define
      );
    }
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2)
                v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0)
                w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = 0 == t ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init(me, seed);
        }
        function copy(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        typeof define == "function" && define
      );
    }
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        typeof define == "function" && define
      );
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(global, pool, math2) {
        var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom2(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten2(
            options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
            3
          ), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math2[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(
            prng,
            shortseed,
            "global" in options ? options.global : this == math2,
            options.state
          );
        }
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten2(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten2(obj[prop], depth - 1));
              } catch (e2) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e2) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [+new Date(), global, plugins, global.screen, tostring(pool)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math2.random(), pool);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom2;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom2;
          });
        } else {
          math2["seed" + rngname] = seedrandom2;
        }
      })(
        typeof self !== "undefined" ? self : exports,
        [],
        Math
      );
    }
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/seedrandom/index.js"(exports, module) {
      var alea = require_alea();
      var xor128 = require_xor128();
      var xorwow = require_xorwow();
      var xorshift7 = require_xorshift7();
      var xor4096 = require_xor4096();
      var tychei = require_tychei();
      var sr = require_seedrandom();
      sr.alea = alea;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/tiny-emitter/index.js
  var require_tiny_emitter = __commonJS({
    "node_modules/tiny-emitter/index.js"(exports, module) {
      function E() {
      }
      E.prototype = {
        on: function(name297, callback, ctx) {
          var e2 = this.e || (this.e = {});
          (e2[name297] || (e2[name297] = [])).push({
            fn: callback,
            ctx
          });
          return this;
        },
        once: function(name297, callback, ctx) {
          var self2 = this;
          function listener() {
            self2.off(name297, listener);
            callback.apply(ctx, arguments);
          }
          ;
          listener._ = callback;
          return this.on(name297, listener, ctx);
        },
        emit: function(name297) {
          var data = [].slice.call(arguments, 1);
          var evtArr = ((this.e || (this.e = {}))[name297] || []).slice();
          var i = 0;
          var len = evtArr.length;
          for (i; i < len; i++) {
            evtArr[i].fn.apply(evtArr[i].ctx, data);
          }
          return this;
        },
        off: function(name297, callback) {
          var e2 = this.e || (this.e = {});
          var evts = e2[name297];
          var liveEvents = [];
          if (evts && callback) {
            for (var i = 0, len = evts.length; i < len; i++) {
              if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                liveEvents.push(evts[i]);
            }
          }
          liveEvents.length ? e2[name297] = liveEvents : delete e2[name297];
          return this;
        }
      };
      module.exports = E;
      module.exports.TinyEmitter = E;
    }
  });

  // src/main.tsx
  var React2 = __toESM(require_react());
  var ReactDOM = __toESM(require_client());

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/mathjs/lib/esm/core/config.js
  var DEFAULT_CONFIG = {
    epsilon: 1e-12,
    matrix: "Matrix",
    number: "number",
    precision: 64,
    predictable: false,
    randomSeed: null
  };

  // node_modules/mathjs/lib/esm/utils/is.js
  function isNumber(x) {
    return typeof x === "number";
  }
  function isBigNumber(x) {
    if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
      return false;
    }
    if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
      return true;
    }
    if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
      return true;
    }
    return false;
  }
  function isComplex(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === "string";
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === void 0;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function rule2Node(node) {
    return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRelationalNode(x) {
    return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = typeof x;
    if (t === "object") {
      if (x === null)
        return "null";
      if (isBigNumber(x))
        return "BigNumber";
      if (x.constructor && x.constructor.name)
        return x.constructor.name;
      return "Object";
    }
    return t;
  }

  // node_modules/mathjs/lib/esm/utils/object.js
  function clone(x) {
    var type = typeof x;
    if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
      return x;
    }
    if (typeof x.clone === "function") {
      return x.clone();
    }
    if (Array.isArray(x)) {
      return x.map(function(value) {
        return clone(value);
      });
    }
    if (x instanceof Date)
      return new Date(x.valueOf());
    if (isBigNumber(x))
      return x;
    if (x instanceof RegExp)
      throw new TypeError("Cannot clone " + x);
    return mapObject(x, clone);
  }
  function mapObject(object, callback) {
    var clone3 = {};
    for (var key in object) {
      if (hasOwnProperty2(object, key)) {
        clone3[key] = callback(object[key]);
      }
    }
    return clone3;
  }
  function extend(a, b) {
    for (var prop in b) {
      if (hasOwnProperty2(b, prop)) {
        a[prop] = b[prop];
      }
    }
    return a;
  }
  function deepExtend(a, b) {
    if (Array.isArray(b)) {
      throw new TypeError("Arrays are not supported by deepExtend");
    }
    for (var prop in b) {
      if (hasOwnProperty2(b, prop) && !(prop in Object.prototype) && !(prop in Function.prototype)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === void 0) {
            a[prop] = {};
          }
          if (a[prop] && a[prop].constructor === Object) {
            deepExtend(a[prop], b[prop]);
          } else {
            a[prop] = b[prop];
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError("Arrays are not supported by deepExtend");
        } else {
          a[prop] = b[prop];
        }
      }
    }
    return a;
  }
  function deepStrictEqual(a, b) {
    var prop, i, len;
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0, len = a.length; i < len; i++) {
        if (!deepStrictEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    } else if (typeof a === "function") {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }
      for (prop in a) {
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      for (prop in b) {
        if (!(prop in a)) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  }
  function deepFlatten(nestedObject) {
    var flattenedObject = {};
    _deepFlatten(nestedObject, flattenedObject);
    return flattenedObject;
  }
  function _deepFlatten(nestedObject, flattenedObject) {
    for (var prop in nestedObject) {
      if (hasOwnProperty2(nestedObject, prop)) {
        var value = nestedObject[prop];
        if (typeof value === "object" && value !== null) {
          _deepFlatten(value, flattenedObject);
        } else {
          flattenedObject[prop] = value;
        }
      }
    }
  }
  function lazy(object, prop, valueResolver) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function get() {
        if (_uninitialized) {
          _value = valueResolver();
          _uninitialized = false;
        }
        return _value;
      },
      set: function set(value) {
        _value = value;
        _uninitialized = false;
      },
      configurable: true,
      enumerable: true
    });
  }
  function hasOwnProperty2(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  function isLegacyFactory(object) {
    return object && typeof object.factory === "function";
  }
  function pickShallow(object, properties2) {
    var copy = {};
    for (var i = 0; i < properties2.length; i++) {
      var key = properties2[i];
      var value = object[key];
      if (value !== void 0) {
        copy[key] = value;
      }
    }
    return copy;
  }
  function values(object) {
    return Object.keys(object).map((key) => object[key]);
  }

  // node_modules/mathjs/lib/esm/core/function/config.js
  var MATRIX_OPTIONS = ["Matrix", "Array"];
  var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
  function configFactory(config2, emit) {
    function _config(options) {
      if (options) {
        var prev = mapObject(config2, clone);
        validateOption(options, "matrix", MATRIX_OPTIONS);
        validateOption(options, "number", NUMBER_OPTIONS);
        deepExtend(config2, options);
        var curr = mapObject(config2, clone);
        var changes = mapObject(options, clone);
        emit("config", curr, prev, changes);
        return curr;
      } else {
        return mapObject(config2, clone);
      }
    }
    _config.MATRIX_OPTIONS = MATRIX_OPTIONS;
    _config.NUMBER_OPTIONS = NUMBER_OPTIONS;
    Object.keys(DEFAULT_CONFIG).forEach((key) => {
      Object.defineProperty(_config, key, {
        get: () => config2[key],
        enumerable: true,
        configurable: true
      });
    });
    return _config;
  }
  function contains(array, item) {
    return array.indexOf(item) !== -1;
  }
  function validateOption(options, name297, values2) {
    if (options[name297] !== void 0 && !contains(values2, options[name297])) {
      console.warn('Warning: Unknown value "' + options[name297] + '" for configuration option "' + name297 + '". Available options: ' + values2.map((value) => JSON.stringify(value)).join(", ") + ".");
    }
  }

  // node_modules/mathjs/lib/esm/factoriesAny.js
  var factoriesAny_exports = {};
  __export(factoriesAny_exports, {
    createAbs: () => createAbs,
    createAccessorNode: () => createAccessorNode,
    createAcos: () => createAcos,
    createAcosh: () => createAcosh,
    createAcot: () => createAcot,
    createAcoth: () => createAcoth,
    createAcsc: () => createAcsc,
    createAcsch: () => createAcsch,
    createAdd: () => createAdd,
    createAddScalar: () => createAddScalar,
    createAnd: () => createAnd,
    createApply: () => createApply,
    createApplyTransform: () => createApplyTransform,
    createArg: () => createArg,
    createArrayNode: () => createArrayNode,
    createAsec: () => createAsec,
    createAsech: () => createAsech,
    createAsin: () => createAsin,
    createAsinh: () => createAsinh,
    createAssignmentNode: () => createAssignmentNode,
    createAtan: () => createAtan,
    createAtan2: () => createAtan2,
    createAtanh: () => createAtanh,
    createAtomicMass: () => createAtomicMass,
    createAvogadro: () => createAvogadro,
    createBellNumbers: () => createBellNumbers,
    createBigNumberClass: () => createBigNumberClass,
    createBignumber: () => createBignumber,
    createBin: () => createBin,
    createBitAnd: () => createBitAnd,
    createBitNot: () => createBitNot,
    createBitOr: () => createBitOr,
    createBitXor: () => createBitXor,
    createBlockNode: () => createBlockNode,
    createBohrMagneton: () => createBohrMagneton,
    createBohrRadius: () => createBohrRadius,
    createBoltzmann: () => createBoltzmann,
    createBoolean: () => createBoolean,
    createCatalan: () => createCatalan,
    createCbrt: () => createCbrt,
    createCeil: () => createCeil,
    createChain: () => createChain,
    createChainClass: () => createChainClass,
    createClassicalElectronRadius: () => createClassicalElectronRadius,
    createClone: () => createClone,
    createColumn: () => createColumn,
    createColumnTransform: () => createColumnTransform,
    createCombinations: () => createCombinations,
    createCombinationsWithRep: () => createCombinationsWithRep,
    createCompare: () => createCompare,
    createCompareNatural: () => createCompareNatural,
    createCompareText: () => createCompareText,
    createCompile: () => createCompile,
    createComplex: () => createComplex,
    createComplexClass: () => createComplexClass,
    createComposition: () => createComposition,
    createConcat: () => createConcat,
    createConcatTransform: () => createConcatTransform,
    createConditionalNode: () => createConditionalNode,
    createConductanceQuantum: () => createConductanceQuantum,
    createConj: () => createConj,
    createConstantNode: () => createConstantNode,
    createCos: () => createCos,
    createCosh: () => createCosh,
    createCot: () => createCot,
    createCoth: () => createCoth,
    createCoulomb: () => createCoulomb,
    createCount: () => createCount,
    createCreateUnit: () => createCreateUnit,
    createCross: () => createCross,
    createCsc: () => createCsc,
    createCsch: () => createCsch,
    createCtranspose: () => createCtranspose,
    createCube: () => createCube,
    createCumSum: () => createCumSum,
    createCumSumTransform: () => createCumSumTransform,
    createDeepEqual: () => createDeepEqual,
    createDenseMatrixClass: () => createDenseMatrixClass,
    createDerivative: () => createDerivative,
    createDet: () => createDet,
    createDeuteronMass: () => createDeuteronMass,
    createDiag: () => createDiag,
    createDiff: () => createDiff,
    createDiffTransform: () => createDiffTransform,
    createDistance: () => createDistance,
    createDivide: () => createDivide,
    createDivideScalar: () => createDivideScalar,
    createDot: () => createDot,
    createDotDivide: () => createDotDivide,
    createDotMultiply: () => createDotMultiply,
    createDotPow: () => createDotPow,
    createE: () => createE,
    createEfimovFactor: () => createEfimovFactor,
    createEigs: () => createEigs,
    createElectricConstant: () => createElectricConstant,
    createElectronMass: () => createElectronMass,
    createElementaryCharge: () => createElementaryCharge,
    createEqual: () => createEqual,
    createEqualScalar: () => createEqualScalar,
    createEqualText: () => createEqualText,
    createErf: () => createErf,
    createEvaluate: () => createEvaluate,
    createExp: () => createExp,
    createExpm: () => createExpm,
    createExpm1: () => createExpm1,
    createFactorial: () => createFactorial,
    createFalse: () => createFalse,
    createFaraday: () => createFaraday,
    createFermiCoupling: () => createFermiCoupling,
    createFft: () => createFft,
    createFibonacciHeapClass: () => createFibonacciHeapClass,
    createFilter: () => createFilter,
    createFilterTransform: () => createFilterTransform,
    createFineStructure: () => createFineStructure,
    createFirstRadiation: () => createFirstRadiation,
    createFix: () => createFix,
    createFlatten: () => createFlatten,
    createFloor: () => createFloor,
    createForEach: () => createForEach,
    createForEachTransform: () => createForEachTransform,
    createFormat: () => createFormat,
    createFraction: () => createFraction,
    createFractionClass: () => createFractionClass,
    createFunctionAssignmentNode: () => createFunctionAssignmentNode,
    createFunctionNode: () => createFunctionNode,
    createGamma: () => createGamma,
    createGasConstant: () => createGasConstant,
    createGcd: () => createGcd,
    createGetMatrixDataType: () => createGetMatrixDataType,
    createGravitationConstant: () => createGravitationConstant,
    createGravity: () => createGravity,
    createHartreeEnergy: () => createHartreeEnergy,
    createHasNumericValue: () => createHasNumericValue,
    createHelp: () => createHelp,
    createHelpClass: () => createHelpClass,
    createHex: () => createHex,
    createHypot: () => createHypot,
    createI: () => createI,
    createIdentity: () => createIdentity,
    createIfft: () => createIfft,
    createIm: () => createIm,
    createImmutableDenseMatrixClass: () => createImmutableDenseMatrixClass,
    createIndex: () => createIndex,
    createIndexClass: () => createIndexClass,
    createIndexNode: () => createIndexNode,
    createIndexTransform: () => createIndexTransform,
    createInfinity: () => createInfinity,
    createIntersect: () => createIntersect,
    createInv: () => createInv,
    createInverseConductanceQuantum: () => createInverseConductanceQuantum,
    createInvmod: () => createInvmod,
    createIsInteger: () => createIsInteger,
    createIsNaN: () => createIsNaN,
    createIsNegative: () => createIsNegative,
    createIsNumeric: () => createIsNumeric,
    createIsPositive: () => createIsPositive,
    createIsPrime: () => createIsPrime,
    createIsZero: () => createIsZero,
    createKldivergence: () => createKldivergence,
    createKlitzing: () => createKlitzing,
    createKron: () => createKron,
    createLN10: () => createLN10,
    createLN2: () => createLN2,
    createLOG10E: () => createLOG10E,
    createLOG2E: () => createLOG2E,
    createLarger: () => createLarger,
    createLargerEq: () => createLargerEq,
    createLcm: () => createLcm,
    createLeafCount: () => createLeafCount,
    createLeftShift: () => createLeftShift,
    createLgamma: () => createLgamma,
    createLog: () => createLog,
    createLog10: () => createLog10,
    createLog1p: () => createLog1p,
    createLog2: () => createLog2,
    createLoschmidt: () => createLoschmidt,
    createLsolve: () => createLsolve,
    createLsolveAll: () => createLsolveAll,
    createLup: () => createLup,
    createLusolve: () => createLusolve,
    createMad: () => createMad,
    createMagneticConstant: () => createMagneticConstant,
    createMagneticFluxQuantum: () => createMagneticFluxQuantum,
    createMap: () => createMap2,
    createMapTransform: () => createMapTransform,
    createMatrix: () => createMatrix,
    createMatrixClass: () => createMatrixClass,
    createMatrixFromColumns: () => createMatrixFromColumns,
    createMatrixFromFunction: () => createMatrixFromFunction,
    createMatrixFromRows: () => createMatrixFromRows,
    createMax: () => createMax,
    createMaxTransform: () => createMaxTransform,
    createMean: () => createMean,
    createMeanTransform: () => createMeanTransform,
    createMedian: () => createMedian,
    createMin: () => createMin,
    createMinTransform: () => createMinTransform,
    createMod: () => createMod,
    createMode: () => createMode,
    createMolarMass: () => createMolarMass,
    createMolarMassC12: () => createMolarMassC12,
    createMolarPlanckConstant: () => createMolarPlanckConstant,
    createMolarVolume: () => createMolarVolume,
    createMultinomial: () => createMultinomial,
    createMultiply: () => createMultiply,
    createMultiplyScalar: () => createMultiplyScalar,
    createNaN: () => createNaN,
    createNeutronMass: () => createNeutronMass,
    createNode: () => createNode,
    createNorm: () => createNorm,
    createNot: () => createNot,
    createNthRoot: () => createNthRoot,
    createNthRoots: () => createNthRoots,
    createNuclearMagneton: () => createNuclearMagneton,
    createNull: () => createNull,
    createNumber: () => createNumber,
    createNumeric: () => createNumeric,
    createObjectNode: () => createObjectNode,
    createOct: () => createOct,
    createOnes: () => createOnes,
    createOperatorNode: () => createOperatorNode,
    createOr: () => createOr,
    createParenthesisNode: () => createParenthesisNode,
    createParse: () => createParse,
    createParser: () => createParser,
    createParserClass: () => createParserClass,
    createPartitionSelect: () => createPartitionSelect,
    createPermutations: () => createPermutations,
    createPhi: () => createPhi,
    createPi: () => createPi,
    createPickRandom: () => createPickRandom,
    createPinv: () => createPinv,
    createPlanckCharge: () => createPlanckCharge,
    createPlanckConstant: () => createPlanckConstant,
    createPlanckLength: () => createPlanckLength,
    createPlanckMass: () => createPlanckMass,
    createPlanckTemperature: () => createPlanckTemperature,
    createPlanckTime: () => createPlanckTime,
    createPow: () => createPow,
    createPrint: () => createPrint,
    createProd: () => createProd,
    createProtonMass: () => createProtonMass,
    createQr: () => createQr,
    createQuantileSeq: () => createQuantileSeq,
    createQuantumOfCirculation: () => createQuantumOfCirculation,
    createRandom: () => createRandom,
    createRandomInt: () => createRandomInt,
    createRange: () => createRange,
    createRangeClass: () => createRangeClass,
    createRangeNode: () => createRangeNode,
    createRangeTransform: () => createRangeTransform,
    createRationalize: () => createRationalize,
    createRe: () => createRe,
    createReducedPlanckConstant: () => createReducedPlanckConstant,
    createRelationalNode: () => createRelationalNode,
    createReplacer: () => createReplacer,
    createReshape: () => createReshape,
    createResize: () => createResize,
    createResolve: () => createResolve,
    createResultSet: () => createResultSet,
    createReviver: () => createReviver,
    createRightArithShift: () => createRightArithShift,
    createRightLogShift: () => createRightLogShift,
    createRotate: () => createRotate,
    createRotationMatrix: () => createRotationMatrix,
    createRound: () => createRound,
    createRow: () => createRow,
    createRowTransform: () => createRowTransform,
    createRydberg: () => createRydberg,
    createSQRT1_2: () => createSQRT1_2,
    createSQRT2: () => createSQRT2,
    createSackurTetrode: () => createSackurTetrode,
    createSec: () => createSec,
    createSech: () => createSech,
    createSecondRadiation: () => createSecondRadiation,
    createSetCartesian: () => createSetCartesian,
    createSetDifference: () => createSetDifference,
    createSetDistinct: () => createSetDistinct,
    createSetIntersect: () => createSetIntersect,
    createSetIsSubset: () => createSetIsSubset,
    createSetMultiplicity: () => createSetMultiplicity,
    createSetPowerset: () => createSetPowerset,
    createSetSize: () => createSetSize,
    createSetSymDifference: () => createSetSymDifference,
    createSetUnion: () => createSetUnion,
    createSign: () => createSign,
    createSimplify: () => createSimplify,
    createSimplifyConstant: () => createSimplifyConstant,
    createSimplifyCore: () => createSimplifyCore,
    createSin: () => createSin,
    createSinh: () => createSinh,
    createSize: () => createSize,
    createSlu: () => createSlu,
    createSmaller: () => createSmaller,
    createSmallerEq: () => createSmallerEq,
    createSort: () => createSort,
    createSpaClass: () => createSpaClass,
    createSparse: () => createSparse,
    createSparseMatrixClass: () => createSparseMatrixClass,
    createSpeedOfLight: () => createSpeedOfLight,
    createSplitUnit: () => createSplitUnit,
    createSqrt: () => createSqrt,
    createSqrtm: () => createSqrtm,
    createSquare: () => createSquare,
    createSqueeze: () => createSqueeze,
    createStd: () => createStd,
    createStdTransform: () => createStdTransform,
    createStefanBoltzmann: () => createStefanBoltzmann,
    createStirlingS2: () => createStirlingS2,
    createString: () => createString,
    createSubset: () => createSubset,
    createSubsetTransform: () => createSubsetTransform,
    createSubtract: () => createSubtract,
    createSum: () => createSum,
    createSumTransform: () => createSumTransform,
    createSymbolNode: () => createSymbolNode,
    createSymbolicEqual: () => createSymbolicEqual,
    createTan: () => createTan,
    createTanh: () => createTanh,
    createTau: () => createTau,
    createThomsonCrossSection: () => createThomsonCrossSection,
    createTo: () => createTo,
    createTrace: () => createTrace,
    createTranspose: () => createTranspose,
    createTrue: () => createTrue,
    createTypeOf: () => createTypeOf,
    createTyped: () => createTyped,
    createUnaryMinus: () => createUnaryMinus,
    createUnaryPlus: () => createUnaryPlus,
    createUnequal: () => createUnequal,
    createUnitClass: () => createUnitClass,
    createUnitFunction: () => createUnitFunction,
    createUppercaseE: () => createUppercaseE,
    createUppercasePi: () => createUppercasePi,
    createUsolve: () => createUsolve,
    createUsolveAll: () => createUsolveAll,
    createVacuumImpedance: () => createVacuumImpedance,
    createVariance: () => createVariance,
    createVarianceTransform: () => createVarianceTransform,
    createVersion: () => createVersion,
    createWeakMixingAngle: () => createWeakMixingAngle,
    createWienDisplacement: () => createWienDisplacement,
    createXgcd: () => createXgcd,
    createXor: () => createXor,
    createZeros: () => createZeros
  });

  // node_modules/mathjs/lib/esm/core/function/typed.js
  var import_typed_function = __toESM(require_typed_function(), 1);

  // node_modules/mathjs/lib/esm/utils/number.js
  function isInteger(value) {
    if (typeof value === "boolean") {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  var sign = Math.sign || function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  var log2 = Math.log2 || function log22(x) {
    return Math.log(x) / Math.LN2;
  };
  var log10 = Math.log10 || function log102(x) {
    return Math.log(x) / Math.LN10;
  };
  var log1p = Math.log1p || function(x) {
    return Math.log(x + 1);
  };
  var cbrt = Math.cbrt || function cbrt2(x) {
    if (x === 0) {
      return x;
    }
    var negate = x < 0;
    var result;
    if (negate) {
      x = -x;
    }
    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3);
      result = (x / (result * result) + 2 * result) / 3;
    } else {
      result = x;
    }
    return negate ? -result : result;
  };
  var expm1 = Math.expm1 || function expm12(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
  };
  function formatNumberToBase(n, base, size) {
    var prefixes = {
      2: "0b",
      8: "0o",
      16: "0x"
    };
    var prefix = prefixes[base];
    var suffix = "";
    if (size) {
      if (size < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size)) {
        throw new Error("size must be an integer");
      }
      if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
        throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
      }
      if (!isInteger(n)) {
        throw new Error("Value must be an integer");
      }
      if (n < 0) {
        n = n + 2 ** size;
      }
      suffix = "i".concat(size);
    }
    var sign3 = "";
    if (n < 0) {
      n = -n;
      sign3 = "-";
    }
    return "".concat(sign3).concat(prefix).concat(n.toString(base)).concat(suffix);
  }
  function format(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    } else if (isNaN(value)) {
      return "NaN";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options) {
      if (options.notation) {
        notation = options.notation;
      }
      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed(value, precision);
      case "exponential":
        return toExponential(value, precision);
      case "engineering":
        return toEngineering(value, precision);
      case "bin":
        return formatNumberToBase(value, 2, wordSize);
      case "oct":
        return formatNumberToBase(value, 8, wordSize);
      case "hex":
        return formatNumberToBase(value, 16, wordSize);
      case "auto":
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e2 = arguments[4];
          return digits2 !== "." ? digits2 + e2 : e2;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function splitNumber(value) {
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError("Invalid number " + value);
    }
    var sign3 = match[1];
    var digits2 = match[2];
    var exponent = parseFloat(match[4] || "0");
    var dot = digits2.indexOf(".");
    exponent += dot !== -1 ? dot - 1 : digits2.length - 1;
    var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
      exponent -= zeros2.length;
      return "";
    }).replace(/0*$/, "").split("").map(function(d) {
      return parseInt(d);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign: sign3,
      coefficients,
      exponent
    };
  }
  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e2 = rounded.exponent;
    var c = rounded.coefficients;
    var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
    if (isNumber(precision)) {
      while (precision > c.length || e2 - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      var missingZeros = Math.abs(e2 - newExp) - (c.length - 1);
      for (var i = 0; i < missingZeros; i++) {
        c.push(0);
      }
    }
    var expDiff = Math.abs(e2 - newExp);
    var decimalIdx = 1;
    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    }
    var decimals = c.slice(decimalIdx).join("");
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
    var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
    return rounded.sign + str;
  }
  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1;
    var pp = p + (precision || 0);
    if (c.length < pp) {
      c = c.concat(zeros(pp - c.length));
    }
    if (p < 0) {
      c = zeros(-p + 1).concat(c);
      p = 1;
    }
    if (p < c.length) {
      c.splice(p, 0, p === 0 ? "0." : ".");
    }
    return rounded.sign + c.join("");
  }
  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e2 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e2 >= 0 ? "+" : "") + e2;
  }
  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      return toExponential(value, precision);
    } else {
      var c = rounded.coefficients;
      var e2 = rounded.exponent;
      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      }
      c = c.concat(zeros(e2 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
      c = zeros(-e2).concat(c);
      var dot = e2 > 0 ? e2 : 0;
      if (dot < c.length - 1) {
        c.splice(dot + 1, 0, ".");
      }
      return rounded.sign + c.join("");
    }
  }
  function roundDigits(split, precision) {
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients;
    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        var i = precision - 1;
        c[i]++;
        while (c[i] === 10) {
          c.pop();
          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }
          i--;
          c[i]++;
        }
      }
    }
    return rounded;
  }
  function zeros(length) {
    var arr = [];
    for (var i = 0; i < length; i++) {
      arr.push(0);
    }
    return arr;
  }
  function digits(value) {
    return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
  }
  var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
  function nearlyEqual(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x === y;
    }
    if (x === y) {
      return true;
    }
    if (isNaN(x) || isNaN(y)) {
      return false;
    }
    if (isFinite(x) && isFinite(y)) {
      var diff = Math.abs(x - y);
      if (diff < DBL_EPSILON) {
        return true;
      } else {
        return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
      }
    }
    return false;
  }
  var acosh = Math.acosh || function(x) {
    return Math.log(Math.sqrt(x * x - 1) + x);
  };
  var asinh = Math.asinh || function(x) {
    return Math.log(Math.sqrt(x * x + 1) + x);
  };
  var atanh = Math.atanh || function(x) {
    return Math.log((1 + x) / (1 - x)) / 2;
  };
  var cosh = Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  };
  var sinh = Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  };
  var tanh = Math.tanh || function(x) {
    var e2 = Math.exp(2 * x);
    return (e2 - 1) / (e2 + 1);
  };
  function copysign(x, y) {
    var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
    var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
    return signx ^ signy ? -x : x;
  }

  // node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
  function formatBigNumberToBase(n, base, size) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = "";
    if (size) {
      if (size < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size)) {
        throw new Error("size must be an integer");
      }
      if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
      }
      if (!n.isInteger()) {
        throw new Error("Value must be an integer");
      }
      if (n.lessThan(0)) {
        n = n.add(big2.pow(size));
      }
      suffix = "i".concat(size);
    }
    switch (base) {
      case 2:
        return "".concat(n.toBinary()).concat(suffix);
      case 8:
        return "".concat(n.toOctal()).concat(suffix);
      case 16:
        return "".concat(n.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  function format2(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (!value.isFinite()) {
      return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options !== void 0) {
      if (options.notation) {
        notation = options.notation;
      }
      if (typeof options === "number") {
        precision = options;
      } else if (options.precision) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed2(value, precision);
      case "exponential":
        return toExponential2(value, precision);
      case "engineering":
        return toEngineering2(value, precision);
      case "bin":
        return formatBigNumberToBase(value, 2, wordSize);
      case "oct":
        return formatBigNumberToBase(value, 8, wordSize);
      case "hex":
        return formatBigNumberToBase(value, 16, wordSize);
      case "auto": {
        var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
        var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
        if (value.isZero())
          return "0";
        var str;
        var rounded = value.toSignificantDigits(precision);
        var exp2 = rounded.e;
        if (exp2 >= lowerExp && exp2 < upperExp) {
          str = rounded.toFixed();
        } else {
          str = toExponential2(value, precision);
        }
        return str.replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e2 = arguments[4];
          return digits2 !== "." ? digits2 + e2 : e2;
        });
      }
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function toEngineering2(value, precision) {
    var e2 = value.e;
    var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.indexOf("e") !== -1) {
      valueStr = valueWithoutExp.toString();
    }
    return valueStr + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
  }
  function toExponential2(value, precision) {
    if (precision !== void 0) {
      return value.toExponential(precision - 1);
    } else {
      return value.toExponential();
    }
  }
  function toFixed2(value, precision) {
    return value.toFixed(precision);
  }

  // node_modules/mathjs/lib/esm/utils/string.js
  function endsWith(text, search) {
    var start = text.length - search.length;
    var end = text.length;
    return text.substring(start, end) === search;
  }
  function format3(value, options) {
    var result = _format(value, options);
    if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
      return result.substring(0, options.truncate - 3) + "...";
    }
    return result;
  }
  function _format(value, options) {
    if (typeof value === "number") {
      return format(value, options);
    }
    if (isBigNumber(value)) {
      return format2(value, options);
    }
    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== "decimal") {
        return value.s * value.n + "/" + value.d;
      } else {
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return '"' + value + '"';
    }
    if (typeof value === "function") {
      return value.syntax ? String(value.syntax) : "function";
    }
    if (value && typeof value === "object") {
      if (typeof value.format === "function") {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map((key) => {
          return '"' + key + '": ' + format3(value[key], options);
        });
        return "{" + entries.join(", ") + "}";
      }
    }
    return String(value);
  }
  function stringify(value) {
    var text = String(value);
    var escaped = "";
    var i = 0;
    while (i < text.length) {
      var c = text.charAt(i);
      if (c === "\\") {
        escaped += c;
        i++;
        c = text.charAt(i);
        if (c === "" || '"\\/bfnrtu'.indexOf(c) === -1) {
          escaped += "\\";
        }
        escaped += c;
      } else if (c === '"') {
        escaped += '\\"';
      } else {
        escaped += c;
      }
      i++;
    }
    return '"' + escaped + '"';
  }
  function escape(value) {
    var text = String(value);
    text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return text;
  }
  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = "[";
      var len = array.length;
      for (var i = 0; i < len; i++) {
        if (i !== 0) {
          str += ", ";
        }
        str += formatArray(array[i], options);
      }
      str += "]";
      return str;
    } else {
      return format3(array, options);
    }
  }
  function looksLikeFraction(value) {
    return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
  }
  function compareText(x, y) {
    if (!isString(x)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
    }
    if (!isString(y)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)");
    }
    return x === y ? 0 : x > y ? 1 : -1;
  }

  // node_modules/mathjs/lib/esm/error/DimensionError.js
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = "DimensionError";
  DimensionError.prototype.isDimensionError = true;

  // node_modules/mathjs/lib/esm/error/IndexError.js
  function IndexError(index, min2, max2) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.index = index;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min2;
    } else {
      this.min = min2;
      this.max = max2;
    }
    if (this.min !== void 0 && this.index < this.min) {
      this.message = "Index out of range (" + this.index + " < " + this.min + ")";
    } else if (this.max !== void 0 && this.index >= this.max) {
      this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
    } else {
      this.message = "Index out of range (" + this.index + ")";
    }
    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = "IndexError";
  IndexError.prototype.isIndexError = true;

  // node_modules/mathjs/lib/esm/utils/array.js
  function arraySize(x) {
    var s = [];
    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }
    return s;
  }
  function _validate(array, size, dim) {
    var i;
    var len = array.length;
    if (len !== size[dim]) {
      throw new DimensionError(len, size[dim]);
    }
    if (dim < size.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < len; i++) {
        var child = array[i];
        if (!Array.isArray(child)) {
          throw new DimensionError(size.length - 1, size.length, "<");
        }
        _validate(array[i], size, dimNext);
      }
    } else {
      for (i = 0; i < len; i++) {
        if (Array.isArray(array[i])) {
          throw new DimensionError(size.length + 1, size.length, ">");
        }
      }
    }
  }
  function validate(array, size) {
    var isScalar = size.length === 0;
    if (isScalar) {
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      _validate(array, size, 0);
    }
  }
  function validateIndex(index, length) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError("Index must be an integer (value: " + index + ")");
    }
    if (index < 0 || typeof length === "number" && index >= length) {
      throw new IndexError(index, length);
    }
  }
  function resize(array, size, defaultValue) {
    if (!Array.isArray(array) || !Array.isArray(size)) {
      throw new TypeError("Array expected");
    }
    if (size.length === 0) {
      throw new Error("Resizing to scalar is not supported");
    }
    size.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size) + ")");
      }
    });
    var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
    _resize(array, size, 0, _defaultValue);
    return array;
  }
  function _resize(array, size, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size[dim];
    var minLen = Math.min(oldLen, newLen);
    array.length = newLen;
    if (dim < size.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < minLen; i++) {
        elem = array[i];
        if (!Array.isArray(elem)) {
          elem = [elem];
          array[i] = elem;
        }
        _resize(elem, size, dimNext, defaultValue);
      }
      for (i = minLen; i < newLen; i++) {
        elem = [];
        array[i] = elem;
        _resize(elem, size, dimNext, defaultValue);
      }
    } else {
      for (i = 0; i < minLen; i++) {
        while (Array.isArray(array[i])) {
          array[i] = array[i][0];
        }
      }
      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, "!=");
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e2) {
      if (e2 instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, "!=");
      }
      throw e2;
    }
  }
  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error("More than one wildcard in sizes");
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
      }
    }
    return processedSizes;
  }
  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  function _reshape(array, sizes) {
    var tmpArray = array;
    var tmpArray2;
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex];
      tmpArray2 = [];
      var length = tmpArray.length / size;
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
      }
      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  function squeeze(array, size) {
    var s = size || arraySize(array);
    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s.shift();
    }
    var dims = s.length;
    while (s[dims - 1] === 1) {
      dims--;
    }
    if (dims < s.length) {
      array = _squeeze(array, dims, 0);
      s.length = dims;
    }
    return array;
  }
  function _squeeze(array, dims, dim) {
    var i, ii;
    if (dim < dims) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _squeeze(array[i], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }
    return array;
  }
  function unsqueeze(array, dims, outer, size) {
    var s = size || arraySize(array);
    if (outer) {
      for (var i = 0; i < outer; i++) {
        array = [array];
        s.unshift(1);
      }
    }
    array = _unsqueeze(array, dims, 0);
    while (s.length < dims) {
      s.push(1);
    }
    return array;
  }
  function _unsqueeze(array, dims, dim) {
    var i, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _unsqueeze(array[i], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }
    return array;
  }
  function flatten(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback);
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  function map(array, callback) {
    return Array.prototype.map.call(array, callback);
  }
  function forEach(array, callback) {
    Array.prototype.forEach.call(array, callback);
  }
  function filter(array, callback) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, callback);
  }
  function filterRegExp(array, regexp) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
  }
  function join(array, separator) {
    return Array.prototype.join.call(array, separator);
  }
  function identify(a) {
    if (!Array.isArray(a)) {
      throw new TypeError("Array input expected");
    }
    if (a.length === 0) {
      return a;
    }
    var b = [];
    var count = 0;
    b[0] = {
      value: a[0],
      identifier: 0
    };
    for (var i = 1; i < a.length; i++) {
      if (a[i] === a[i - 1]) {
        count++;
      } else {
        count = 0;
      }
      b.push({
        value: a[i],
        identifier: count
      });
    }
    return b;
  }
  function generalize(a) {
    if (!Array.isArray(a)) {
      throw new TypeError("Array input expected");
    }
    if (a.length === 0) {
      return a;
    }
    var b = [];
    for (var i = 0; i < a.length; i++) {
      b.push(a[i].value);
    }
    return b;
  }
  function getArrayDataType(array, typeOf2) {
    var type;
    var length = 0;
    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      var isArray2 = Array.isArray(item);
      if (i === 0 && isArray2) {
        length = item.length;
      }
      if (isArray2 && item.length !== length) {
        return void 0;
      }
      var itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
      if (type === void 0) {
        type = itemType;
      } else if (type !== itemType) {
        return "mixed";
      } else {
      }
    }
    return type;
  }
  function contains2(array, item) {
    return array.indexOf(item) !== -1;
  }

  // node_modules/mathjs/lib/esm/utils/factory.js
  function factory(name297, dependencies298, create2, meta) {
    function assertAndCreate(scope) {
      var deps = pickShallow(scope, dependencies298.map(stripOptionalNotation));
      assertDependencies(name297, dependencies298, scope);
      return create2(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name297;
    assertAndCreate.dependencies = dependencies298.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  function isFactory(obj) {
    return typeof obj === "function" && typeof obj.fn === "string" && Array.isArray(obj.dependencies);
  }
  function assertDependencies(name297, dependencies298, scope) {
    var allDefined = dependencies298.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
    if (!allDefined) {
      var missingDependencies = dependencies298.filter((dependency) => scope[dependency] === void 0);
      throw new Error('Cannot create function "'.concat(name297, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === "?";
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
  }

  // node_modules/mathjs/lib/esm/utils/customs.js
  function getSafeProperty(object, prop) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function setSafeProperty(object, prop, value) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function hasSafeProperty(object, prop) {
    return prop in object;
  }
  function isSafeProperty(object, prop) {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (hasOwnProperty2(safeNativeProperties, prop)) {
      return true;
    }
    if (prop in Object.prototype) {
      return false;
    }
    if (prop in Function.prototype) {
      return false;
    }
    return true;
  }
  function validateSafeMethod(object, method) {
    if (!isSafeMethod(object, method)) {
      throw new Error('No access to method "' + method + '"');
    }
  }
  function isSafeMethod(object, method) {
    if (object === null || object === void 0 || typeof object[method] !== "function") {
      return false;
    }
    if (hasOwnProperty2(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    }
    if (hasOwnProperty2(safeNativeMethods, method)) {
      return true;
    }
    if (method in Object.prototype) {
      return false;
    }
    if (method in Function.prototype) {
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === "object" && object && object.constructor === Object;
  }
  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  // node_modules/mathjs/lib/esm/utils/map.js
  var ObjectWrappingMap = class {
    constructor(object) {
      this.wrappedObject = object;
    }
    keys() {
      return Object.keys(this.wrappedObject);
    }
    get(key) {
      return getSafeProperty(this.wrappedObject, key);
    }
    set(key, value) {
      setSafeProperty(this.wrappedObject, key, value);
      return this;
    }
    has(key) {
      return hasSafeProperty(this.wrappedObject, key);
    }
  };
  function createEmptyMap() {
    return /* @__PURE__ */ new Map();
  }
  function createMap(mapOrObject) {
    if (!mapOrObject) {
      return createEmptyMap();
    }
    if (isMap(mapOrObject)) {
      return mapOrObject;
    }
    if (isObject(mapOrObject)) {
      return new ObjectWrappingMap(mapOrObject);
    }
    throw new Error("createMap can create maps from objects or Maps");
  }
  function toObject(map2) {
    if (map2 instanceof ObjectWrappingMap) {
      return map2.wrappedObject;
    }
    var object = {};
    for (var key of map2.keys()) {
      var value = map2.get(key);
      setSafeProperty(object, key, value);
    }
    return object;
  }
  function isMap(object) {
    if (!object) {
      return false;
    }
    return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
  }
  function assign(map2) {
    for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      objects[_key - 1] = arguments[_key];
    }
    for (var args of objects) {
      if (!args) {
        continue;
      }
      if (isMap(args)) {
        for (var key of args.keys()) {
          map2.set(key, args.get(key));
        }
      } else if (isObject(args)) {
        for (var _key2 of Object.keys(args)) {
          map2.set(_key2, args[_key2]);
        }
      }
    }
    return map2;
  }

  // node_modules/mathjs/lib/esm/core/function/typed.js
  var _createTyped2 = function _createTyped() {
    _createTyped2 = import_typed_function.default.create;
    return import_typed_function.default;
  };
  var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
  var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
    var {
      BigNumber,
      Complex: Complex2,
      DenseMatrix,
      Fraction: Fraction2
    } = _ref;
    var typed = _createTyped2();
    typed.clear();
    typed.addTypes([
      {
        name: "number",
        test: isNumber
      },
      {
        name: "Complex",
        test: isComplex
      },
      {
        name: "BigNumber",
        test: isBigNumber
      },
      {
        name: "Fraction",
        test: isFraction
      },
      {
        name: "Unit",
        test: isUnit
      },
      {
        name: "identifier",
        test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])*$/.test(s)
      },
      {
        name: "string",
        test: isString
      },
      {
        name: "Chain",
        test: isChain
      },
      {
        name: "Array",
        test: isArray
      },
      {
        name: "Matrix",
        test: isMatrix
      },
      {
        name: "DenseMatrix",
        test: isDenseMatrix
      },
      {
        name: "SparseMatrix",
        test: isSparseMatrix
      },
      {
        name: "Range",
        test: isRange
      },
      {
        name: "Index",
        test: isIndex
      },
      {
        name: "boolean",
        test: isBoolean
      },
      {
        name: "ResultSet",
        test: isResultSet
      },
      {
        name: "Help",
        test: isHelp
      },
      {
        name: "function",
        test: isFunction
      },
      {
        name: "Date",
        test: isDate
      },
      {
        name: "RegExp",
        test: isRegExp
      },
      {
        name: "null",
        test: isNull
      },
      {
        name: "undefined",
        test: isUndefined
      },
      {
        name: "AccessorNode",
        test: isAccessorNode
      },
      {
        name: "ArrayNode",
        test: isArrayNode
      },
      {
        name: "AssignmentNode",
        test: isAssignmentNode
      },
      {
        name: "BlockNode",
        test: isBlockNode
      },
      {
        name: "ConditionalNode",
        test: isConditionalNode
      },
      {
        name: "ConstantNode",
        test: isConstantNode
      },
      {
        name: "FunctionNode",
        test: isFunctionNode
      },
      {
        name: "FunctionAssignmentNode",
        test: isFunctionAssignmentNode
      },
      {
        name: "IndexNode",
        test: isIndexNode
      },
      {
        name: "Node",
        test: isNode
      },
      {
        name: "ObjectNode",
        test: isObjectNode
      },
      {
        name: "OperatorNode",
        test: isOperatorNode
      },
      {
        name: "ParenthesisNode",
        test: isParenthesisNode
      },
      {
        name: "RangeNode",
        test: isRangeNode
      },
      {
        name: "RelationalNode",
        test: isRelationalNode
      },
      {
        name: "SymbolNode",
        test: isSymbolNode
      },
      {
        name: "Map",
        test: isMap
      },
      {
        name: "Object",
        test: isObject
      }
    ]);
    typed.addConversions([{
      from: "number",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        if (digits(x) > 15) {
          throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
        }
        return new BigNumber(x);
      }
    }, {
      from: "number",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        return new Complex2(x, 0);
      }
    }, {
      from: "BigNumber",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        return new Complex2(x.toNumber(), 0);
      }
    }, {
      from: "Fraction",
      to: "BigNumber",
      convert: function convert(x) {
        throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
      }
    }, {
      from: "Fraction",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        return new Complex2(x.valueOf(), 0);
      }
    }, {
      from: "number",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction2) {
          throwNoFraction(x);
        }
        var f = new Fraction2(x);
        if (f.valueOf() !== x) {
          throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
        }
        return f;
      }
    }, {
      from: "string",
      to: "number",
      convert: function convert(x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: "string",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        try {
          return new BigNumber(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: "string",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction2) {
          throwNoFraction(x);
        }
        try {
          return new Fraction2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: "string",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex2) {
          throwNoComplex(x);
        }
        try {
          return new Complex2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: "boolean",
      to: "number",
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: "boolean",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        return new BigNumber(+x);
      }
    }, {
      from: "boolean",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction2) {
          throwNoFraction(x);
        }
        return new Fraction2(+x);
      }
    }, {
      from: "boolean",
      to: "string",
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: "Array",
      to: "Matrix",
      convert: function convert(array) {
        if (!DenseMatrix) {
          throwNoMatrix();
        }
        return new DenseMatrix(array);
      }
    }, {
      from: "Matrix",
      to: "Array",
      convert: function convert(matrix) {
        return matrix.valueOf();
      }
    }]);
    typed.onMismatch = (name297, args, signatures) => {
      var usualError = typed.createError(name297, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
        var err = new TypeError("Function '".concat(name297, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name297, ")'."));
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    typed.onMismatch = (name297, args, signatures) => {
      var usualError = typed.createError(name297, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
        var err = new TypeError("Function '".concat(name297, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name297, ")'."));
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    return typed;
  });
  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
  }
  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  // node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
  var name = "ResultSet";
  var dependencies2 = [];
  var createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
    function ResultSet(entries) {
      if (!(this instanceof ResultSet)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.entries = entries || [];
    }
    ResultSet.prototype.type = "ResultSet";
    ResultSet.prototype.isResultSet = true;
    ResultSet.prototype.valueOf = function() {
      return this.entries;
    };
    ResultSet.prototype.toString = function() {
      return "[" + this.entries.join(", ") + "]";
    };
    ResultSet.prototype.toJSON = function() {
      return {
        mathjs: "ResultSet",
        entries: this.entries
      };
    };
    ResultSet.fromJSON = function(json) {
      return new ResultSet(json.entries);
    };
    return ResultSet;
  }, {
    isClass: true
  });

  // node_modules/decimal.js/decimal.mjs
  var EXP_LIMIT = 9e15;
  var MAX_DIGITS = 1e9;
  var NUMERALS = "0123456789abcdef";
  var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var DEFAULTS = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -EXP_LIMIT,
    maxE: EXP_LIMIT,
    crypto: false
  };
  var inexact;
  var quadrant;
  var external = true;
  var decimalError = "[DecimalError] ";
  var invalidArgument = decimalError + "Invalid argument: ";
  var precisionLimitExceeded = decimalError + "Precision limit exceeded";
  var cryptoUnavailable = decimalError + "crypto unavailable";
  var tag = "[object Decimal]";
  var mathfloor = Math.floor;
  var mathpow = Math.pow;
  var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var BASE = 1e7;
  var LOG_BASE = 7;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var LN10_PRECISION = LN10.length - 1;
  var PI_PRECISION = PI.length - 1;
  var P = { toStringTag: tag };
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s < 0)
      x.s = 1;
    return finalise(x);
  };
  P.ceil = function() {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };
  P.clampedTo = P.clamp = function(min2, max2) {
    var k, x = this, Ctor = x.constructor;
    min2 = new Ctor(min2);
    max2 = new Ctor(max2);
    if (!min2.s || !max2.s)
      return new Ctor(NaN);
    if (min2.gt(max2))
      throw Error(invalidArgument + max2);
    k = x.cmp(min2);
    return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
  };
  P.comparedTo = P.cmp = function(y) {
    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }
    if (!xd[0] || !yd[0])
      return xd[0] ? xs : yd[0] ? -ys : 0;
    if (xs !== ys)
      return xs;
    if (x.e !== y.e)
      return x.e > y.e ^ xs < 0 ? 1 : -1;
    xdL = xd.length;
    ydL = yd.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i])
        return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };
  P.cosine = P.cos = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.d)
      return new Ctor(NaN);
    if (!x.d[0])
      return new Ctor(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };
  P.cubeRoot = P.cbrt = function() {
    var e2, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    external = false;
    s = x.s * mathpow(x.s * x, 1 / 3);
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e2 = x.e;
      if (s = (e2 - n.length + 1) % 3)
        n += s == 1 || s == -2 ? "0" : "00";
      s = mathpow(n, 1 / 3);
      e2 = mathfloor((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2));
      if (s == 1 / 0) {
        n = "5e" + e2;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e2;
      }
      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e2 = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e2 + 1, 0);
            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e2 + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e2, Ctor.rounding, m);
  };
  P.decimalPlaces = P.dp = function() {
    var w, d = this.d, n = NaN;
    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
      w = d[w];
      if (w)
        for (; w % 10 == 0; w /= 10)
          n--;
      if (n < 0)
        n = 0;
    }
    return n;
  };
  P.dividedBy = P.div = function(y) {
    return divide(this, new this.constructor(y));
  };
  P.dividedToIntegerBy = P.divToInt = function(y) {
    var x = this, Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };
  P.equals = P.eq = function(y) {
    return this.cmp(y) === 0;
  };
  P.floor = function() {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };
  P.greaterThan = P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };
  P.hyperbolicCosine = P.cosh = function() {
    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
    if (!x.isFinite())
      return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero())
      return one;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = "2.3283064365386962890625e-10";
    }
    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
    var cosh2_x, i = k, d8 = new Ctor(8);
    for (; i--; ) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }
    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.hyperbolicSine = P.sinh = function() {
    var k, pr, rm, len, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);
      var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(x, pr, rm, true);
  };
  P.hyperbolicTangent = P.tanh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(x.s);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;
    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };
  P.inverseCosine = P.acos = function() {
    var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
    if (k !== -1) {
      return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
    }
    if (x.isZero())
      return getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return halfPi.minus(x);
  };
  P.inverseHyperbolicCosine = P.acosh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (x.lte(1))
      return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).minus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicSine = P.asinh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).plus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicTangent = P.atanh = function() {
    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.e >= 0)
      return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();
    if (Math.max(xsd, pr) < 2 * -x.e - 1)
      return finalise(new Ctor(x), pr, rm, true);
    Ctor.precision = wpr = xsd - x.e;
    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
    Ctor.precision = pr + 4;
    Ctor.rounding = 1;
    x = x.ln();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(0.5);
  };
  P.inverseSine = P.asin = function() {
    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
    if (x.isZero())
      return new Ctor(x);
    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (k !== -1) {
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }
      return new Ctor(NaN);
    }
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseTangent = P.atan = function() {
    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
    if (!x.isFinite()) {
      if (!x.s)
        return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }
    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;
    k = Math.min(28, wpr / LOG_BASE + 2 | 0);
    for (i = k; i; --i)
      x = x.div(x.times(x).plus(1).sqrt().plus(1));
    external = false;
    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;
    for (; i !== -1; ) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));
      px = px.times(x2);
      r = t.plus(px.div(n += 2));
      if (r.d[j] !== void 0)
        for (i = j; r.d[i] === t.d[i] && i--; )
          ;
    }
    if (k)
      r = r.times(2 << k - 1);
    external = true;
    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.isFinite = function() {
    return !!this.d;
  };
  P.isInteger = P.isInt = function() {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = P.isNeg = function() {
    return this.s < 0;
  };
  P.isPositive = P.isPos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  P.lessThan = P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.logarithm = P.log = function(base) {
    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;
      if (base.s < 0 || !d || !d[0] || base.eq(1))
        return new Ctor(NaN);
      isBase10 = base.eq(10);
    }
    d = arg.d;
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0; )
          k /= 10;
        inf = k !== 1;
      }
    }
    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
    r = divide(num, denominator, sd, 1);
    if (checkRoundingDigits(r.d, k = pr, rm)) {
      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (!inf) {
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }
    external = true;
    return finalise(r, pr, rm);
  };
  P.minus = P.sub = function(y) {
    var d, e2, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s)
        y = new Ctor(NaN);
      else if (x.d)
        y.s = -y.s;
      else
        y = new Ctor(y.d || x.s !== y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (yd[0])
        y.s = -y.s;
      else if (xd[0])
        y = new Ctor(x);
      else
        return new Ctor(rm === 3 ? -0 : 0);
      return external ? finalise(y, pr, rm) : y;
    }
    e2 = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);
    xd = xd.slice();
    k = xe - e2;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e2 = xe;
        len = xd.length;
      }
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
      if (k > i) {
        k = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k; i--; )
        d.push(0);
      d.reverse();
    } else {
      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy)
        len = i;
      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }
    len = xd.length;
    for (i = yd.length - len; i > 0; --i)
      xd[len++] = 0;
    for (i = yd.length; i > k; ) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0; )
          xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }
      xd[i] -= yd[i];
    }
    for (; xd[--len] === 0; )
      xd.pop();
    for (; xd[0] === 0; xd.shift())
      --e2;
    if (!xd[0])
      return new Ctor(rm === 3 ? -0 : 0);
    y.d = xd;
    y.e = getBase10Exponent(xd, e2);
    return external ? finalise(y, pr, rm) : y;
  };
  P.modulo = P.mod = function(y) {
    var q, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.s || y.d && !y.d[0])
      return new Ctor(NaN);
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }
    external = false;
    if (Ctor.modulo == 9) {
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }
    q = q.times(y);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return naturalExponential(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return naturalLogarithm(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };
  P.plus = P.add = function(y) {
    var carry, d, e2, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s)
        y = new Ctor(NaN);
      else if (!x.d)
        y = new Ctor(y.d || x.s === y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (!yd[0])
        y = new Ctor(x);
      return external ? finalise(y, pr, rm) : y;
    }
    k = mathfloor(x.e / LOG_BASE);
    e2 = mathfloor(y.e / LOG_BASE);
    xd = xd.slice();
    i = k - e2;
    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e2 = k;
        len = xd.length;
      }
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; )
        d.push(0);
      d.reverse();
    }
    len = xd.length;
    i = yd.length;
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }
    for (carry = 0; i; ) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }
    if (carry) {
      xd.unshift(carry);
      ++e2;
    }
    for (len = xd.length; xd[--len] == 0; )
      xd.pop();
    y.d = xd;
    y.e = getBase10Exponent(xd, e2);
    return external ? finalise(y, pr, rm) : y;
  };
  P.precision = P.sd = function(z) {
    var k, x = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
      throw Error(invalidArgument + z);
    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k)
        k = x.e + 1;
    } else {
      k = NaN;
    }
    return k;
  };
  P.round = function() {
    var x = this, Ctor = x.constructor;
    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };
  P.sine = P.sin = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = sine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, sd, r, rep, t, x = this, d = x.d, e2 = x.e, s = x.s, Ctor = x.constructor;
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);
      if ((n.length + e2) % 2 == 0)
        n += "0";
      s = Math.sqrt(n);
      e2 = mathfloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s == 1 / 0) {
        n = "5e" + e2;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e2;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e2 = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e2 + 1, 0);
            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e2 + 1, 1);
            m = !r.times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e2, Ctor.rounding, m);
  };
  P.tangent = P.tan = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;
    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };
  P.times = P.mul = function(y) {
    var carry, e2, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
    y.s *= x.s;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
    }
    e2 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--; )
      r.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k = xdL + i; k > i; ) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; )
      r.pop();
    if (carry)
      ++e2;
    else
      r.shift();
    y.d = r;
    y.e = getBase10Exponent(r, e2);
    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };
  P.toBinary = function(sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };
  P.toDecimalPlaces = P.toDP = function(dp, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp === void 0)
      return x;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    return finalise(x, dp + x.e + 1, rm);
  };
  P.toExponential = function(dp, rm) {
    var str, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFixed = function(dp, rm) {
    var str, y, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFraction = function(maxD) {
    var d, d0, d1, d2, e2, k, n, n0, n16, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
    if (!xd)
      return new Ctor(x);
    n16 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);
    d = new Ctor(d1);
    e2 = d.e = getPrecision(xd) - x.e - 1;
    k = e2 % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
    if (maxD == null) {
      maxD = e2 > 0 ? d : n16;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n16))
        throw Error(invalidArgument + n);
      maxD = n.gt(d) ? e2 > 0 ? d : n16 : n;
    }
    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e2 = xd.length * LOG_BASE * 2;
    for (; ; ) {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1)
        break;
      d0 = d1;
      d1 = d2;
      d2 = n16;
      n16 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }
    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n16));
    d0 = d0.plus(d2.times(d1));
    n0.s = n16.s = x.s;
    r = divide(n16, d1, e2, 1).minus(x).abs().cmp(divide(n0, d0, e2, 1).minus(x).abs()) < 1 ? [n16, d1] : [n0, d0];
    Ctor.precision = pr;
    external = true;
    return r;
  };
  P.toHexadecimal = P.toHex = function(sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };
  P.toNearest = function(y, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (y == null) {
      if (!x.d)
        return x;
      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }
      if (!x.d)
        return y.s ? x : y;
      if (!y.d) {
        if (y.s)
          y.s = x.s;
        return y;
      }
    }
    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);
    } else {
      y.s = x.s;
      x = y;
    }
    return x;
  };
  P.toNumber = function() {
    return +this;
  };
  P.toOctal = function(sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };
  P.toPower = P.pow = function(y) {
    var e2, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
    if (!x.d || !y.d || !x.d[0] || !y.d[0])
      return new Ctor(mathpow(+x, yn));
    x = new Ctor(x);
    if (x.eq(1))
      return x;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (y.eq(1))
      return finalise(x, pr, rm);
    e2 = mathfloor(y.e / LOG_BASE);
    if (e2 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }
    s = x.s;
    if (s < 0) {
      if (e2 < y.d.length - 1)
        return new Ctor(NaN);
      if ((y.d[e2] & 1) == 0)
        s = 1;
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }
    k = mathpow(+x, yn);
    e2 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
    if (e2 > Ctor.maxE + 1 || e2 < Ctor.minE - 1)
      return new Ctor(e2 > 0 ? s / 0 : 0);
    external = false;
    Ctor.rounding = x.s = 1;
    k = Math.min(12, (e2 + "").length);
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
    if (r.d) {
      r = finalise(r, pr + 5, 1);
      if (checkRoundingDigits(r.d, pr, rm)) {
        e2 = pr + 10;
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e2 + k)), e2), e2 + 5, 1);
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }
    r.s = s;
    external = true;
    Ctor.rounding = rm;
    return finalise(r, pr, rm);
  };
  P.toPrecision = function(sd, rm) {
    var str, x = this, Ctor = x.constructor;
    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toSignificantDigits = P.toSD = function(sd, rm) {
    var x = this, Ctor = x.constructor;
    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    }
    return finalise(new Ctor(x), sd, rm);
  };
  P.toString = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.truncated = P.trunc = function() {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };
  P.valueOf = P.toJSON = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() ? "-" + str : str;
  };
  function digitsToString(d) {
    var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
        str += ws;
      }
      w = d[i];
      ws = w + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; )
      w /= 10;
    return str + w;
  }
  function checkInt32(i, min2, max2) {
    if (i !== ~~i || i < min2 || i > max2) {
      throw Error(invalidArgument + i);
    }
  }
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;
    for (k = d[0]; k >= 10; k /= 10)
      --i;
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;
    if (repeating == null) {
      if (i < 3) {
        if (i == 0)
          rd = rd / 100 | 0;
        else if (i == 1)
          rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0)
          rd = rd / 1e3 | 0;
        else if (i == 1)
          rd = rd / 100 | 0;
        else if (i == 2)
          rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
      }
    }
    return r;
  }
  function convertBase(str, baseIn, baseOut) {
    var j, arr = [0], arrL, i = 0, strL = str.length;
    for (; i < strL; ) {
      for (arrL = arr.length; arrL--; )
        arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0)
            arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }
    return arr.reverse();
  }
  function cosine(Ctor, x) {
    var k, len, y;
    if (x.isZero())
      return x;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = "2.3283064365386962890625e-10";
    }
    Ctor.precision += k;
    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
    for (var i = k; i--; ) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }
    Ctor.precision -= k;
    return x;
  }
  var divide = function() {
    function multiplyInteger(x, k, base) {
      var temp, carry = 0, i = x.length;
      for (x = x.slice(); i--; ) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }
      if (carry)
        x.unshift(carry);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; )
        a.shift();
    }
    return function(x, y, pr, rm, dp, base) {
      var cmp, e2, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign3 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign3 * 0 : sign3 / 0
        );
      }
      if (base) {
        logBase = 1;
        e2 = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e2 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign3);
      qd = q.d = [];
      for (i = 0; yd[i] == (xd[i] || 0); i++)
        ;
      if (yd[i] > (xd[i] || 0))
        e2--;
      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }
      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {
        sd = sd / logBase + 2 | 0;
        i = 0;
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }
          more = k || i < xL;
        } else {
          k = base / (yd[0] + 1) | 0;
          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }
          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; )
            rem[remL++] = 0;
          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= base / 2)
            ++yd0;
          do {
            k = 0;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              k = rem0 / yd0 | 0;
              if (k > 1) {
                if (k >= base)
                  k = base - 1;
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;
                cmp = compare(prod, rem, prodL, remL);
                if (cmp == 1) {
                  k--;
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {
                if (k == 0)
                  cmp = k = 1;
                prod = yd.slice();
              }
              prodL = prod.length;
              if (prodL < remL)
                prod.unshift(0);
              subtract(rem, prod, remL, base);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 1) {
                  k++;
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }
            qd[i++] = k;
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          more = rem[0] !== void 0;
        }
        if (!qd[0])
          qd.shift();
      }
      if (logBase == 1) {
        q.e = e2;
        inexact = more;
      } else {
        for (i = 1, k = qd[0]; k >= 10; k /= 10)
          i++;
        q.e = i + e2 * logBase - 1;
        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }
      return q;
    };
  }();
  function finalise(x, sd, rm, isTruncated) {
    var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
    out:
      if (sd != null) {
        xd = x.d;
        if (!xd)
          return x;
        for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
          digits2++;
        i = sd - digits2;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];
          rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {
              for (; k++ <= xdi; )
                xd.push(0);
              w = rd = 0;
              digits2 = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];
            for (digits2 = 1; k >= 10; k /= 10)
              digits2++;
            i %= LOG_BASE;
            j = i - LOG_BASE + digits2;
            rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
          }
        }
        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {
            sd -= x.e + 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {
            xd[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);
          xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
        }
        if (roundUp) {
          for (; ; ) {
            if (xdi == 0) {
              for (i = 1, j = xd[0]; j >= 10; j /= 10)
                i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10)
                k++;
              if (i != k) {
                x.e++;
                if (xd[0] == BASE)
                  xd[0] = 1;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE)
                break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i = xd.length; xd[--i] === 0; )
          xd.pop();
      }
    if (external) {
      if (x.e > Ctor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < Ctor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
    return x;
  }
  function finiteToString(x, isExp, sd) {
    if (!x.isFinite())
      return nonFiniteToString(x);
    var k, e2 = x.e, str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (x.e < 0 ? "e" : "e+") + x.e;
    } else if (e2 < 0) {
      str = "0." + getZeroString(-e2 - 1) + str;
      if (sd && (k = sd - len) > 0)
        str += getZeroString(k);
    } else if (e2 >= len) {
      str += getZeroString(e2 + 1 - len);
      if (sd && (k = sd - e2 - 1) > 0)
        str = str + "." + getZeroString(k);
    } else {
      if ((k = e2 + 1) < len)
        str = str.slice(0, k) + "." + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e2 + 1 === len)
          str += ".";
        str += getZeroString(k);
      }
    }
    return str;
  }
  function getBase10Exponent(digits2, e2) {
    var w = digits2[0];
    for (e2 *= LOG_BASE; w >= 10; w /= 10)
      e2++;
    return e2;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      external = true;
      if (pr)
        Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }
  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION)
      throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }
  function getPrecision(digits2) {
    var w = digits2.length - 1, len = w * LOG_BASE + 1;
    w = digits2[w];
    if (w) {
      for (; w % 10 == 0; w /= 10)
        len--;
      for (w = digits2[0]; w >= 10; w /= 10)
        len++;
    }
    return len;
  }
  function getZeroString(k) {
    var zs = "";
    for (; k--; )
      zs += "0";
    return zs;
  }
  function intPow(Ctor, x, n, pr) {
    var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k))
          isTruncated = true;
      }
      n = mathfloor(n / 2);
      if (n === 0) {
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0)
          ++r.d[n];
        break;
      }
      x = x.times(x);
      truncate(x.d, k);
    }
    external = true;
    return r;
  }
  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }
  function maxOrMin(Ctor, args, ltgt) {
    var y, x = new Ctor(args[0]), i = 0;
    for (; ++i < args.length; ) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }
    return x;
  }
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (!x.d || !x.d[0] || x.e > 17) {
      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t = new Ctor(0.03125);
    while (x.e > -2) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow2 = sum2 = new Ctor(1);
    Ctor.precision = wpr;
    for (; ; ) {
      pow2 = finalise(pow2.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum2.plus(divide(pow2, denominator, wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        j = k;
        while (j--)
          sum2 = finalise(sum2.times(sum2), wpr, 1);
        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow2 = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
    }
  }
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e2, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    if (Math.abs(e2 = x.e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }
      e2 = x.e;
      if (c0 > 1) {
        x = new Ctor("0." + c);
        e2++;
      } else {
        x = new Ctor(c0 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr).times(e2 + "");
      x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }
    x1 = x;
    sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;
    for (; ; ) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        sum2 = sum2.times(2);
        if (e2 !== 0)
          sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e2 + ""));
        sum2 = divide(sum2, new Ctor(n), wpr, 1);
        if (sd == null) {
          if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
      denominator += 2;
    }
  }
  function nonFiniteToString(x) {
    return String(x.s * x.s / 0);
  }
  function parseDecimal(x, str) {
    var e2, i, len;
    if ((e2 = str.indexOf(".")) > -1)
      str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e2 < 0)
        e2 = i;
      e2 += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e2 < 0) {
      e2 = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
      ;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      x.e = e2 = e2 - i - 1;
      x.d = [];
      i = (e2 + 1) % LOG_BASE;
      if (e2 < 0)
        i += LOG_BASE;
      if (i < len) {
        if (i)
          x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; )
          x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; )
        str += "0";
      x.d.push(+str);
      if (external) {
        if (x.e > x.constructor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < x.constructor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
    } else {
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
    if (str.indexOf("_") > -1) {
      str = str.replace(/(\d)_(?=\d)/g, "$1");
      if (isDecimal.test(str))
        return parseDecimal(x, str);
    } else if (str === "Infinity" || str === "NaN") {
      if (!+str)
        x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }
    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }
    i = str.search(/p/i);
    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }
    i = str.indexOf(".");
    isFloat = i >= 0;
    Ctor = x.constructor;
    if (isFloat) {
      str = str.replace(".", "");
      len = str.length;
      i = len - i;
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }
    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;
    for (i = xe; xd[i] === 0; --i)
      xd.pop();
    if (i < 0)
      return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;
    if (isFloat)
      x = divide(x, divisor, len * 4);
    if (p)
      x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;
    return x;
  }
  function sine(Ctor, x) {
    var k, len = x.d.length;
    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);
    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }
    return x;
  }
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
    external = false;
    x2 = x.times(x);
    u = new Ctor(y);
    for (; ; ) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);
      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--; )
          ;
        if (j == -1)
          break;
      }
      j = u;
      u = y;
      y = t;
      t = j;
      i++;
    }
    external = true;
    t.d.length = k + 1;
    return t;
  }
  function tinyPow(b, e2) {
    var n = b;
    while (--e2)
      n *= b;
    return n;
  }
  function toLessThanHalfPi(Ctor, x) {
    var t, isNeg = x.s < 0, pi2 = getPi(Ctor, Ctor.precision, 1), halfPi = pi2.times(0.5);
    x = x.abs();
    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }
    t = x.divToInt(pi2);
    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi2));
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x;
      }
      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }
    return x.minus(pi2).abs();
  }
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e2, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }
    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf(".");
      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }
      if (i >= 0) {
        str = str.replace(".", "");
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }
      xd = convertBase(str, 10, base);
      e2 = len = xd.length;
      for (; xd[--len] == 0; )
        xd.pop();
      if (!xd[0]) {
        str = isExp ? "0p+0" : "0";
      } else {
        if (i < 0) {
          e2--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e2;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e2 = x.e;
          roundUp = inexact;
        }
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
        xd.length = sd;
        if (roundUp) {
          for (; ++xd[--sd] > base - 1; ) {
            xd[sd] = 0;
            if (!sd) {
              ++e2;
              xd.unshift(1);
            }
          }
        }
        for (len = xd.length; !xd[len - 1]; --len)
          ;
        for (i = 0, str = ""; i < len; i++)
          str += NUMERALS.charAt(xd[i]);
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++)
                str += "0";
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len)
                ;
              for (i = 1, str = "1."; i < len; i++)
                str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + "." + str.slice(1);
            }
          }
          str = str + (e2 < 0 ? "p" : "p+") + e2;
        } else if (e2 < 0) {
          for (; ++e2; )
            str = "0" + str;
          str = "0." + str;
        } else {
          if (++e2 > len)
            for (e2 -= len; e2--; )
              str += "0";
          else if (e2 < len)
            str = str.slice(0, e2) + "." + str.slice(e2);
        }
      }
      str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function abs(x) {
    return new this(x).abs();
  }
  function acos(x) {
    return new this(x).acos();
  }
  function acosh2(x) {
    return new this(x).acosh();
  }
  function add(x, y) {
    return new this(x).plus(y);
  }
  function asin(x) {
    return new this(x).asin();
  }
  function asinh2(x) {
    return new this(x).asinh();
  }
  function atan(x) {
    return new this(x).atan();
  }
  function atanh2(x) {
    return new this(x).atanh();
  }
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
    if (!y.s || !x.s) {
      r = new this(NaN);
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }
    return r;
  }
  function cbrt3(x) {
    return new this(x).cbrt();
  }
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }
  function clamp(x, min2, max2) {
    return new this(x).clamp(min2, max2);
  }
  function config(obj) {
    if (!obj || typeof obj !== "object")
      throw Error(decimalError + "Object expected");
    var i, p, v, useDefaults = obj.defaults === true, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -EXP_LIMIT,
      0,
      "toExpPos",
      0,
      EXP_LIMIT,
      "maxE",
      0,
      EXP_LIMIT,
      "minE",
      -EXP_LIMIT,
      0,
      "modulo",
      0,
      9
    ];
    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
          this[p] = v;
        else
          throw Error(invalidArgument + p + ": " + v);
      }
    }
    if (p = "crypto", useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ": " + v);
      }
    }
    return this;
  }
  function cos(x) {
    return new this(x).cos();
  }
  function cosh2(x) {
    return new this(x).cosh();
  }
  function clone2(obj) {
    var i, p, ps;
    function Decimal2(v) {
      var e2, i2, t, x = this;
      if (!(x instanceof Decimal2))
        return new Decimal2(v);
      x.constructor = Decimal2;
      if (isDecimalInstance(v)) {
        x.s = v.s;
        if (external) {
          if (!v.d || v.e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }
        return;
      }
      t = typeof v;
      if (t === "number") {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        if (v === ~~v && v < 1e7) {
          for (e2 = 0, i2 = v; i2 >= 10; i2 /= 10)
            e2++;
          if (external) {
            if (e2 > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e2 < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e2;
              x.d = [v];
            }
          } else {
            x.e = e2;
            x.d = [v];
          }
          return;
        } else if (v * 0 !== 0) {
          if (!v)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }
        return parseDecimal(x, v.toString());
      } else if (t !== "string") {
        throw Error(invalidArgument + v);
      }
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.EUCLID = 9;
    Decimal2.config = Decimal2.set = config;
    Decimal2.clone = clone2;
    Decimal2.isDecimal = isDecimalInstance;
    Decimal2.abs = abs;
    Decimal2.acos = acos;
    Decimal2.acosh = acosh2;
    Decimal2.add = add;
    Decimal2.asin = asin;
    Decimal2.asinh = asinh2;
    Decimal2.atan = atan;
    Decimal2.atanh = atanh2;
    Decimal2.atan2 = atan2;
    Decimal2.cbrt = cbrt3;
    Decimal2.ceil = ceil;
    Decimal2.clamp = clamp;
    Decimal2.cos = cos;
    Decimal2.cosh = cosh2;
    Decimal2.div = div;
    Decimal2.exp = exp;
    Decimal2.floor = floor;
    Decimal2.hypot = hypot;
    Decimal2.ln = ln;
    Decimal2.log = log;
    Decimal2.log10 = log103;
    Decimal2.log2 = log23;
    Decimal2.max = max;
    Decimal2.min = min;
    Decimal2.mod = mod;
    Decimal2.mul = mul;
    Decimal2.pow = pow;
    Decimal2.random = random;
    Decimal2.round = round;
    Decimal2.sign = sign2;
    Decimal2.sin = sin;
    Decimal2.sinh = sinh2;
    Decimal2.sqrt = sqrt;
    Decimal2.sub = sub;
    Decimal2.sum = sum;
    Decimal2.tan = tan;
    Decimal2.tanh = tanh2;
    Decimal2.trunc = trunc;
    if (obj === void 0)
      obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
        for (i = 0; i < ps.length; )
          if (!obj.hasOwnProperty(p = ps[i++]))
            obj[p] = this[p];
      }
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function div(x, y) {
    return new this(x).div(y);
  }
  function exp(x) {
    return new this(x).exp();
  }
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }
  function hypot() {
    var i, n, t = new this(0);
    external = false;
    for (i = 0; i < arguments.length; ) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }
    external = true;
    return t.sqrt();
  }
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  function ln(x) {
    return new this(x).ln();
  }
  function log(x, y) {
    return new this(x).log(y);
  }
  function log23(x) {
    return new this(x).log(2);
  }
  function log103(x) {
    return new this(x).log(10);
  }
  function max() {
    return maxOrMin(this, arguments, "lt");
  }
  function min() {
    return maxOrMin(this, arguments, "gt");
  }
  function mod(x, y) {
    return new this(x).mod(y);
  }
  function mul(x, y) {
    return new this(x).mul(y);
  }
  function pow(x, y) {
    return new this(x).pow(y);
  }
  function random(sd) {
    var d, e2, k, n, i = 0, r = new this(1), rd = [];
    if (sd === void 0)
      sd = this.precision;
    else
      checkInt32(sd, 1, MAX_DIGITS);
    k = Math.ceil(sd / LOG_BASE);
    if (!this.crypto) {
      for (; i < k; )
        rd[i++] = Math.random() * 1e7 | 0;
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));
      for (; i < k; ) {
        n = d[i];
        if (n >= 429e7) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          rd[i++] = n % 1e7;
        }
      }
    } else if (crypto.randomBytes) {
      d = crypto.randomBytes(k *= 4);
      for (; i < k; ) {
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
        if (n >= 214e7) {
          crypto.randomBytes(4).copy(d, i);
        } else {
          rd.push(n % 1e7);
          i += 4;
        }
      }
      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }
    k = rd[--i];
    sd %= LOG_BASE;
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }
    for (; rd[i] === 0; i--)
      rd.pop();
    if (i < 0) {
      e2 = 0;
      rd = [0];
    } else {
      e2 = -1;
      for (; rd[0] === 0; e2 -= LOG_BASE)
        rd.shift();
      for (k = 1, n = rd[0]; n >= 10; n /= 10)
        k++;
      if (k < LOG_BASE)
        e2 -= LOG_BASE - k;
    }
    r.e = e2;
    r.d = rd;
    return r;
  }
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }
  function sign2(x) {
    x = new this(x);
    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
  }
  function sin(x) {
    return new this(x).sin();
  }
  function sinh2(x) {
    return new this(x).sinh();
  }
  function sqrt(x) {
    return new this(x).sqrt();
  }
  function sub(x, y) {
    return new this(x).sub(y);
  }
  function sum() {
    var i = 0, args = arguments, x = new this(args[i]);
    external = false;
    for (; x.s && ++i < args.length; )
      x = x.plus(args[i]);
    external = true;
    return finalise(x, this.precision, this.rounding);
  }
  function tan(x) {
    return new this(x).tan();
  }
  function tanh2(x) {
    return new this(x).tanh();
  }
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
  P[Symbol.toStringTag] = "Decimal";
  var Decimal = P.constructor = clone2(DEFAULTS);
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);
  var decimal_default = Decimal;

  // node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
  var name2 = "BigNumber";
  var dependencies3 = ["?on", "config"];
  var createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
    var {
      on,
      config: config2
    } = _ref;
    var BigNumber = decimal_default.clone({
      precision: config2.precision,
      modulo: decimal_default.EUCLID
    });
    BigNumber.prototype = Object.create(BigNumber.prototype);
    BigNumber.prototype.type = "BigNumber";
    BigNumber.prototype.isBigNumber = true;
    BigNumber.prototype.toJSON = function() {
      return {
        mathjs: "BigNumber",
        value: this.toString()
      };
    };
    BigNumber.fromJSON = function(json) {
      return new BigNumber(json.value);
    };
    if (on) {
      on("config", function(curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber.config({
            precision: curr.precision
          });
        }
      });
    }
    return BigNumber;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/complex/Complex.js
  var import_complex = __toESM(require_complex(), 1);
  var name3 = "Complex";
  var dependencies4 = [];
  var createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
    Object.defineProperty(import_complex.default, "name", {
      value: "Complex"
    });
    import_complex.default.prototype.constructor = import_complex.default;
    import_complex.default.prototype.type = "Complex";
    import_complex.default.prototype.isComplex = true;
    import_complex.default.prototype.toJSON = function() {
      return {
        mathjs: "Complex",
        re: this.re,
        im: this.im
      };
    };
    import_complex.default.prototype.toPolar = function() {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    import_complex.default.prototype.format = function(options) {
      var str = "";
      var im = this.im;
      var re = this.re;
      var strRe = format(this.re, options);
      var strIm = format(this.im, options);
      var precision = isNumber(options) ? options : options ? options.precision : null;
      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);
        if (Math.abs(re / im) < epsilon) {
          re = 0;
        }
        if (Math.abs(im / re) < epsilon) {
          im = 0;
        }
      }
      if (im === 0) {
        str = strRe;
      } else if (re === 0) {
        if (im === 1) {
          str = "i";
        } else if (im === -1) {
          str = "-i";
        } else {
          str = strIm + "i";
        }
      } else {
        if (im < 0) {
          if (im === -1) {
            str = strRe + " - i";
          } else {
            str = strRe + " - " + strIm.substring(1) + "i";
          }
        } else {
          if (im === 1) {
            str = strRe + " + i";
          } else {
            str = strRe + " + " + strIm + "i";
          }
        }
      }
      return str;
    };
    import_complex.default.fromPolar = function(args) {
      switch (arguments.length) {
        case 1: {
          var arg = arguments[0];
          if (typeof arg === "object") {
            return (0, import_complex.default)(arg);
          } else {
            throw new TypeError("Input has to be an object with r and phi keys.");
          }
        }
        case 2: {
          var r = arguments[0];
          var phi2 = arguments[1];
          if (isNumber(r)) {
            if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
              phi2 = phi2.toNumber("rad");
            }
            if (isNumber(phi2)) {
              return new import_complex.default({
                r,
                phi: phi2
              });
            }
            throw new TypeError("Phi is not a number nor an angle unit.");
          } else {
            throw new TypeError("Radius r is not a number.");
          }
        }
        default:
          throw new SyntaxError("Wrong number of arguments in function fromPolar");
      }
    };
    import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
    import_complex.default.fromJSON = function(json) {
      return new import_complex.default(json);
    };
    import_complex.default.compare = function(a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return import_complex.default;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/fraction/Fraction.js
  var import_fraction = __toESM(require_fraction(), 1);
  var name4 = "Fraction";
  var dependencies5 = [];
  var createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
    Object.defineProperty(import_fraction.default, "name", {
      value: "Fraction"
    });
    import_fraction.default.prototype.constructor = import_fraction.default;
    import_fraction.default.prototype.type = "Fraction";
    import_fraction.default.prototype.isFraction = true;
    import_fraction.default.prototype.toJSON = function() {
      return {
        mathjs: "Fraction",
        n: this.s * this.n,
        d: this.d
      };
    };
    import_fraction.default.fromJSON = function(json) {
      return new import_fraction.default(json);
    };
    return import_fraction.default;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Range.js
  var name5 = "Range";
  var dependencies6 = [];
  var createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      var hasStart = start !== null && start !== void 0;
      var hasEnd = end !== null && end !== void 0;
      var hasStep = step !== null && step !== void 0;
      if (hasStart) {
        if (isBigNumber(start)) {
          start = start.toNumber();
        } else if (typeof start !== "number") {
          throw new TypeError("Parameter start must be a number");
        }
      }
      if (hasEnd) {
        if (isBigNumber(end)) {
          end = end.toNumber();
        } else if (typeof end !== "number") {
          throw new TypeError("Parameter end must be a number");
        }
      }
      if (hasStep) {
        if (isBigNumber(step)) {
          step = step.toNumber();
        } else if (typeof step !== "number") {
          throw new TypeError("Parameter step must be a number");
        }
      }
      this.start = hasStart ? parseFloat(start) : 0;
      this.end = hasEnd ? parseFloat(end) : 0;
      this.step = hasStep ? parseFloat(step) : 1;
    }
    Range.prototype.type = "Range";
    Range.prototype.isRange = true;
    Range.parse = function(str) {
      if (typeof str !== "string") {
        return null;
      }
      var args = str.split(":");
      var nums = args.map(function(arg) {
        return parseFloat(arg);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return new Range(nums[0], nums[1]);
        case 3:
          return new Range(nums[0], nums[2], nums[1]);
        default:
          return null;
      }
    };
    Range.prototype.clone = function() {
      return new Range(this.start, this.end, this.step);
    };
    Range.prototype.size = function() {
      var len = 0;
      var start = this.start;
      var step = this.step;
      var end = this.end;
      var diff = end - start;
      if (sign(step) === sign(diff)) {
        len = Math.ceil(diff / step);
      } else if (diff === 0) {
        len = 0;
      }
      if (isNaN(len)) {
        len = 0;
      }
      return [len];
    };
    Range.prototype.min = function() {
      var size = this.size()[0];
      if (size > 0) {
        if (this.step > 0) {
          return this.start;
        } else {
          return this.start + (size - 1) * this.step;
        }
      } else {
        return void 0;
      }
    };
    Range.prototype.max = function() {
      var size = this.size()[0];
      if (size > 0) {
        if (this.step > 0) {
          return this.start + (size - 1) * this.step;
        } else {
          return this.start;
        }
      } else {
        return void 0;
      }
    };
    Range.prototype.forEach = function(callback) {
      var x = this.start;
      var step = this.step;
      var end = this.end;
      var i = 0;
      if (step > 0) {
        while (x < end) {
          callback(x, [i], this);
          x += step;
          i++;
        }
      } else if (step < 0) {
        while (x > end) {
          callback(x, [i], this);
          x += step;
          i++;
        }
      }
    };
    Range.prototype.map = function(callback) {
      var array = [];
      this.forEach(function(value, index, obj) {
        array[index[0]] = callback(value, index, obj);
      });
      return array;
    };
    Range.prototype.toArray = function() {
      var array = [];
      this.forEach(function(value, index) {
        array[index[0]] = value;
      });
      return array;
    };
    Range.prototype.valueOf = function() {
      return this.toArray();
    };
    Range.prototype.format = function(options) {
      var str = format(this.start, options);
      if (this.step !== 1) {
        str += ":" + format(this.step, options);
      }
      str += ":" + format(this.end, options);
      return str;
    };
    Range.prototype.toString = function() {
      return this.format();
    };
    Range.prototype.toJSON = function() {
      return {
        mathjs: "Range",
        start: this.start,
        end: this.end,
        step: this.step
      };
    };
    Range.fromJSON = function(json) {
      return new Range(json.start, json.end, json.step);
    };
    return Range;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Matrix.js
  var name6 = "Matrix";
  var dependencies7 = [];
  var createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
    function Matrix() {
      if (!(this instanceof Matrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
    }
    Matrix.prototype.type = "Matrix";
    Matrix.prototype.isMatrix = true;
    Matrix.prototype.storage = function() {
      throw new Error("Cannot invoke storage on a Matrix interface");
    };
    Matrix.prototype.datatype = function() {
      throw new Error("Cannot invoke datatype on a Matrix interface");
    };
    Matrix.prototype.create = function(data, datatype) {
      throw new Error("Cannot invoke create on a Matrix interface");
    };
    Matrix.prototype.subset = function(index, replacement, defaultValue) {
      throw new Error("Cannot invoke subset on a Matrix interface");
    };
    Matrix.prototype.get = function(index) {
      throw new Error("Cannot invoke get on a Matrix interface");
    };
    Matrix.prototype.set = function(index, value, defaultValue) {
      throw new Error("Cannot invoke set on a Matrix interface");
    };
    Matrix.prototype.resize = function(size, defaultValue) {
      throw new Error("Cannot invoke resize on a Matrix interface");
    };
    Matrix.prototype.reshape = function(size, defaultValue) {
      throw new Error("Cannot invoke reshape on a Matrix interface");
    };
    Matrix.prototype.clone = function() {
      throw new Error("Cannot invoke clone on a Matrix interface");
    };
    Matrix.prototype.size = function() {
      throw new Error("Cannot invoke size on a Matrix interface");
    };
    Matrix.prototype.map = function(callback, skipZeros) {
      throw new Error("Cannot invoke map on a Matrix interface");
    };
    Matrix.prototype.forEach = function(callback) {
      throw new Error("Cannot invoke forEach on a Matrix interface");
    };
    Matrix.prototype[Symbol.iterator] = function() {
      throw new Error("Cannot iterate a Matrix interface");
    };
    Matrix.prototype.toArray = function() {
      throw new Error("Cannot invoke toArray on a Matrix interface");
    };
    Matrix.prototype.valueOf = function() {
      throw new Error("Cannot invoke valueOf on a Matrix interface");
    };
    Matrix.prototype.format = function(options) {
      throw new Error("Cannot invoke format on a Matrix interface");
    };
    Matrix.prototype.toString = function() {
      throw new Error("Cannot invoke toString on a Matrix interface");
    };
    return Matrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/utils/lruQueue.js
  function lruQueue(limit) {
    var size = 0;
    var base = 1;
    var queue = /* @__PURE__ */ Object.create(null);
    var map2 = /* @__PURE__ */ Object.create(null);
    var index = 0;
    var del = function del2(id) {
      var oldIndex = map2[id];
      if (!oldIndex)
        return;
      delete queue[oldIndex];
      delete map2[id];
      --size;
      if (base !== oldIndex)
        return;
      if (!size) {
        index = 0;
        base = 1;
        return;
      }
      while (!hasOwnProperty.call(queue, ++base)) {
        continue;
      }
    };
    limit = Math.abs(limit);
    return {
      hit: function hit(id) {
        var oldIndex = map2[id];
        var nuIndex = ++index;
        queue[nuIndex] = id;
        map2[id] = nuIndex;
        if (!oldIndex) {
          ++size;
          if (size <= limit)
            return void 0;
          id = queue[base];
          del(id);
          return id;
        }
        delete queue[oldIndex];
        if (base !== oldIndex)
          return void 0;
        while (!hasOwnProperty.call(queue, ++base)) {
          continue;
        }
        return void 0;
      },
      delete: del,
      clear: function clear() {
        size = index = 0;
        base = 1;
        queue = /* @__PURE__ */ Object.create(null);
        map2 = /* @__PURE__ */ Object.create(null);
      }
    };
  }

  // node_modules/mathjs/lib/esm/utils/function.js
  function memoize(fn) {
    var {
      hasher: hasher2,
      limit
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    limit = limit == null ? Number.POSITIVE_INFINITY : limit;
    hasher2 = hasher2 == null ? JSON.stringify : hasher2;
    return function memoize2() {
      if (typeof memoize2.cache !== "object") {
        memoize2.cache = {
          values: /* @__PURE__ */ new Map(),
          lru: lruQueue(limit || Number.POSITIVE_INFINITY)
        };
      }
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      var hash = hasher2(args);
      if (memoize2.cache.values.has(hash)) {
        memoize2.cache.lru.hit(hash);
        return memoize2.cache.values.get(hash);
      }
      var newVal = fn.apply(fn, args);
      memoize2.cache.values.set(hash, newVal);
      memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
      return newVal;
    };
  }
  function maxArgumentCount(fn) {
    return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
      var count = (signature.match(/,/g) || []).length + 1;
      return Math.max(args, count);
    }, -1);
  }

  // node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
  var name7 = "DenseMatrix";
  var dependencies8 = ["Matrix"];
  var createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
    var {
      Matrix
    } = _ref;
    function DenseMatrix(data, datatype) {
      if (!(this instanceof DenseMatrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        if (data.type === "DenseMatrix") {
          this._data = clone(data._data);
          this._size = clone(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        this._data = preprocess(data);
        this._size = arraySize(this._data);
        validate(this._data, this._size);
        this._datatype = datatype;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }
    DenseMatrix.prototype = new Matrix();
    DenseMatrix.prototype.createDenseMatrix = function(data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    Object.defineProperty(DenseMatrix, "name", {
      value: "DenseMatrix"
    });
    DenseMatrix.prototype.constructor = DenseMatrix;
    DenseMatrix.prototype.type = "DenseMatrix";
    DenseMatrix.prototype.isDenseMatrix = true;
    DenseMatrix.prototype.getDataType = function() {
      return getArrayDataType(this._data, typeOf);
    };
    DenseMatrix.prototype.storage = function() {
      return "dense";
    };
    DenseMatrix.prototype.datatype = function() {
      return this._datatype;
    };
    DenseMatrix.prototype.create = function(data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    DenseMatrix.prototype.subset = function(index, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index);
        case 2:
        case 3:
          return _set(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    DenseMatrix.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      for (var x = 0; x < index.length; x++) {
        validateIndex(index[x], this._size[x]);
      }
      var data = this._data;
      for (var i = 0, ii = index.length; i < ii; i++) {
        var indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      return data;
    };
    DenseMatrix.prototype.set = function(index, value, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length < this._size.length) {
        throw new DimensionError(index.length, this._size.length, "<");
      }
      var i, ii, indexI;
      var size = index.map(function(i2) {
        return i2 + 1;
      });
      _fit(this, size, defaultValue);
      var data = this._data;
      for (i = 0, ii = index.length - 1; i < ii; i++) {
        indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      indexI = index[index.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    function _get(matrix, index) {
      if (!isIndex(index)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = index.isScalar();
      if (isScalar) {
        return matrix.get(index.min());
      } else {
        var size = index.size();
        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length);
        }
        var min2 = index.min();
        var max2 = index.max();
        for (var i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min2[i], matrix._size[i]);
          validateIndex(max2[i], matrix._size[i]);
        }
        return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
      }
    }
    function _getSubmatrix(data, index, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        return range.map(function(i) {
          validateIndex(i, data.length);
          return data[i];
        }).valueOf();
      } else {
        return range.map(function(i) {
          validateIndex(i, data.length);
          var child = data[i];
          return _getSubmatrix(child, index, dims, dim + 1);
        }).valueOf();
      }
    }
    function _set(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length < matrix._size.length) {
          throw new DimensionError(iSize.length, matrix._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        var size = index.max().map(function(i2) {
          return i2 + 1;
        });
        _fit(matrix, size, defaultValue);
        var dims = iSize.length;
        var dim = 0;
        _setSubmatrix(matrix._data, index, submatrix, dims, dim);
      }
      return matrix;
    }
    function _setSubmatrix(data, index, submatrix, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    DenseMatrix.prototype.resize = function(size, defaultValue, copy) {
      if (!isCollection(size)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray, defaultValue);
    };
    function _resize2(matrix, size, defaultValue) {
      if (size.length === 0) {
        var v = matrix._data;
        while (isArray(v)) {
          v = v[0];
        }
        return v;
      }
      matrix._size = size.slice(0);
      matrix._data = resize(matrix._data, matrix._size, defaultValue);
      return matrix;
    }
    DenseMatrix.prototype.reshape = function(size, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size);
      var currentLength = m._size.reduce((length, size2) => length * size2);
      m._size = processSizesWildcard(size, currentLength);
      return m;
    };
    function _fit(matrix, size, defaultValue) {
      var newSize = matrix._size.slice(0);
      var changed = false;
      while (newSize.length < size.length) {
        newSize.push(0);
        changed = true;
      }
      for (var i = 0, ii = size.length; i < ii; i++) {
        if (size[i] > newSize[i]) {
          newSize[i] = size[i];
          changed = true;
        }
      }
      if (changed) {
        _resize2(matrix, newSize, defaultValue);
      }
    }
    DenseMatrix.prototype.clone = function() {
      var m = new DenseMatrix({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    DenseMatrix.prototype.size = function() {
      return this._size.slice(0);
    };
    DenseMatrix.prototype.map = function(callback) {
      var me = this;
      var args = maxArgumentCount(callback);
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          return value.map(function(child, i) {
            return recurse2(child, index.concat(i));
          });
        } else {
          if (args === 1) {
            return callback(value);
          } else if (args === 2) {
            return callback(value, index);
          } else {
            return callback(value, index, me);
          }
        }
      };
      var data = recurse(this._data, []);
      var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
      return new DenseMatrix(data, datatype);
    };
    DenseMatrix.prototype.forEach = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          value.forEach(function(child, i) {
            recurse2(child, index.concat(i));
          });
        } else {
          callback(value, index, me);
        }
      };
      recurse(this._data, []);
    };
    DenseMatrix.prototype[Symbol.iterator] = function* () {
      var recurse = function* recurse2(value, index) {
        if (isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            yield* recurse2(value[i], index.concat(i));
          }
        } else {
          yield {
            value,
            index
          };
        }
      };
      yield* recurse(this._data, []);
    };
    DenseMatrix.prototype.rows = function() {
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      for (var row of data) {
        result.push(new DenseMatrix([row], this._datatype));
      }
      return result;
    };
    DenseMatrix.prototype.columns = function() {
      var _this = this;
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      var _loop = function _loop2(i2) {
        var col = data.map((row) => [row[i2]]);
        result.push(new DenseMatrix(col, _this._datatype));
      };
      for (var i = 0; i < s[1]; i++) {
        _loop(i);
      }
      return result;
    };
    DenseMatrix.prototype.toArray = function() {
      return clone(this._data);
    };
    DenseMatrix.prototype.valueOf = function() {
      return this._data;
    };
    DenseMatrix.prototype.format = function(options) {
      return format3(this._data, options);
    };
    DenseMatrix.prototype.toString = function() {
      return format3(this._data);
    };
    DenseMatrix.prototype.toJSON = function() {
      return {
        mathjs: "DenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    DenseMatrix.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var data = [];
      for (var i = 0; i < n; i++) {
        data[i] = this._data[i + kSub][i + kSuper];
      }
      return new DenseMatrix({
        data,
        size: [n],
        datatype: this._datatype
      });
    };
    DenseMatrix.diagonal = function(size, value, k, defaultValue) {
      if (!isArray(size)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size = size.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size[0];
      var columns = size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i) {
          return value[i];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i) {
          return value.get([i]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      if (!defaultValue) {
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
      }
      var data = [];
      if (size.length > 0) {
        data = resize(data, size, defaultValue);
        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      }
      return new DenseMatrix({
        data,
        size: [rows, columns]
      });
    };
    DenseMatrix.fromJSON = function(json) {
      return new DenseMatrix(json);
    };
    DenseMatrix.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      DenseMatrix._swapRows(i, j, this._data);
      return this;
    };
    DenseMatrix._swapRows = function(i, j, data) {
      var vi = data[i];
      data[i] = data[j];
      data[j] = vi;
    };
    function preprocess(data) {
      for (var i = 0, ii = data.length; i < ii; i++) {
        var elem = data[i];
        if (isArray(elem)) {
          data[i] = preprocess(elem);
        } else if (elem && elem.isMatrix === true) {
          data[i] = preprocess(elem.valueOf());
        }
      }
      return data;
    }
    return DenseMatrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/function/utils/clone.js
  var name8 = "clone";
  var dependencies9 = ["typed"];
  var createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name8, {
      any: clone
    });
  });

  // node_modules/mathjs/lib/esm/utils/switch.js
  function _switch(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];
    for (j = 0; j < J; j++) {
      var tmp = [];
      for (i = 0; i < I; i++) {
        tmp.push(mat[i][j]);
      }
      ret.push(tmp);
    }
    return ret;
  }

  // node_modules/mathjs/lib/esm/utils/collection.js
  function containsCollections(array) {
    for (var i = 0; i < array.length; i++) {
      if (isCollection(array[i])) {
        return true;
      }
    }
    return false;
  }
  function deepForEach(array, callback) {
    if (isMatrix(array)) {
      array = array.valueOf();
    }
    for (var i = 0, ii = array.length; i < ii; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        deepForEach(value, callback);
      } else {
        callback(value);
      }
    }
  }
  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === "function") {
      return array.map(function(x) {
        return deepMap(x, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }
  function reduce(mat, dim, callback) {
    var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
    if (dim < 0 || dim >= size.length) {
      throw new IndexError(dim, size.length);
    }
    if (isMatrix(mat)) {
      return mat.create(_reduce(mat.valueOf(), dim, callback));
    } else {
      return _reduce(mat, dim, callback);
    }
  }
  function _reduce(mat, dim, callback) {
    var i, ret, val, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        val = mat[0];
        for (i = 1; i < mat.length; i++) {
          val = callback(val, mat[i]);
        }
        return val;
      } else {
        tran = _switch(mat);
        ret = [];
        for (i = 0; i < tran.length; i++) {
          ret[i] = _reduce(tran[i], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i = 0; i < mat.length; i++) {
        ret[i] = _reduce(mat[i], dim - 1, callback);
      }
      return ret;
    }
  }
  function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var k, k0, k1, i;
    if (x) {
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i = aindex[k];
        if (w[i] !== mark) {
          w[i] = mark;
          cindex.push(i);
          if (update) {
            x[i] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
            u[i] = mark;
          } else {
            x[i] = avalues[k];
          }
        } else {
          x[i] = inverse ? f(avalues[k], x[i]) : f(x[i], avalues[k]);
          u[i] = mark;
        }
      }
    } else {
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i = aindex[k];
        if (w[i] !== mark) {
          w[i] = mark;
          cindex.push(i);
        } else {
          u[i] = mark;
        }
      }
    }
  }

  // node_modules/mathjs/lib/esm/function/utils/isInteger.js
  var name9 = "isInteger";
  var dependencies10 = ["typed"];
  var createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name9, {
      number: isInteger,
      BigNumber: function BigNumber(x) {
        return x.isInt();
      },
      Fraction: function Fraction2(x) {
        return x.d === 1 && isFinite(x.n);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/plain/number/arithmetic.js
  var n1 = "number";
  var n2 = "number, number";
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function subtractNumber(a, b) {
    return a - b;
  }
  subtractNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function divideNumber(a, b) {
    return a / b;
  }
  divideNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1;
  function unaryPlusNumber(x) {
    return x;
  }
  unaryPlusNumber.signature = n1;
  function cbrtNumber(x) {
    return cbrt(x);
  }
  cbrtNumber.signature = n1;
  function cubeNumber(x) {
    return x * x * x;
  }
  cubeNumber.signature = n1;
  function expNumber(x) {
    return Math.exp(x);
  }
  expNumber.signature = n1;
  function expm1Number(x) {
    return expm1(x);
  }
  expm1Number.signature = n1;
  function gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = a % b;
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  gcdNumber.signature = n2;
  function lcmNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a === 0 || b === 0) {
      return 0;
    }
    var t;
    var prod = a * b;
    while (b !== 0) {
      t = b;
      b = a % t;
      a = t;
    }
    return Math.abs(prod / a);
  }
  lcmNumber.signature = n2;
  function logNumber(x, y) {
    if (y) {
      return Math.log(x) / Math.log(y);
    }
    return Math.log(x);
  }
  function log10Number(x) {
    return log10(x);
  }
  log10Number.signature = n1;
  function log2Number(x) {
    return log2(x);
  }
  log2Number.signature = n1;
  function log1pNumber(x) {
    return log1p(x);
  }
  log1pNumber.signature = n1;
  function modNumber(x, y) {
    if (y > 0) {
      return x - y * Math.floor(x / y);
    } else if (y === 0) {
      return x;
    } else {
      throw new Error("Cannot calculate mod for a negative divisor");
    }
  }
  modNumber.signature = n2;
  function nthRootNumber(a) {
    var root2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    var inv = root2 < 0;
    if (inv) {
      root2 = -root2;
    }
    if (root2 === 0) {
      throw new Error("Root must be non-zero");
    }
    if (a < 0 && Math.abs(root2) % 2 !== 1) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a === 0) {
      return inv ? Infinity : 0;
    }
    if (!isFinite(a)) {
      return inv ? 0 : a;
    }
    var x = Math.pow(Math.abs(a), 1 / root2);
    x = a < 0 ? -x : x;
    return inv ? 1 / x : x;
  }
  function signNumber(x) {
    return sign(x);
  }
  signNumber.signature = n1;
  function sqrtNumber(x) {
    return Math.sqrt(x);
  }
  sqrtNumber.signature = n1;
  function squareNumber(x) {
    return x * x;
  }
  squareNumber.signature = n1;
  function xgcdNumber(a, b) {
    var t;
    var q;
    var r;
    var x = 0;
    var lastx = 1;
    var y = 1;
    var lasty = 0;
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (b) {
      q = Math.floor(a / b);
      r = a - q * b;
      t = x;
      x = lastx - q * x;
      lastx = t;
      t = y;
      y = lasty - q * y;
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    } else {
      res = [a, a ? lastx : 0, lasty];
    }
    return res;
  }
  xgcdNumber.signature = n2;
  function powNumber(x, y) {
    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
      return 0;
    }
    return Math.pow(x, y);
  }
  powNumber.signature = n2;
  function roundNumber(value) {
    var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
      throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
    }
    return parseFloat(toFixed(value, decimals));
  }
  function normNumber(x) {
    return Math.abs(x);
  }
  normNumber.signature = n1;

  // node_modules/mathjs/lib/esm/plain/number/bitwise.js
  var n12 = "number";
  var n22 = "number, number";
  function bitAndNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function bitAnd");
    }
    return x & y;
  }
  bitAndNumber.signature = n22;
  function bitNotNumber(x) {
    if (!isInteger(x)) {
      throw new Error("Integer expected in function bitNot");
    }
    return ~x;
  }
  bitNotNumber.signature = n12;
  function bitOrNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function bitOr");
    }
    return x | y;
  }
  bitOrNumber.signature = n22;
  function bitXorNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function bitXor");
    }
    return x ^ y;
  }
  bitXorNumber.signature = n22;
  function leftShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function leftShift");
    }
    return x << y;
  }
  leftShiftNumber.signature = n22;
  function rightArithShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function rightArithShift");
    }
    return x >> y;
  }
  rightArithShiftNumber.signature = n22;
  function rightLogShiftNumber(x, y) {
    if (!isInteger(x) || !isInteger(y)) {
      throw new Error("Integers expected in function rightLogShift");
    }
    return x >>> y;
  }
  rightLogShiftNumber.signature = n22;

  // node_modules/mathjs/lib/esm/utils/product.js
  function product2(i, n) {
    if (n < i) {
      return 1;
    }
    if (n === i) {
      return n;
    }
    var half = n + i >> 1;
    return product2(i, half) * product2(half + 1, n);
  }

  // node_modules/mathjs/lib/esm/plain/number/combinations.js
  function combinationsNumber(n, k) {
    if (!isInteger(n) || n < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (!isInteger(k) || k < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (k > n) {
      throw new TypeError("k must be less than or equal to n");
    }
    var nMinusk = n - k;
    var answer = 1;
    var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
    var nextdivisor = 2;
    var lastdivisor = k < nMinusk ? k : nMinusk;
    for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
      answer *= nextnumerator;
      while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
        answer /= nextdivisor;
        ++nextdivisor;
      }
    }
    if (nextdivisor <= lastdivisor) {
      answer /= product2(nextdivisor, lastdivisor);
    }
    return answer;
  }
  combinationsNumber.signature = "number, number";

  // node_modules/mathjs/lib/esm/plain/number/constants.js
  var pi = Math.PI;
  var tau = 2 * Math.PI;
  var e = Math.E;
  var phi = 1.618033988749895;

  // node_modules/mathjs/lib/esm/plain/number/logical.js
  var n13 = "number";
  var n23 = "number, number";
  function notNumber(x) {
    return !x;
  }
  notNumber.signature = n13;
  function orNumber(x, y) {
    return !!(x || y);
  }
  orNumber.signature = n23;
  function xorNumber(x, y) {
    return !!x !== !!y;
  }
  xorNumber.signature = n23;
  function andNumber(x, y) {
    return !!(x && y);
  }
  andNumber.signature = n23;

  // node_modules/mathjs/lib/esm/plain/number/probability.js
  function gammaNumber(n) {
    var x;
    if (isInteger(n)) {
      if (n <= 0) {
        return isFinite(n) ? Infinity : NaN;
      }
      if (n > 171) {
        return Infinity;
      }
      return product2(1, n - 1);
    }
    if (n < 0.5) {
      return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
    }
    if (n >= 171.35) {
      return Infinity;
    }
    if (n > 85) {
      var twoN = n * n;
      var threeN = twoN * n;
      var fourN = threeN * n;
      var fiveN = fourN * n;
      return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
    }
    --n;
    x = gammaP[0];
    for (var i = 1; i < gammaP.length; ++i) {
      x += gammaP[i] / (n + i);
    }
    var t = n + gammaG + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
  }
  gammaNumber.signature = "number";
  var gammaG = 4.7421875;
  var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
  var lnSqrt2PI = 0.9189385332046728;
  var lgammaG = 5;
  var lgammaN = 7;
  var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
  function lgammaNumber(n) {
    if (n < 0)
      return NaN;
    if (n === 0)
      return Infinity;
    if (!isFinite(n))
      return n;
    if (n < 0.5) {
      return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
    }
    n = n - 1;
    var base = n + lgammaG + 0.5;
    var sum2 = lgammaSeries[0];
    for (var i = lgammaN - 1; i >= 1; i--) {
      sum2 += lgammaSeries[i] / (n + i);
    }
    return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum2);
  }
  lgammaNumber.signature = "number";

  // node_modules/mathjs/lib/esm/plain/number/trigonometry.js
  var n14 = "number";
  var n24 = "number, number";
  function acosNumber(x) {
    return Math.acos(x);
  }
  acosNumber.signature = n14;
  function acoshNumber(x) {
    return acosh(x);
  }
  acoshNumber.signature = n14;
  function acotNumber(x) {
    return Math.atan(1 / x);
  }
  acotNumber.signature = n14;
  function acothNumber(x) {
    return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
  }
  acothNumber.signature = n14;
  function acscNumber(x) {
    return Math.asin(1 / x);
  }
  acscNumber.signature = n14;
  function acschNumber(x) {
    var xInv = 1 / x;
    return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
  }
  acschNumber.signature = n14;
  function asecNumber(x) {
    return Math.acos(1 / x);
  }
  asecNumber.signature = n14;
  function asechNumber(x) {
    var xInv = 1 / x;
    var ret = Math.sqrt(xInv * xInv - 1);
    return Math.log(ret + xInv);
  }
  asechNumber.signature = n14;
  function asinNumber(x) {
    return Math.asin(x);
  }
  asinNumber.signature = n14;
  function asinhNumber(x) {
    return asinh(x);
  }
  asinhNumber.signature = n14;
  function atanNumber(x) {
    return Math.atan(x);
  }
  atanNumber.signature = n14;
  function atan2Number(y, x) {
    return Math.atan2(y, x);
  }
  atan2Number.signature = n24;
  function atanhNumber(x) {
    return atanh(x);
  }
  atanhNumber.signature = n14;
  function cosNumber(x) {
    return Math.cos(x);
  }
  cosNumber.signature = n14;
  function coshNumber(x) {
    return cosh(x);
  }
  coshNumber.signature = n14;
  function cotNumber(x) {
    return 1 / Math.tan(x);
  }
  cotNumber.signature = n14;
  function cothNumber(x) {
    var e2 = Math.exp(2 * x);
    return (e2 + 1) / (e2 - 1);
  }
  cothNumber.signature = n14;
  function cscNumber(x) {
    return 1 / Math.sin(x);
  }
  cscNumber.signature = n14;
  function cschNumber(x) {
    if (x === 0) {
      return Number.POSITIVE_INFINITY;
    } else {
      return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
    }
  }
  cschNumber.signature = n14;
  function secNumber(x) {
    return 1 / Math.cos(x);
  }
  secNumber.signature = n14;
  function sechNumber(x) {
    return 2 / (Math.exp(x) + Math.exp(-x));
  }
  sechNumber.signature = n14;
  function sinNumber(x) {
    return Math.sin(x);
  }
  sinNumber.signature = n14;
  function sinhNumber(x) {
    return sinh(x);
  }
  sinhNumber.signature = n14;
  function tanNumber(x) {
    return Math.tan(x);
  }
  tanNumber.signature = n14;
  function tanhNumber(x) {
    return tanh(x);
  }
  tanhNumber.signature = n14;

  // node_modules/mathjs/lib/esm/plain/number/utils.js
  var n15 = "number";
  function isIntegerNumber(x) {
    return isInteger(x);
  }
  isIntegerNumber.signature = n15;
  function isNegativeNumber(x) {
    return x < 0;
  }
  isNegativeNumber.signature = n15;
  function isPositiveNumber(x) {
    return x > 0;
  }
  isPositiveNumber.signature = n15;
  function isZeroNumber(x) {
    return x === 0;
  }
  isZeroNumber.signature = n15;
  function isNaNNumber(x) {
    return Number.isNaN(x);
  }
  isNaNNumber.signature = n15;

  // node_modules/mathjs/lib/esm/function/utils/isNegative.js
  var name10 = "isNegative";
  var dependencies11 = ["typed"];
  var createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name10, {
      number: isNegativeNumber,
      BigNumber: function BigNumber(x) {
        return x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction2(x) {
        return x.s < 0;
      },
      Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isNumeric.js
  var name11 = "isNumeric";
  var dependencies12 = ["typed"];
  var createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name11, {
      "number | BigNumber | Fraction | boolean": () => true,
      "Complex | Unit | string | null | undefined | Node": () => false,
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
  var name12 = "hasNumericValue";
  var dependencies13 = ["typed", "isNumeric"];
  var createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
    var {
      typed,
      isNumeric
    } = _ref;
    return typed(name12, {
      boolean: () => true,
      string: function string(x) {
        return x.trim().length > 0 && !isNaN(Number(x));
      },
      any: function any(x) {
        return isNumeric(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isPositive.js
  var name13 = "isPositive";
  var dependencies14 = ["typed"];
  var createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name13, {
      number: isPositiveNumber,
      BigNumber: function BigNumber(x) {
        return !x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction2(x) {
        return x.s > 0 && x.n > 0;
      },
      Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isZero.js
  var name14 = "isZero";
  var dependencies15 = ["typed"];
  var createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name14, {
      number: isZeroNumber,
      BigNumber: function BigNumber(x) {
        return x.isZero();
      },
      Complex: function Complex2(x) {
        return x.re === 0 && x.im === 0;
      },
      Fraction: function Fraction2(x) {
        return x.d === 1 && x.n === 0;
      },
      Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isNaN.js
  var name15 = "isNaN";
  var dependencies16 = ["typed"];
  var createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name15, {
      number: isNaNNumber,
      BigNumber: function BigNumber(x) {
        return x.isNaN();
      },
      Fraction: function Fraction2(x) {
        return false;
      },
      Complex: function Complex2(x) {
        return x.isNaN();
      },
      Unit: function Unit(x) {
        return Number.isNaN(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, Number.isNaN);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/typeOf.js
  var name16 = "typeOf";
  var dependencies17 = ["typed"];
  var createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name16, {
      any: typeOf
    });
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
  function nearlyEqual2(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x.eq(y);
    }
    if (x.eq(y)) {
      return true;
    }
    if (x.isNaN() || y.isNaN()) {
      return false;
    }
    if (x.isFinite() && y.isFinite()) {
      var diff = x.minus(y).abs();
      if (diff.isZero()) {
        return true;
      } else {
        var max2 = x.constructor.max(x.abs(), y.abs());
        return diff.lte(max2.times(epsilon));
      }
    }
    return false;
  }

  // node_modules/mathjs/lib/esm/utils/complex.js
  function complexEquals(x, y, epsilon) {
    return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
  }

  // node_modules/mathjs/lib/esm/function/relational/compareUnits.js
  var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
    var {
      typed
    } = _ref;
    return {
      "Unit, Unit": typed.referToSelf((self2) => (x, y) => {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return typed.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
      })
    };
  });

  // node_modules/mathjs/lib/esm/function/relational/equalScalar.js
  var name17 = "equalScalar";
  var dependencies18 = ["typed", "config"];
  var createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
    var {
      typed,
      config: config2
    } = _ref;
    var compareUnits = createCompareUnits({
      typed
    });
    return typed(name17, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x === y;
      },
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config2.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.eq(y) || nearlyEqual2(x, y, config2.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.equals(y);
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return complexEquals(x, y, config2.epsilon);
      }
    }, compareUnits);
  });
  var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config: config2
    } = _ref2;
    return typed(name17, {
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config2.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
  var name18 = "SparseMatrix";
  var dependencies19 = ["typed", "equalScalar", "Matrix"];
  var createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
    var {
      typed,
      equalScalar,
      Matrix
    } = _ref;
    function SparseMatrix(data, datatype) {
      if (!(this instanceof SparseMatrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        _createFromArray(this, data, datatype);
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }
    function _createFromMatrix(matrix, source, datatype) {
      if (source.type === "SparseMatrix") {
        matrix._values = source._values ? clone(source._values) : void 0;
        matrix._index = clone(source._index);
        matrix._ptr = clone(source._ptr);
        matrix._size = clone(source._size);
        matrix._datatype = datatype || source._datatype;
      } else {
        _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix, data, datatype) {
      matrix._values = [];
      matrix._index = [];
      matrix._ptr = [];
      matrix._datatype = datatype;
      var rows = data.length;
      var columns = 0;
      var eq = equalScalar;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
        zero = typed.convert(0, datatype);
      }
      if (rows > 0) {
        var j = 0;
        do {
          matrix._ptr.push(matrix._index.length);
          for (var i = 0; i < rows; i++) {
            var row = data[i];
            if (isArray(row)) {
              if (j === 0 && columns < row.length) {
                columns = row.length;
              }
              if (j < row.length) {
                var v = row[j];
                if (!eq(v, zero)) {
                  matrix._values.push(v);
                  matrix._index.push(i);
                }
              }
            } else {
              if (j === 0 && columns < 1) {
                columns = 1;
              }
              if (!eq(row, zero)) {
                matrix._values.push(row);
                matrix._index.push(i);
              }
            }
          }
          j++;
        } while (j < columns);
      }
      matrix._ptr.push(matrix._index.length);
      matrix._size = [rows, columns];
    }
    SparseMatrix.prototype = new Matrix();
    SparseMatrix.prototype.createSparseMatrix = function(data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    Object.defineProperty(SparseMatrix, "name", {
      value: "SparseMatrix"
    });
    SparseMatrix.prototype.constructor = SparseMatrix;
    SparseMatrix.prototype.type = "SparseMatrix";
    SparseMatrix.prototype.isSparseMatrix = true;
    SparseMatrix.prototype.getDataType = function() {
      return getArrayDataType(this._values, typeOf);
    };
    SparseMatrix.prototype.storage = function() {
      return "sparse";
    };
    SparseMatrix.prototype.datatype = function() {
      return this._datatype;
    };
    SparseMatrix.prototype.create = function(data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    SparseMatrix.prototype.density = function() {
      var rows = this._size[0];
      var columns = this._size[1];
      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    SparseMatrix.prototype.subset = function(index, replacement, defaultValue) {
      if (!this._values) {
        throw new Error("Cannot invoke subset on a Pattern only matrix");
      }
      switch (arguments.length) {
        case 1:
          return _getsubset(this, index);
        case 2:
        case 3:
          return _setsubset(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    function _getsubset(matrix, idx) {
      if (!isIndex(idx)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = idx.isScalar();
      if (isScalar) {
        return matrix.get(idx.min());
      }
      var size = idx.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      }
      var i, ii, k, kk;
      var min2 = idx.min();
      var max2 = idx.max();
      for (i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min2[i], matrix._size[i]);
        validateIndex(max2[i], matrix._size[i]);
      }
      var mvalues = matrix._values;
      var mindex = matrix._index;
      var mptr = matrix._ptr;
      var rows = idx.dimension(0);
      var columns = idx.dimension(1);
      var w = [];
      var pv = [];
      rows.forEach(function(i2, r) {
        pv[i2] = r[0];
        w[i2] = true;
      });
      var values2 = mvalues ? [] : void 0;
      var index = [];
      var ptr = [];
      columns.forEach(function(j) {
        ptr.push(index.length);
        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          i = mindex[k];
          if (w[i] === true) {
            index.push(pv[i]);
            if (values2) {
              values2.push(mvalues[k]);
            }
          }
        }
      });
      ptr.push(index.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size,
        datatype: matrix._datatype
      });
    }
    function _setsubset(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.toArray();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        if (iSize.length === 1) {
          var range = index.dimension(0);
          range.forEach(function(dataIndex, subIndex) {
            validateIndex(dataIndex);
            matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
          });
        } else {
          var firstDimensionRange = index.dimension(0);
          var secondDimensionRange = index.dimension(1);
          firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
            validateIndex(firstDataIndex);
            secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
              validateIndex(secondDataIndex);
              matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
            });
          });
        }
      }
      return matrix;
    }
    SparseMatrix.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke get on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[1]);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        return this._values[k];
      }
      return 0;
    };
    SparseMatrix.prototype.set = function(index, v, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke set on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      var rows = this._size[0];
      var columns = this._size[1];
      var eq = equalScalar;
      var zero = 0;
      if (isString(this._datatype)) {
        eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
        zero = typed.convert(0, this._datatype);
      }
      if (i > rows - 1 || j > columns - 1) {
        _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
        rows = this._size[0];
        columns = this._size[1];
      }
      validateIndex(i, rows);
      validateIndex(j, columns);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        if (!eq(v, zero)) {
          this._values[k] = v;
        } else {
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }
      return this;
    };
    function _getValueIndex(i, top, bottom, index) {
      if (bottom - top === 0) {
        return bottom;
      }
      for (var r = top; r < bottom; r++) {
        if (index[r] === i) {
          return r;
        }
      }
      return top;
    }
    function _remove(k, j, values2, index, ptr) {
      values2.splice(k, 1);
      index.splice(k, 1);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i, j, v, values2, index, ptr) {
      values2.splice(k, 0, v);
      index.splice(k, 0, i);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    SparseMatrix.prototype.resize = function(size, defaultValue, copy) {
      if (!isCollection(size)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      if (sizeArray.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      sizeArray.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
        }
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize2(matrix, rows, columns, defaultValue) {
      var value = defaultValue || 0;
      var eq = equalScalar;
      var zero = 0;
      if (isString(matrix._datatype)) {
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
        zero = typed.convert(0, matrix._datatype);
        value = typed.convert(value, matrix._datatype);
      }
      var ins = !eq(value, zero);
      var r = matrix._size[0];
      var c = matrix._size[1];
      var i, j, k;
      if (columns > c) {
        for (j = c; j < columns; j++) {
          matrix._ptr[j] = matrix._values.length;
          if (ins) {
            for (i = 0; i < r; i++) {
              matrix._values.push(value);
              matrix._index.push(i);
            }
          }
        }
        matrix._ptr[columns] = matrix._values.length;
      } else if (columns < c) {
        matrix._ptr.splice(columns + 1, c - columns);
        matrix._values.splice(matrix._ptr[columns], matrix._values.length);
        matrix._index.splice(matrix._ptr[columns], matrix._index.length);
      }
      c = columns;
      if (rows > r) {
        if (ins) {
          var n = 0;
          for (j = 0; j < c; j++) {
            matrix._ptr[j] = matrix._ptr[j] + n;
            k = matrix._ptr[j + 1] + n;
            var p = 0;
            for (i = r; i < rows; i++, p++) {
              matrix._values.splice(k + p, 0, value);
              matrix._index.splice(k + p, 0, i);
              n++;
            }
          }
          matrix._ptr[c] = matrix._values.length;
        }
      } else if (rows < r) {
        var d = 0;
        for (j = 0; j < c; j++) {
          matrix._ptr[j] = matrix._ptr[j] - d;
          var k0 = matrix._ptr[j];
          var k1 = matrix._ptr[j + 1] - d;
          for (k = k0; k < k1; k++) {
            i = matrix._index[k];
            if (i > rows - 1) {
              matrix._values.splice(k, 1);
              matrix._index.splice(k, 1);
              d++;
            }
          }
        }
        matrix._ptr[j] = matrix._values.length;
      }
      matrix._size[0] = rows;
      matrix._size[1] = columns;
      return matrix;
    }
    SparseMatrix.prototype.reshape = function(sizes, copy) {
      if (!isArray(sizes)) {
        throw new TypeError("Array expected");
      }
      if (sizes.length !== 2) {
        throw new Error("Sparse matrices can only be reshaped in two dimensions");
      }
      sizes.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
          throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
        }
      });
      var currentLength = this._size[0] * this._size[1];
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = sizes[0] * sizes[1];
      if (currentLength !== newLength) {
        throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
      }
      var m = copy ? this.clone() : this;
      if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
        return m;
      }
      var colIndex = [];
      for (var i = 0; i < m._ptr.length; i++) {
        for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
          colIndex.push(i);
        }
      }
      var values2 = m._values.slice();
      var rowIndex = m._index.slice();
      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % sizes[1];
        rowIndex[_i] = Math.floor(flat / sizes[1]);
      }
      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = sizes[1] + 1;
      m._size = sizes.slice();
      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      }
      for (var h = 0; h < values2.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values2[h];
        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      }
      return m;
    };
    SparseMatrix.prototype.clone = function() {
      var m = new SparseMatrix({
        values: this._values ? clone(this._values) : void 0,
        index: clone(this._index),
        ptr: clone(this._ptr),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    SparseMatrix.prototype.size = function() {
      return this._size.slice(0);
    };
    SparseMatrix.prototype.map = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke map on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      var args = maxArgumentCount(callback);
      var invoke = function invoke2(v, i, j) {
        if (args === 1)
          return callback(v);
        if (args === 2)
          return callback(v, [i, j]);
        return callback(v, [i, j], me);
      };
      return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    function _map3(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      var values2 = [];
      var index = [];
      var ptr = [];
      var eq = equalScalar;
      var zero = 0;
      if (isString(matrix._datatype)) {
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar;
        zero = typed.convert(0, matrix._datatype);
      }
      var invoke = function invoke2(v, x, y) {
        v = callback(v, x, y);
        if (!eq(v, zero)) {
          values2.push(v);
          index.push(x);
        }
      };
      for (var j = minColumn; j <= maxColumn; j++) {
        ptr.push(values2.length);
        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = matrix._index[k];
            if (i >= minRow && i <= maxRow) {
              invoke(matrix._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          var _values = {};
          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix._index[_k];
            _values[_i4] = matrix._values[_k];
          }
          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      }
      ptr.push(values2.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    SparseMatrix.prototype.forEach = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke forEach on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = this._index[k];
            callback(this._values[k], [i, j], me);
          }
        } else {
          var values2 = {};
          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values2[_i6] = this._values[_k2];
          }
          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values2 ? values2[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    SparseMatrix.prototype[Symbol.iterator] = function* () {
      if (!this._values) {
        throw new Error("Cannot iterate a Pattern only matrix");
      }
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          yield {
            value: this._values[k],
            index: [i, j]
          };
        }
      }
    };
    SparseMatrix.prototype.toArray = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    SparseMatrix.prototype.valueOf = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values2, index, ptr, size, copy) {
      var rows = size[0];
      var columns = size[1];
      var a = [];
      var i, j;
      for (i = 0; i < rows; i++) {
        a[i] = [];
        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      }
      for (j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          i = index[k];
          a[i][j] = values2 ? copy ? clone(values2[k]) : values2[k] : 1;
        }
      }
      return a;
    }
    SparseMatrix.prototype.format = function(options) {
      var rows = this._size[0];
      var columns = this._size[1];
      var density = this.density();
      var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
        }
      }
      return str;
    };
    SparseMatrix.prototype.toString = function() {
      return format3(this.toArray());
    };
    SparseMatrix.prototype.toJSON = function() {
      return {
        mathjs: "SparseMatrix",
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    SparseMatrix.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var values2 = [];
      var index = [];
      var ptr = [];
      ptr[0] = 0;
      for (var j = kSuper; j < columns && values2.length < n; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var x = k0; x < k1; x++) {
          var i = this._index[x];
          if (i === j - kSuper + kSub) {
            values2.push(this._values[x]);
            index[values2.length - 1] = i - kSub;
            break;
          }
        }
      }
      ptr.push(values2.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size: [n, 1]
      });
    };
    SparseMatrix.fromJSON = function(json) {
      return new SparseMatrix(json);
    };
    SparseMatrix.diagonal = function(size, value, k, defaultValue, datatype) {
      if (!isArray(size)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size = size.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var eq = equalScalar;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
        zero = typed.convert(0, datatype);
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size[0];
      var columns = size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i2) {
          return value[i2];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i2) {
          return value.get([i2]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      var values2 = [];
      var index = [];
      var ptr = [];
      for (var j = 0; j < columns; j++) {
        ptr.push(values2.length);
        var i = j - kSuper;
        if (i >= 0 && i < n) {
          var v = _value(i);
          if (!eq(v, zero)) {
            index.push(i + kSub);
            values2.push(v);
          }
        }
      }
      ptr.push(values2.length);
      return new SparseMatrix({
        values: values2,
        index,
        ptr,
        size: [rows, columns]
      });
    };
    SparseMatrix.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
      return this;
    };
    SparseMatrix._forEachRow = function(j, values2, index, ptr, callback) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        callback(index[k], values2[k]);
      }
    };
    SparseMatrix._swapRows = function(x, y, columns, values2, index, ptr) {
      for (var j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        var kx = _getValueIndex(x, k0, k1, index);
        var ky = _getValueIndex(y, k0, k1, index);
        if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
          if (values2) {
            var v = values2[kx];
            values2[kx] = values2[ky];
            values2[ky] = v;
          }
          continue;
        }
        if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
          var vx = values2 ? values2[kx] : void 0;
          index.splice(ky, 0, y);
          if (values2) {
            values2.splice(ky, 0, vx);
          }
          index.splice(ky <= kx ? kx + 1 : kx, 1);
          if (values2) {
            values2.splice(ky <= kx ? kx + 1 : kx, 1);
          }
          continue;
        }
        if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
          var vy = values2 ? values2[ky] : void 0;
          index.splice(kx, 0, x);
          if (values2) {
            values2.splice(kx, 0, vy);
          }
          index.splice(kx <= ky ? ky + 1 : ky, 1);
          if (values2) {
            values2.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };
    return SparseMatrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/number.js
  var name19 = "number";
  var dependencies20 = ["typed"];
  function getNonDecimalNumberParts(input) {
    var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
      var radix = {
        "0b": 2,
        "0o": 8,
        "0x": 16
      }[nonDecimalWithRadixMatch[1]];
      var integerPart = nonDecimalWithRadixMatch[2];
      var fractionalPart = nonDecimalWithRadixMatch[3];
      return {
        input,
        radix,
        integerPart,
        fractionalPart
      };
    } else {
      return null;
    }
  }
  function makeNumberFromNonDecimalParts(parts) {
    var n = parseInt(parts.integerPart, parts.radix);
    var f = 0;
    for (var i = 0; i < parts.fractionalPart.length; i++) {
      var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
      f += digitValue / Math.pow(parts.radix, i + 1);
    }
    var result = n + f;
    if (isNaN(result)) {
      throw new SyntaxError('String "' + parts.input + '" is no valid number');
    }
    return result;
  }
  var createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
    var {
      typed
    } = _ref;
    var number = typed("number", {
      "": function _() {
        return 0;
      },
      number: function number2(x) {
        return x;
      },
      string: function string(x) {
        if (x === "NaN")
          return NaN;
        var nonDecimalNumberParts = getNonDecimalNumberParts(x);
        if (nonDecimalNumberParts) {
          return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
        }
        var size = 0;
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          size = Number(wordSizeSuffixMatch[2]);
          x = wordSizeSuffixMatch[1];
        }
        var num = Number(x);
        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is no valid number');
        }
        if (wordSizeSuffixMatch) {
          if (num > 2 ** size - 1) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          if (num >= 2 ** (size - 1)) {
            num = num - 2 ** size;
          }
        }
        return num;
      },
      BigNumber: function BigNumber(x) {
        return x.toNumber();
      },
      Fraction: function Fraction2(x) {
        return x.valueOf();
      },
      Unit: function Unit(x) {
        throw new Error("Second argument with valueless unit expected");
      },
      null: function _null(x) {
        return 0;
      },
      "Unit, string | Unit": function UnitStringUnit(unit, valuelessUnit) {
        return unit.toNumber(valuelessUnit);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
    number.fromJSON = function(json) {
      return parseFloat(json.value);
    };
    return number;
  });

  // node_modules/mathjs/lib/esm/type/string.js
  var name20 = "string";
  var dependencies21 = ["typed"];
  var createString = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name20, {
      "": function _() {
        return "";
      },
      number: format,
      null: function _null(x) {
        return "null";
      },
      boolean: function boolean(x) {
        return x + "";
      },
      string: function string(x) {
        return x;
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2)),
      any: function any(x) {
        return String(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/boolean.js
  var name21 = "boolean";
  var dependencies22 = ["typed"];
  var createBoolean = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name21, {
      "": function _() {
        return false;
      },
      boolean: function boolean(x) {
        return x;
      },
      number: function number(x) {
        return !!x;
      },
      null: function _null(x) {
        return false;
      },
      BigNumber: function BigNumber(x) {
        return !x.isZero();
      },
      string: function string(x) {
        var lcase = x.toLowerCase();
        if (lcase === "true") {
          return true;
        } else if (lcase === "false") {
          return false;
        }
        var num = Number(x);
        if (x !== "" && !isNaN(num)) {
          return !!num;
        }
        throw new Error('Cannot convert "' + x + '" to a boolean');
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
  var name22 = "bignumber";
  var dependencies23 = ["typed", "BigNumber"];
  var createBignumber = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
    var {
      typed,
      BigNumber
    } = _ref;
    return typed("bignumber", {
      "": function _() {
        return new BigNumber(0);
      },
      number: function number(x) {
        return new BigNumber(x + "");
      },
      string: function string(x) {
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          var size = wordSizeSuffixMatch[2];
          var n = BigNumber(wordSizeSuffixMatch[1]);
          var twoPowSize = new BigNumber(2).pow(Number(size));
          if (n.gt(twoPowSize.sub(1))) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
          if (n.gte(twoPowSizeSubOne)) {
            return n.sub(twoPowSize);
          } else {
            return n;
          }
        }
        return new BigNumber(x);
      },
      BigNumber: function BigNumber2(x) {
        return x;
      },
      Fraction: function Fraction2(x) {
        return new BigNumber(x.n).div(x.d).times(x.s);
      },
      null: function _null(x) {
        return new BigNumber(0);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/complex/function/complex.js
  var name23 = "complex";
  var dependencies24 = ["typed", "Complex"];
  var createComplex = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
    var {
      typed,
      Complex: Complex2
    } = _ref;
    return typed("complex", {
      "": function _() {
        return Complex2.ZERO;
      },
      number: function number(x) {
        return new Complex2(x, 0);
      },
      "number, number": function numberNumber(re, im) {
        return new Complex2(re, im);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(re, im) {
        return new Complex2(re.toNumber(), im.toNumber());
      },
      Fraction: function Fraction2(x) {
        return new Complex2(x.valueOf(), 0);
      },
      Complex: function Complex3(x) {
        return x.clone();
      },
      string: function string(x) {
        return Complex2(x);
      },
      null: function _null(x) {
        return Complex2(0);
      },
      Object: function Object2(x) {
        if ("re" in x && "im" in x) {
          return new Complex2(x.re, x.im);
        }
        if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
          return new Complex2(x);
        }
        throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
  var name24 = "fraction";
  var dependencies25 = ["typed", "Fraction"];
  var createFraction = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
    var {
      typed,
      Fraction: Fraction2
    } = _ref;
    return typed("fraction", {
      number: function number(x) {
        if (!isFinite(x) || isNaN(x)) {
          throw new Error(x + " cannot be represented as a fraction");
        }
        return new Fraction2(x);
      },
      string: function string(x) {
        return new Fraction2(x);
      },
      "number, number": function numberNumber(numerator, denominator) {
        return new Fraction2(numerator, denominator);
      },
      null: function _null(x) {
        return new Fraction2(0);
      },
      BigNumber: function BigNumber(x) {
        return new Fraction2(x.toString());
      },
      Fraction: function Fraction3(x) {
        return x;
      },
      Object: function Object2(x) {
        return new Fraction2(x);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
  var name25 = "matrix";
  var dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
  var createMatrix = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
    var {
      typed,
      Matrix,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    return typed(name25, {
      "": function _() {
        return _create([]);
      },
      string: function string(format4) {
        return _create([], format4);
      },
      "string, string": function stringString(format4, datatype) {
        return _create([], format4, datatype);
      },
      Array: function Array2(data) {
        return _create(data);
      },
      Matrix: function Matrix2(data) {
        return _create(data, data.storage());
      },
      "Array | Matrix, string": _create,
      "Array | Matrix, string, string": _create
    });
    function _create(data, format4, datatype) {
      if (format4 === "dense" || format4 === "default" || format4 === void 0) {
        return new DenseMatrix(data, datatype);
      }
      if (format4 === "sparse") {
        return new SparseMatrix(data, datatype);
      }
      throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
  var name26 = "matrixFromFunction";
  var dependencies27 = ["typed", "matrix", "isZero"];
  var createMatrixFromFunction = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
    var {
      typed,
      matrix,
      isZero
    } = _ref;
    return typed(name26, {
      "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size, fn, format4, datatype) {
        return _create(size, fn, format4, datatype);
      },
      "Array | Matrix, function, string": function ArrayMatrixFunctionString(size, fn, format4) {
        return _create(size, fn, format4);
      },
      "Matrix, function": function MatrixFunction(size, fn) {
        return _create(size, fn, "dense");
      },
      "Array, function": function ArrayFunction(size, fn) {
        return _create(size, fn, "dense").toArray();
      },
      "Array | Matrix, string, function": function ArrayMatrixStringFunction(size, format4, fn) {
        return _create(size, fn, format4);
      },
      "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size, format4, datatype, fn) {
        return _create(size, fn, format4, datatype);
      }
    });
    function _create(size, fn, format4, datatype) {
      var m;
      if (datatype !== void 0) {
        m = matrix(format4, datatype);
      } else {
        m = matrix(format4);
      }
      m.resize(size);
      m.forEach(function(_, index) {
        var val = fn(index);
        if (isZero(val))
          return;
        m.set(index, val);
      });
      return m;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
  var name27 = "matrixFromRows";
  var dependencies28 = ["typed", "matrix", "flatten", "size"];
  var createMatrixFromRows = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
    var {
      typed,
      matrix,
      flatten: flatten2,
      size
    } = _ref;
    return typed(name27, {
      "...Array": function Array2(arr) {
        return _createArray(arr);
      },
      "...Matrix": function Matrix(arr) {
        return matrix(_createArray(arr.map((m) => m.toArray())));
      }
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError("At least one row is needed to construct a matrix.");
      var N = checkVectorTypeAndReturnLength(arr[0]);
      var result = [];
      for (var row of arr) {
        var rowLength = checkVectorTypeAndReturnLength(row);
        if (rowLength !== N) {
          throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
        }
        result.push(flatten2(row));
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      var s = size(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError("Only one- or two-dimensional vectors are supported.");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
  var name28 = "matrixFromColumns";
  var dependencies29 = ["typed", "matrix", "flatten", "size"];
  var createMatrixFromColumns = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
    var {
      typed,
      matrix,
      flatten: flatten2,
      size
    } = _ref;
    return typed(name28, {
      "...Array": function Array2(arr) {
        return _createArray(arr);
      },
      "...Matrix": function Matrix(arr) {
        return matrix(_createArray(arr.map((m) => m.toArray())));
      }
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError("At least one column is needed to construct a matrix.");
      var N = checkVectorTypeAndReturnLength(arr[0]);
      var result = [];
      for (var i = 0; i < N; i++) {
        result[i] = [];
      }
      for (var col of arr) {
        var colLength = checkVectorTypeAndReturnLength(col);
        if (colLength !== N) {
          throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
        }
        var f = flatten2(col);
        for (var _i = 0; _i < N; _i++) {
          result[_i].push(f[_i]);
        }
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      var s = size(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError("Only one- or two-dimensional vectors are supported.");
      }
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
  var name29 = "splitUnit";
  var dependencies30 = ["typed"];
  var createSplitUnit = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name29, {
      "Unit, Array": function UnitArray(unit, parts) {
        return unit.splitUnit(parts);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
  var name30 = "unaryMinus";
  var dependencies31 = ["typed"];
  var createUnaryMinus = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name30, {
      number: unaryMinusNumber,
      "Complex | BigNumber | Fraction": (x) => x.neg(),
      Unit: typed.referToSelf((self2) => (x) => {
        var res = x.clone();
        res.value = typed.find(self2, res.valueType())(x.value);
        return res;
      }),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true))
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
  var name31 = "unaryPlus";
  var dependencies32 = ["typed", "config", "BigNumber"];
  var createUnaryPlus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
    var {
      typed,
      config: config2,
      BigNumber
    } = _ref;
    return typed(name31, {
      number: unaryPlusNumber,
      Complex: function Complex2(x) {
        return x;
      },
      BigNumber: function BigNumber2(x) {
        return x;
      },
      Fraction: function Fraction2(x) {
        return x;
      },
      Unit: function Unit(x) {
        return x.clone();
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true)),
      "boolean | string": function booleanString(x) {
        return config2.number === "BigNumber" ? new BigNumber(+x) : +x;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/abs.js
  var name32 = "abs";
  var dependencies33 = ["typed"];
  var createAbs = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name32, {
      number: absNumber,
      "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true))
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/apply.js
  var name33 = "apply";
  var dependencies34 = ["typed", "isInteger"];
  var createApply = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
    var {
      typed,
      isInteger: isInteger2
    } = _ref;
    return typed(name33, {
      "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
        if (!isInteger2(dim)) {
          throw new TypeError("Integer number expected for dimension");
        }
        var size = Array.isArray(mat) ? arraySize(mat) : mat.size();
        if (dim < 0 || dim >= size.length) {
          throw new IndexError(dim, size.length);
        }
        if (isMatrix(mat)) {
          return mat.create(_apply(mat.valueOf(), dim, callback));
        } else {
          return _apply(mat, dim, callback);
        }
      }
    });
  });
  function _apply(mat, dim, callback) {
    var i, ret, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        return callback(mat);
      } else {
        tran = _switch2(mat);
        ret = [];
        for (i = 0; i < tran.length; i++) {
          ret[i] = _apply(tran[i], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i = 0; i < mat.length; i++) {
        ret[i] = _apply(mat[i], dim - 1, callback);
      }
      return ret;
    }
  }
  function _switch2(mat) {
    var I = mat.length;
    var J = mat[0].length;
    var i, j;
    var ret = [];
    for (j = 0; j < J; j++) {
      var tmp = [];
      for (i = 0; i < I; i++) {
        tmp.push(mat[i][j]);
      }
      ret.push(tmp);
    }
    return ret;
  }

  // node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
  var name34 = "addScalar";
  var dependencies35 = ["typed"];
  var createAddScalar = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name34, {
      "number, number": addNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.add(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.plus(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.add(y);
      },
      "Unit, Unit": typed.referToSelf((self2) => (x, y) => {
        if (x.value === null || x.value === void 0) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null || y.value === void 0) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y))
          throw new Error("Units do not match");
        var res = x.clone();
        res.value = typed.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
        res.fixPrefix = false;
        return res;
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
  var name35 = "cbrt";
  var dependencies36 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
  var createCbrt = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
    var {
      config: config2,
      typed,
      isNegative,
      unaryMinus,
      matrix,
      Complex: Complex2,
      BigNumber,
      Fraction: Fraction2
    } = _ref;
    return typed(name35, {
      number: cbrtNumber,
      Complex: _cbrtComplex,
      "Complex, boolean": _cbrtComplex,
      BigNumber: function BigNumber2(x) {
        return x.cbrt();
      },
      Unit: _cbrtUnit
    });
    function _cbrtComplex(x, allRoots) {
      var arg3 = x.arg() / 3;
      var abs2 = x.abs();
      var principal = new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3).exp());
      if (allRoots) {
        var all2 = [principal, new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 + Math.PI * 2 / 3).exp()), new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 - Math.PI * 2 / 3).exp())];
        return config2.matrix === "Array" ? all2 : matrix(all2);
      } else {
        return principal;
      }
    }
    function _cbrtUnit(x) {
      if (x.value && isComplex(x.value)) {
        var result = x.clone();
        result.value = 1;
        result = result.pow(1 / 3);
        result.value = _cbrtComplex(x.value);
        return result;
      } else {
        var negate = isNegative(x.value);
        if (negate) {
          x.value = unaryMinus(x.value);
        }
        var third;
        if (isBigNumber(x.value)) {
          third = new BigNumber(1).div(3);
        } else if (isFraction(x.value)) {
          third = new Fraction2(1, 3);
        } else {
          third = 1 / 3;
        }
        var _result = x.pow(third);
        if (negate) {
          _result.value = unaryMinus(_result.value);
        }
        return _result;
      }
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
  var name36 = "matAlgo11xS0s";
  var dependencies37 = ["typed", "equalScalar"];
  var createMatAlgo11xS0s = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo11xS0s(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var i = aindex[k];
          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
          if (!eq(v, zero)) {
            cindex.push(i);
            cvalues.push(v);
          }
        }
      }
      cptr[columns] = cindex.length;
      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
  var name37 = "matAlgo12xSfs";
  var dependencies38 = ["typed", "DenseMatrix"];
  var createMatAlgo12xSfs = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
    var {
      typed,
      DenseMatrix
    } = _ref;
    return function matAlgo12xSfs(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (var i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
  var name38 = "matAlgo14xDs";
  var dependencies39 = ["typed"];
  var createMatAlgo14xDs = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
    var {
      typed
    } = _ref;
    return function matAlgo14xDs(a, b, callback, inverse) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv, inverse) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
  var name39 = "ceil";
  var dependencies40 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createCeilNumber = /* @__PURE__ */ factory(name39, ["typed", "config", "round"], (_ref) => {
    var {
      typed,
      config: config2,
      round: round2
    } = _ref;
    return typed(name39, {
      number: function number(x) {
        if (nearlyEqual(x, round2(x), config2.epsilon)) {
          return round2(x);
        } else {
          return Math.ceil(x);
        }
      },
      "number, number": function numberNumber(x, n) {
        if (nearlyEqual(x, round2(x, n), config2.epsilon)) {
          return round2(x, n);
        } else {
          var [number, exponent] = "".concat(x, "e").split("e");
          var result = Math.ceil(Number("".concat(number, "e").concat(Number(exponent) + n)));
          [number, exponent] = "".concat(result, "e").split("e");
          return Number("".concat(number, "e").concat(Number(exponent) - n));
        }
      }
    });
  });
  var createCeil = /* @__PURE__ */ factory(name39, dependencies40, (_ref2) => {
    var {
      typed,
      config: config2,
      round: round2,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref2;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var ceilNumber = createCeilNumber({
      typed,
      config: config2,
      round: round2
    });
    return typed("ceil", {
      number: ceilNumber.signatures.number,
      "number,number": ceilNumber.signatures["number,number"],
      Complex: function Complex2(x) {
        return x.ceil();
      },
      "Complex, number": function ComplexNumber(x, n) {
        return x.ceil(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        return x.ceil(n.toNumber());
      },
      BigNumber: function BigNumber(x) {
        if (nearlyEqual2(x, round2(x), config2.epsilon)) {
          return round2(x);
        } else {
          return x.ceil();
        }
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (nearlyEqual2(x, round2(x, n), config2.epsilon)) {
          return round2(x, n);
        } else {
          return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_CEIL);
        }
      },
      Fraction: function Fraction2(x) {
        return x.ceil();
      },
      "Fraction, number": function FractionNumber(x, n) {
        return x.ceil(n);
      },
      "Fraction, BigNumber": function FractionBigNumber(x, n) {
        return x.ceil(n.toNumber());
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "Array, number | BigNumber": typed.referToSelf((self2) => (x, n) => {
        return deepMap(x, (i) => self2(i, n), true);
      }),
      "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(x, y, self2, false);
      }),
      "number | Complex | Fraction | BigNumber, Array": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
      }),
      "number | Complex | Fraction | BigNumber, Matrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0))
          return zeros2(y.size(), y.storage());
        if (y.storage() === "dense") {
          return matAlgo14xDs(y, x, self2, true);
        }
        return matAlgo12xSfs(y, x, self2, true);
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cube.js
  var name40 = "cube";
  var dependencies41 = ["typed"];
  var createCube = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name40, {
      number: cubeNumber,
      Complex: function Complex2(x) {
        return x.mul(x).mul(x);
      },
      BigNumber: function BigNumber(x) {
        return x.times(x).times(x);
      },
      Fraction: function Fraction2(x) {
        return x.pow(3);
      },
      Unit: function Unit(x) {
        return x.pow(3);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/exp.js
  var name41 = "exp";
  var dependencies42 = ["typed"];
  var createExp = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name41, {
      number: expNumber,
      Complex: function Complex2(x) {
        return x.exp();
      },
      BigNumber: function BigNumber(x) {
        return x.exp();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
  var name42 = "expm1";
  var dependencies43 = ["typed", "Complex"];
  var createExpm1 = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
    var {
      typed,
      Complex: _Complex
    } = _ref;
    return typed(name42, {
      number: expm1Number,
      Complex: function Complex2(x) {
        var r = Math.exp(x.re);
        return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
      },
      BigNumber: function BigNumber(x) {
        return x.exp().minus(1);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/fix.js
  var name43 = "fix";
  var dependencies44 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
  var createFixNumber = /* @__PURE__ */ factory(name43, ["typed", "ceil", "floor"], (_ref) => {
    var {
      typed,
      ceil: ceil2,
      floor: floor2
    } = _ref;
    return typed(name43, {
      number: function number(x) {
        return x > 0 ? floor2(x) : ceil2(x);
      },
      "number, number": function numberNumber(x, n) {
        return x > 0 ? floor2(x, n) : ceil2(x, n);
      }
    });
  });
  var createFix = /* @__PURE__ */ factory(name43, dependencies44, (_ref2) => {
    var {
      typed,
      Complex: _Complex,
      matrix,
      ceil: ceil2,
      floor: floor2,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref2;
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var fixNumber = createFixNumber({
      typed,
      ceil: ceil2,
      floor: floor2
    });
    return typed("fix", {
      number: fixNumber.signatures.number,
      "number, number | BigNumber": fixNumber.signatures["number,number"],
      Complex: function Complex2(x) {
        return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
      },
      "Complex, number": function ComplexNumber(x, n) {
        return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
      },
      "Complex, BigNumber": function ComplexBigNumber(x, bn) {
        var n = bn.toNumber();
        return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
      },
      BigNumber: function BigNumber(x) {
        return x.isNegative() ? ceil2(x) : floor2(x);
      },
      "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
        return x.isNegative() ? ceil2(x, n) : floor2(x, n);
      },
      Fraction: function Fraction2(x) {
        return x.s < 0 ? x.ceil() : x.floor();
      },
      "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
        return x.s < 0 ? ceil2(x, n) : floor2(x, n);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "Array | Matrix, number | BigNumber": typed.referToSelf((self2) => (x, n) => {
        return deepMap(x, (i) => self2(i, n), true);
      }),
      "number | Complex | Fraction | BigNumber, Array": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
      }),
      "number | Complex | Fraction | BigNumber, Matrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0))
          return zeros2(y.size(), y.storage());
        if (y.storage() === "dense") {
          return matAlgo14xDs(y, x, self2, true);
        }
        return matAlgo12xSfs(y, x, self2, true);
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/floor.js
  var name44 = "floor";
  var dependencies45 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createFloorNumber = /* @__PURE__ */ factory(name44, ["typed", "config", "round"], (_ref) => {
    var {
      typed,
      config: config2,
      round: round2
    } = _ref;
    return typed(name44, {
      number: function number(x) {
        if (nearlyEqual(x, round2(x), config2.epsilon)) {
          return round2(x);
        } else {
          return Math.floor(x);
        }
      },
      "number, number": function numberNumber(x, n) {
        if (nearlyEqual(x, round2(x, n), config2.epsilon)) {
          return round2(x, n);
        } else {
          var [number, exponent] = "".concat(x, "e").split("e");
          var result = Math.floor(Number("".concat(number, "e").concat(Number(exponent) + n)));
          [number, exponent] = "".concat(result, "e").split("e");
          return Number("".concat(number, "e").concat(Number(exponent) - n));
        }
      }
    });
  });
  var createFloor = /* @__PURE__ */ factory(name44, dependencies45, (_ref2) => {
    var {
      typed,
      config: config2,
      round: round2,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref2;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var floorNumber = createFloorNumber({
      typed,
      config: config2,
      round: round2
    });
    return typed("floor", {
      number: floorNumber.signatures.number,
      "number,number": floorNumber.signatures["number,number"],
      Complex: function Complex2(x) {
        return x.floor();
      },
      "Complex, number": function ComplexNumber(x, n) {
        return x.floor(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        return x.floor(n.toNumber());
      },
      BigNumber: function BigNumber(x) {
        if (nearlyEqual2(x, round2(x), config2.epsilon)) {
          return round2(x);
        } else {
          return x.floor();
        }
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (nearlyEqual2(x, round2(x, n), config2.epsilon)) {
          return round2(x, n);
        } else {
          return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_FLOOR);
        }
      },
      Fraction: function Fraction2(x) {
        return x.floor();
      },
      "Fraction, number": function FractionNumber(x, n) {
        return x.floor(n);
      },
      "Fraction, BigNumber": function FractionBigNumber(x, n) {
        return x.floor(n.toNumber());
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "Array, number | BigNumber": typed.referToSelf((self2) => (x, n) => {
        return deepMap(x, (i) => self2(i, n), true);
      }),
      "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(x, y, self2, false);
      }),
      "number | Complex | Fraction | BigNumber, Array": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
      }),
      "number | Complex | Fraction | BigNumber, Matrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0))
          return zeros2(y.size(), y.storage());
        if (y.storage() === "dense") {
          return matAlgo14xDs(y, x, self2, true);
        }
        return matAlgo12xSfs(y, x, self2, true);
      })
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
  var name45 = "matAlgo01xDSid";
  var dependencies46 = ["typed"];
  var createMatAlgo01xDSid = /* @__PURE__ */ factory(name45, dependencies46, (_ref) => {
    var {
      typed
    } = _ref;
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
      var cf = dt ? typed.find(callback, [dt, dt]) : callback;
      var i, j;
      var cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      var x = [];
      var w = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (i = 0; i < rows; i++) {
          if (w[i] === mark) {
            cdata[i][j] = x[i];
          } else {
            cdata[i][j] = adata[i][j];
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
  var name46 = "matAlgo04xSidSid";
  var dependencies47 = ["typed", "equalScalar"];
  var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo04xSidSid(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = avalues && bvalues ? [] : void 0;
      var xb = avalues && bvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa) {
            xa[i] = avalues[k];
          }
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (wa[i] === mark) {
            if (xa) {
              var v = cf(xa[i], bvalues[k]);
              if (!eq(v, zero)) {
                xa[i] = v;
              } else {
                wa[i] = null;
              }
            }
          } else {
            cindex.push(i);
            wb[i] = mark;
            if (xb) {
              xb[i] = bvalues[k];
            }
          }
        }
        if (xa && xb) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            if (wa[i] === mark) {
              cvalues[k] = xa[i];
              k++;
            } else if (wb[i] === mark) {
              cvalues[k] = xb[i];
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
  var name47 = "matAlgo10xSids";
  var dependencies48 = ["typed", "DenseMatrix"];
  var createMatAlgo10xSids = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
    var {
      typed,
      DenseMatrix
    } = _ref;
    return function matAlgo10xSids(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed.convert(b, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (var i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = b;
          }
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
  var name48 = "matAlgo13xDD";
  var dependencies49 = ["typed"];
  var createMatAlgo13xDD = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
    var {
      typed
    } = _ref;
    return function matAlgo13xDD(a, b, callback) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var csize = [];
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      for (var s = 0; s < asize.length; s++) {
        if (asize[s] !== bsize[s]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        csize[s] = asize[s];
      }
      var dt;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = f(av[i], bv[i]);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }
      return cv;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
  var name49 = "matrixAlgorithmSuite";
  var dependencies50 = ["typed", "matrix"];
  var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var matAlgo13xDD = createMatAlgo13xDD({
      typed
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    return function matrixAlgorithmSuite(options) {
      var elop = options.elop;
      var SD = options.SD || options.DS;
      var matrixSignatures;
      if (elop) {
        matrixSignatures = {
          "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD(x, y, elop),
          "Array, Array": (x, y) => matAlgo13xDD(matrix(x), matrix(y), elop).valueOf(),
          "Array, DenseMatrix": (x, y) => matAlgo13xDD(matrix(x), y, elop),
          "DenseMatrix, Array": (x, y) => matAlgo13xDD(x, matrix(y), elop)
        };
        if (options.SS) {
          matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options.SS(x, y, elop, false);
        }
        if (options.DS) {
          matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options.DS(x, y, elop, false);
          matrixSignatures["Array, SparseMatrix"] = (x, y) => options.DS(matrix(x), y, elop, false);
        }
        if (SD) {
          matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(y, x, elop, true);
          matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(matrix(y), x, elop, true);
        }
      } else {
        matrixSignatures = {
          "DenseMatrix, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
            return matAlgo13xDD(x, y, self2);
          }),
          "Array, Array": typed.referToSelf((self2) => (x, y) => {
            return matAlgo13xDD(matrix(x), matrix(y), self2).valueOf();
          }),
          "Array, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
            return matAlgo13xDD(matrix(x), y, self2);
          }),
          "DenseMatrix, Array": typed.referToSelf((self2) => (x, y) => {
            return matAlgo13xDD(x, matrix(y), self2);
          })
        };
        if (options.SS) {
          matrixSignatures["SparseMatrix, SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
            return options.SS(x, y, self2, false);
          });
        }
        if (options.DS) {
          matrixSignatures["DenseMatrix, SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
            return options.DS(x, y, self2, false);
          });
          matrixSignatures["Array, SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
            return options.DS(matrix(x), y, self2, false);
          });
        }
        if (SD) {
          matrixSignatures["SparseMatrix, DenseMatrix"] = typed.referToSelf((self2) => (x, y) => {
            return SD(y, x, self2, true);
          });
          matrixSignatures["SparseMatrix, Array"] = typed.referToSelf((self2) => (x, y) => {
            return SD(matrix(y), x, self2, true);
          });
        }
      }
      var scalar = options.scalar || "any";
      var Ds = options.Ds || options.Ss;
      if (Ds) {
        if (elop) {
          matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
          matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs(y, x, elop, true);
          matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();
          matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();
        } else {
          matrixSignatures["DenseMatrix," + scalar] = typed.referToSelf((self2) => (x, y) => {
            return matAlgo14xDs(x, y, self2, false);
          });
          matrixSignatures[scalar + ", DenseMatrix"] = typed.referToSelf((self2) => (x, y) => {
            return matAlgo14xDs(y, x, self2, true);
          });
          matrixSignatures["Array," + scalar] = typed.referToSelf((self2) => (x, y) => {
            return matAlgo14xDs(matrix(x), y, self2, false).valueOf();
          });
          matrixSignatures[scalar + ", Array"] = typed.referToSelf((self2) => (x, y) => {
            return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
          });
        }
      }
      var sS = options.sS !== void 0 ? options.sS : options.Ss;
      if (elop) {
        if (options.Ss) {
          matrixSignatures["SparseMatrix," + scalar] = (x, y) => options.Ss(x, y, elop, false);
        }
        if (sS) {
          matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
        }
      } else {
        if (options.Ss) {
          matrixSignatures["SparseMatrix," + scalar] = typed.referToSelf((self2) => (x, y) => {
            return options.Ss(x, y, self2, false);
          });
        }
        if (sS) {
          matrixSignatures[scalar + ", SparseMatrix"] = typed.referToSelf((self2) => (x, y) => {
            return sS(y, x, self2, true);
          });
        }
      }
      if (elop && elop.signatures) {
        extend(matrixSignatures, elop.signatures);
      }
      return matrixSignatures;
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
  var name50 = "gcd";
  var dependencies51 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
  var createGcd = /* @__PURE__ */ factory(name50, dependencies51, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      BigNumber,
      DenseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo04xSidSid = createMatAlgo04xSidSid({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
    var gcdManySignature = {};
    gcdManySignature["".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes)] = typed.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i = 0; i < args.length; i++) {
        res = self2(res, args[i]);
      }
      return res;
    });
    return typed(name50, {
      "number, number": gcdNumber,
      "BigNumber, BigNumber": _gcdBigNumber,
      "Fraction, Fraction": (x, y) => x.gcd(y)
    }, matrixAlgorithmSuite({
      SS: matAlgo04xSidSid,
      DS: matAlgo01xDSid,
      Ss: matAlgo10xSids
    }), gcdManySignature);
    function _gcdBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function gcd must be integer numbers");
      }
      var zero = new BigNumber(0);
      while (!b.isZero()) {
        var r = a.mod(b);
        a = b;
        b = r;
      }
      return a.lt(zero) ? a.neg() : a;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
  var name51 = "matAlgo02xDS0";
  var dependencies52 = ["typed", "equalScalar"];
  var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name51, dependencies52, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i = bindex[k];
          var cij = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          if (!eq(cij, zero)) {
            cindex.push(i);
            cvalues.push(cij);
          }
        }
      }
      cptr[columns] = cindex.length;
      return sparseMatrix.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
  var name52 = "matAlgo06xS0S0";
  var dependencies53 = ["typed", "equalScalar"];
  var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name52, dependencies53, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo06xS0S0(a, b, callback) {
      var avalues = a._values;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var x = cvalues ? [] : void 0;
      var w = [];
      var u = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        scatter(a, j, w, x, u, mark, cindex, cf);
        scatter(b, j, w, x, u, mark, cindex, cf);
        if (x) {
          var k = cptr[j];
          while (k < cindex.length) {
            var i = cindex[k];
            if (u[i] === mark) {
              var v = x[i];
              if (!eq(v, zero)) {
                cvalues.push(v);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            } else {
              cindex.splice(k, 1);
            }
          }
        } else {
          var p = cptr[j];
          while (p < cindex.length) {
            var r = cindex[p];
            if (u[r] !== mark) {
              cindex.splice(p, 1);
            } else {
              p++;
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
  var name53 = "lcm";
  var dependencies54 = ["typed", "matrix", "equalScalar"];
  var createLcm = /* @__PURE__ */ factory(name53, dependencies54, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
    var lcmManySignature = {};
    lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i = 0; i < args.length; i++) {
        res = self2(res, args[i]);
      }
      return res;
    });
    return typed(name53, {
      "number, number": lcmNumber,
      "BigNumber, BigNumber": _lcmBigNumber,
      "Fraction, Fraction": (x, y) => x.lcm(y)
    }, matrixAlgorithmSuite({
      SS: matAlgo06xS0S0,
      DS: matAlgo02xDS0,
      Ss: matAlgo11xS0s
    }), lcmManySignature);
    function _lcmBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function lcm must be integer numbers");
      }
      if (a.isZero()) {
        return a;
      }
      if (b.isZero()) {
        return b;
      }
      var prod = a.times(b);
      while (!b.isZero()) {
        var t = b;
        b = a.mod(t);
        a = t;
      }
      return prod.div(a).abs();
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log10.js
  var name54 = "log10";
  var dependencies55 = ["typed", "config", "Complex"];
  var createLog10 = /* @__PURE__ */ factory(name54, dependencies55, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: _Complex
    } = _ref;
    return typed(name54, {
      number: function number(x) {
        if (x >= 0 || config2.predictable) {
          return log10Number(x);
        } else {
          return new _Complex(x, 0).log().div(Math.LN10);
        }
      },
      Complex: function Complex2(x) {
        return new _Complex(x).log().div(Math.LN10);
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config2.predictable) {
          return x.log();
        } else {
          return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
        }
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log2.js
  var name55 = "log2";
  var dependencies56 = ["typed", "config", "Complex"];
  var createLog2 = /* @__PURE__ */ factory(name55, dependencies56, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2
    } = _ref;
    return typed(name55, {
      number: function number(x) {
        if (x >= 0 || config2.predictable) {
          return log2Number(x);
        } else {
          return _log2Complex(new Complex2(x, 0));
        }
      },
      Complex: _log2Complex,
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config2.predictable) {
          return x.log(2);
        } else {
          return _log2Complex(new Complex2(x.toNumber(), 0));
        }
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
    function _log2Complex(x) {
      var newX = Math.sqrt(x.re * x.re + x.im * x.im);
      return new Complex2(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
  var name56 = "matAlgo03xDSf";
  var dependencies57 = ["typed"];
  var createMatAlgo03xDSf = /* @__PURE__ */ factory(name56, dependencies57, (_ref) => {
    var {
      typed
    } = _ref;
    return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cdata = [];
      for (var z = 0; z < rows; z++) {
        cdata[z] = [];
      }
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (var y = 0; y < rows; y++) {
          if (w[y] === mark) {
            cdata[y][j] = x[y];
          } else {
            cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
  var name57 = "matAlgo05xSfSf";
  var dependencies58 = ["typed", "equalScalar"];
  var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name57, dependencies58, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo05xSfSf(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = cvalues ? [] : void 0;
      var xb = cvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i, j, k, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa) {
            xa[i] = avalues[k];
          }
        }
        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          i = bindex[k];
          if (wa[i] !== mark) {
            cindex.push(i);
          }
          wb[i] = mark;
          if (xb) {
            xb[i] = bvalues[k];
          }
        }
        if (cvalues) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            var wai = wa[i];
            var wbi = wb[i];
            if (wai === mark || wbi === mark) {
              var va = wai === mark ? xa[i] : zero;
              var vb = wbi === mark ? xb[i] : zero;
              var vc = cf(va, vb);
              if (!eq(vc, zero)) {
                cvalues.push(vc);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/mod.js
  var name58 = "mod";
  var dependencies59 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createMod = /* @__PURE__ */ factory(name58, dependencies59, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name58, {
      "number, number": modNumber,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        if (y.isNeg()) {
          throw new Error("Cannot calculate mod for a negative divisor");
        }
        return y.isZero() ? x : x.mod(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        if (y.compare(0) < 0) {
          throw new Error("Cannot calculate mod for a negative divisor");
        }
        return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
      }
    }, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo03xDSf,
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
  var name59 = "multiplyScalar";
  var dependencies60 = ["typed"];
  var createMultiplyScalar = /* @__PURE__ */ factory(name59, dependencies60, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("multiplyScalar", {
      "number, number": multiplyNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.mul(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.times(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.mul(y);
      },
      "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
      "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
  var name60 = "multiply";
  var dependencies61 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
  var createMultiply = /* @__PURE__ */ factory(name60, dependencies61, (_ref) => {
    var {
      typed,
      matrix,
      addScalar,
      multiplyScalar,
      equalScalar,
      dot
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    function _validateMatrixDimensions(size1, size2) {
      switch (size1.length) {
        case 1:
          switch (size2.length) {
            case 1:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
              }
              break;
            case 2:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        case 2:
          switch (size2.length) {
            case 1:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
              }
              break;
            case 2:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        default:
          throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
      }
    }
    function _multiplyVectorVector(a, b, n) {
      if (n === 0) {
        throw new Error("Cannot multiply two empty vectors");
      }
      return dot(a, b);
    }
    function _multiplyVectorMatrix(a, b) {
      if (b.storage() !== "dense") {
        throw new Error("Support for SparseMatrix not implemented");
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    function _multiplyVectorDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var alength = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var c = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(adata[0], bdata[0][j]);
        for (var i = 1; i < alength; i++) {
          sum2 = af(sum2, mf(adata[i], bdata[i][j]));
        }
        c[j] = sum2;
      }
      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: dt
      });
    }
    var _multiplyMatrixVector = typed("_multiplyMatrixVector", {
      "DenseMatrix, any": _multiplyDenseMatrixVector,
      "SparseMatrix, any": _multiplySparseMatrixVector
    });
    var _multiplyMatrixMatrix = typed("_multiplyMatrixMatrix", {
      "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
      "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
      "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
      "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
    });
    function _multiplyDenseMatrixVector(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        var sum2 = mf(row[0], bdata[0]);
        for (var j = 1; j < acolumns; j++) {
          sum2 = af(sum2, mf(row[j], bdata[j]));
        }
        c[i] = sum2;
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        c[i] = [];
        for (var j = 0; j < bcolumns; j++) {
          var sum2 = mf(row[0], bdata[0][j]);
          for (var x = 1; x < acolumns; x++) {
            sum2 = af(sum2, mf(row[x], bdata[x][j]));
          }
          c[i][j] = sum2;
        }
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixSparseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (!bvalues) {
        throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
      }
      var arows = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      var eq = equalScalar;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1];
        if (kb1 > kb0) {
          var last = 0;
          for (var i = 0; i < arows; i++) {
            var mark = i + 1;
            var cij = void 0;
            for (var kb = kb0; kb < kb1; kb++) {
              var ib = bindex[kb];
              if (last !== mark) {
                cij = mf(adata[i][ib], bvalues[kb]);
                last = mark;
              } else {
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            }
            if (last === mark && !eq(cij, zero)) {
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixVector(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      var eq = equalScalar;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
      }
      var x = [];
      var w = [];
      cptr[0] = 0;
      for (var ib = 0; ib < brows; ib++) {
        var vbi = bdata[ib];
        if (!eq(vbi, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (!w[ia]) {
              w[ia] = true;
              cindex.push(ia);
              x[ia] = mf(vbi, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      }
      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
      cptr[1] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: dt
      });
    }
    function _multiplySparseMatrixDenseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1];
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      var eq = equalScalar;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = [];
      var w = [];
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (var ib = 0; ib < brows; ib++) {
          var vbij = bdata[ib][jb];
          if (!eq(vbij, zero)) {
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              var ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(vbij, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        }
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixSparseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype;
      var arows = a._size[0];
      var bcolumns = b._size[1];
      var values2 = avalues && bvalues;
      var dt;
      var af = addScalar;
      var mf = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      }
      var cvalues = values2 ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = values2 ? [] : void 0;
      var w = [];
      var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          ib = bindex[kb];
          if (values2) {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
              }
            }
          }
        }
        if (values2) {
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    return typed(name60, multiplyScalar, {
      "Array, Array": typed.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
        _validateMatrixDimensions(arraySize(x), arraySize(y));
        var m = selfMM(matrix(x), matrix(y));
        return isMatrix(m) ? m.valueOf() : m;
      }),
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        var xsize = x.size();
        var ysize = y.size();
        _validateMatrixDimensions(xsize, ysize);
        if (xsize.length === 1) {
          if (ysize.length === 1) {
            return _multiplyVectorVector(x, y, xsize[0]);
          }
          return _multiplyVectorMatrix(x, y);
        }
        if (ysize.length === 1) {
          return _multiplyMatrixVector(x, y);
        }
        return _multiplyMatrixMatrix(x, y);
      },
      "Matrix, Array": typed.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix(y))),
      "Array, Matrix": typed.referToSelf((self2) => (x, y) => {
        return self2(matrix(x, y.storage()), y);
      }),
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return matAlgo11xS0s(x, y, multiplyScalar, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return matAlgo14xDs(x, y, multiplyScalar, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return matAlgo11xS0s(y, x, multiplyScalar, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return matAlgo14xDs(y, x, multiplyScalar, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();
      },
      "any, any": multiplyScalar,
      "any, any, ...any": typed.referToSelf((self2) => (x, y, rest) => {
        var result = self2(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = self2(result, rest[i]);
        }
        return result;
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
  var name61 = "nthRoot";
  var dependencies62 = ["typed", "matrix", "equalScalar", "BigNumber"];
  var createNthRoot = /* @__PURE__ */ factory(name61, dependencies62, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      BigNumber: _BigNumber
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    function complexErr() {
      throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
    }
    return typed(name61, {
      number: nthRootNumber,
      "number, number": nthRootNumber,
      BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
      "BigNumber, BigNumber": _bigNthRoot,
      Complex: complexErr,
      "Complex, number": complexErr,
      Array: typed.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix(x), 2).valueOf()),
      DenseMatrix: typed.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
      SparseMatrix: typed.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
      "SparseMatrix, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (y.density() === 1) {
          return matAlgo06xS0S0(x, y, self2);
        } else {
          throw new Error("Root must be non-zero");
        }
      }),
      "DenseMatrix, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (y.density() === 1) {
          return matAlgo01xDSid(x, y, self2, false);
        } else {
          throw new Error("Root must be non-zero");
        }
      }),
      "Array, SparseMatrix": typed.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix(x), y)),
      "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (y.density() === 1) {
          return matAlgo11xS0s(y, x, self2, true);
        } else {
          throw new Error("Root must be non-zero");
        }
      })
    }, matrixAlgorithmSuite({
      scalar: "number | BigNumber",
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: false
    }));
    function _bigNthRoot(a, root2) {
      var precision = _BigNumber.precision;
      var Big = _BigNumber.clone({
        precision: precision + 2
      });
      var zero = new _BigNumber(0);
      var one = new Big(1);
      var inv = root2.isNegative();
      if (inv) {
        root2 = root2.neg();
      }
      if (root2.isZero()) {
        throw new Error("Root must be non-zero");
      }
      if (a.isNegative() && !root2.abs().mod(2).equals(1)) {
        throw new Error("Root must be odd when a is negative.");
      }
      if (a.isZero()) {
        return inv ? new Big(Infinity) : 0;
      }
      if (!a.isFinite()) {
        return inv ? zero : a;
      }
      var x = a.abs().pow(one.div(root2));
      x = a.isNeg() ? x.neg() : x;
      return new _BigNumber((inv ? one.div(x) : x).toPrecision(precision));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sign.js
  var name62 = "sign";
  var dependencies63 = ["typed", "BigNumber", "Fraction", "complex"];
  var createSign = /* @__PURE__ */ factory(name62, dependencies63, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber,
      complex,
      Fraction: _Fraction
    } = _ref;
    return typed(name62, {
      number: signNumber,
      Complex: function Complex2(x) {
        return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x.cmp(0));
      },
      Fraction: function Fraction2(x) {
        return new _Fraction(x.s, 1);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true)),
      Unit: typed.referToSelf((self2) => (x) => {
        if (!x._isDerived() && x.units[0].unit.offset !== 0) {
          throw new TypeError("sign is ambiguous for units with offset");
        }
        return typed.find(self2, x.valueType())(x.value);
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
  var name63 = "sqrt";
  var dependencies64 = ["config", "typed", "Complex"];
  var createSqrt = /* @__PURE__ */ factory(name63, dependencies64, (_ref) => {
    var {
      config: config2,
      typed,
      Complex: Complex2
    } = _ref;
    return typed("sqrt", {
      number: _sqrtNumber,
      Complex: function Complex3(x) {
        return x.sqrt();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config2.predictable) {
          return x.sqrt();
        } else {
          return _sqrtNumber(x.toNumber());
        }
      },
      Unit: function Unit(x) {
        return x.pow(0.5);
      }
    });
    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config2.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex2(x, 0).sqrt();
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/square.js
  var name64 = "square";
  var dependencies65 = ["typed"];
  var createSquare = /* @__PURE__ */ factory(name64, dependencies65, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name64, {
      number: squareNumber,
      Complex: function Complex2(x) {
        return x.mul(x);
      },
      BigNumber: function BigNumber(x) {
        return x.times(x);
      },
      Fraction: function Fraction2(x) {
        return x.mul(x);
      },
      Unit: function Unit(x) {
        return x.pow(2);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
  var name65 = "subtract";
  var dependencies66 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
  var createSubtract = /* @__PURE__ */ factory(name65, dependencies66, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      addScalar,
      unaryMinus,
      DenseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name65, {
      "number, number": (x, y) => x - y,
      "Complex, Complex": (x, y) => x.sub(y),
      "BigNumber, BigNumber": (x, y) => x.minus(y),
      "Fraction, Fraction": (x, y) => x.sub(y),
      "Unit, Unit": typed.referToSelf((self2) => (x, y) => {
        if (x.value === null) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y)) {
          throw new Error("Units do not match");
        }
        var res = x.clone();
        res.value = typed.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
        res.fixPrefix = false;
        return res;
      })
    }, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo01xDSid,
      SD: matAlgo03xDSf,
      Ss: matAlgo12xSfs,
      sS: matAlgo10xSids
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
  var name66 = "xgcd";
  var dependencies67 = ["typed", "config", "matrix", "BigNumber"];
  var createXgcd = /* @__PURE__ */ factory(name66, dependencies67, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      BigNumber
    } = _ref;
    return typed(name66, {
      "number, number": function numberNumber(a, b) {
        var res = xgcdNumber(a, b);
        return config2.matrix === "Array" ? res : matrix(res);
      },
      "BigNumber, BigNumber": _xgcdBigNumber
    });
    function _xgcdBigNumber(a, b) {
      var t;
      var q;
      var r;
      var zero = new BigNumber(0);
      var one = new BigNumber(1);
      var x = zero;
      var lastx = one;
      var y = one;
      var lasty = zero;
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function xgcd must be integer numbers");
      }
      while (!b.isZero()) {
        q = a.div(b).floor();
        r = a.mod(b);
        t = x;
        x = lastx.minus(q.times(x));
        lastx = t;
        t = y;
        y = lasty.minus(q.times(y));
        lasty = t;
        a = b;
        b = r;
      }
      var res;
      if (a.lt(zero)) {
        res = [a.neg(), lastx.neg(), lasty.neg()];
      } else {
        res = [a, !a.isZero() ? lastx : 0, lasty];
      }
      return config2.matrix === "Array" ? res : matrix(res);
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
  var name67 = "invmod";
  var dependencies68 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
  var createInvmod = /* @__PURE__ */ factory(name67, dependencies68, (_ref) => {
    var {
      typed,
      config: config2,
      BigNumber,
      xgcd,
      equal,
      smaller,
      mod: mod2,
      add: add2,
      isInteger: isInteger2
    } = _ref;
    return typed(name67, {
      "number, number": invmod,
      "BigNumber, BigNumber": invmod
    });
    function invmod(a, b) {
      if (!isInteger2(a) || !isInteger2(b))
        throw new Error("Parameters in function invmod must be integer numbers");
      a = mod2(a, b);
      if (equal(b, 0))
        throw new Error("Divisor must be non zero");
      var res = xgcd(a, b);
      res = res.valueOf();
      var [gcd, inv] = res;
      if (!equal(gcd, BigNumber(1)))
        return NaN;
      inv = mod2(inv, b);
      if (smaller(inv, BigNumber(0)))
        inv = add2(inv, b);
      return inv;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
  var name68 = "matAlgo09xS0Sf";
  var dependencies69 = ["typed", "equalScalar"];
  var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name68, dependencies69, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo09xS0Sf(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var x = cvalues ? [] : void 0;
      var w = [];
      var i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        if (x) {
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i = bindex[k];
            w[i] = mark;
            x[i] = bvalues[k];
          }
        }
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          if (x) {
            var vb = w[i] === mark ? x[i] : zero;
            var vc = cf(avalues[k], vb);
            if (!eq(vc, zero)) {
              cindex.push(i);
              cvalues.push(vc);
            }
          } else {
            cindex.push(i);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
  var name69 = "dotMultiply";
  var dependencies70 = ["typed", "matrix", "equalScalar", "multiplyScalar"];
  var createDotMultiply = /* @__PURE__ */ factory(name69, dependencies70, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      multiplyScalar
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name69, matrixAlgorithmSuite({
      elop: multiplyScalar,
      SS: matAlgo09xS0Sf,
      DS: matAlgo02xDS0,
      Ss: matAlgo11xS0s
    }));
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
  function bitAndBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function bitAnd");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }
    if (x.isZero() || y.eq(-1) || x.eq(y)) {
      return x;
    }
    if (y.isZero() || x.eq(-1)) {
      return y;
    }
    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !y.isFinite()) {
        if (x.isNegative() === y.isNegative()) {
          return x;
        }
        return new BigNumber(0);
      }
      if (!x.isFinite()) {
        if (y.isNegative()) {
          return x;
        }
        if (x.isNegative()) {
          return new BigNumber(0);
        }
        return y;
      }
      if (!y.isFinite()) {
        if (x.isNegative()) {
          return y;
        }
        if (y.isNegative()) {
          return new BigNumber(0);
        }
        return x;
      }
    }
    return bitwise(x, y, function(a, b) {
      return a & b;
    });
  }
  function bitNotBigNumber(x) {
    if (x.isFinite() && !x.isInteger()) {
      throw new Error("Integer expected in function bitNot");
    }
    var BigNumber = x.constructor;
    var prevPrec = BigNumber.precision;
    BigNumber.config({
      precision: 1e9
    });
    var result = x.plus(new BigNumber(1));
    result.s = -result.s || null;
    BigNumber.config({
      precision: prevPrec
    });
    return result;
  }
  function bitOrBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function bitOr");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }
    var negOne = new BigNumber(-1);
    if (x.isZero() || y.eq(negOne) || x.eq(y)) {
      return y;
    }
    if (y.isZero() || x.eq(negOne)) {
      return x;
    }
    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
        return negOne;
      }
      if (x.isNegative() && y.isNegative()) {
        return x.isFinite() ? x : y;
      }
      return x.isFinite() ? y : x;
    }
    return bitwise(x, y, function(a, b) {
      return a | b;
    });
  }
  function bitwise(x, y, func) {
    var BigNumber = x.constructor;
    var xBits, yBits;
    var xSign = +(x.s < 0);
    var ySign = +(y.s < 0);
    if (xSign) {
      xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
      for (var i = 0; i < xBits.length; ++i) {
        xBits[i] ^= 1;
      }
    } else {
      xBits = decCoefficientToBinaryString(x);
    }
    if (ySign) {
      yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
      for (var _i = 0; _i < yBits.length; ++_i) {
        yBits[_i] ^= 1;
      }
    } else {
      yBits = decCoefficientToBinaryString(y);
    }
    var minBits, maxBits, minSign;
    if (xBits.length <= yBits.length) {
      minBits = xBits;
      maxBits = yBits;
      minSign = xSign;
    } else {
      minBits = yBits;
      maxBits = xBits;
      minSign = ySign;
    }
    var shortLen = minBits.length;
    var longLen = maxBits.length;
    var expFuncVal = func(xSign, ySign) ^ 1;
    var outVal = new BigNumber(expFuncVal ^ 1);
    var twoPower = new BigNumber(1);
    var two = new BigNumber(2);
    var prevPrec = BigNumber.precision;
    BigNumber.config({
      precision: 1e9
    });
    while (shortLen > 0) {
      if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    while (longLen > 0) {
      if (func(minSign, maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    BigNumber.config({
      precision: prevPrec
    });
    if (expFuncVal === 0) {
      outVal.s = -outVal.s;
    }
    return outVal;
  }
  function decCoefficientToBinaryString(x) {
    var a = x.d;
    var r = a[0] + "";
    for (var i = 1; i < a.length; ++i) {
      var s = a[i] + "";
      for (var z = 7 - s.length; z--; ) {
        s = "0" + s;
      }
      r += s;
    }
    var j = r.length;
    while (r.charAt(j) === "0") {
      j--;
    }
    var xe = x.e;
    var str = r.slice(0, j + 1 || 1);
    var strL = str.length;
    if (xe > 0) {
      if (++xe > strL) {
        xe -= strL;
        while (xe--) {
          str += "0";
        }
      } else if (xe < strL) {
        str = str.slice(0, xe) + "." + str.slice(xe);
      }
    }
    var arr = [0];
    for (var _i2 = 0; _i2 < str.length; ) {
      var arrL = arr.length;
      while (arrL--) {
        arr[arrL] *= 10;
      }
      arr[0] += parseInt(str.charAt(_i2++));
      for (var _j = 0; _j < arr.length; ++_j) {
        if (arr[_j] > 1) {
          if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
            arr[_j + 1] = 0;
          }
          arr[_j + 1] += arr[_j] >> 1;
          arr[_j] &= 1;
        }
      }
    }
    return arr.reverse();
  }
  function bitXor(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function bitXor");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN()) {
      return new BigNumber(NaN);
    }
    if (x.isZero()) {
      return y;
    }
    if (y.isZero()) {
      return x;
    }
    if (x.eq(y)) {
      return new BigNumber(0);
    }
    var negOne = new BigNumber(-1);
    if (x.eq(negOne)) {
      return bitNotBigNumber(y);
    }
    if (y.eq(negOne)) {
      return bitNotBigNumber(x);
    }
    if (!x.isFinite() || !y.isFinite()) {
      if (!x.isFinite() && !y.isFinite()) {
        return negOne;
      }
      return new BigNumber(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
    }
    return bitwise(x, y, function(a, b) {
      return a ^ b;
    });
  }
  function leftShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function leftShift");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
      return new BigNumber(NaN);
    }
    if (x.isZero() || y.isZero()) {
      return x;
    }
    if (!x.isFinite() && !y.isFinite()) {
      return new BigNumber(NaN);
    }
    if (y.lt(55)) {
      return x.times(Math.pow(2, y.toNumber()) + "");
    }
    return x.times(new BigNumber(2).pow(y));
  }
  function rightArithShiftBigNumber(x, y) {
    if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
      throw new Error("Integers expected in function rightArithShift");
    }
    var BigNumber = x.constructor;
    if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
      return new BigNumber(NaN);
    }
    if (x.isZero() || y.isZero()) {
      return x;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return new BigNumber(-1);
      }
      if (!x.isFinite()) {
        return new BigNumber(NaN);
      }
      return new BigNumber(0);
    }
    if (y.lt(55)) {
      return x.div(Math.pow(2, y.toNumber()) + "").floor();
    }
    return x.div(new BigNumber(2).pow(y)).floor();
  }

  // node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
  var name70 = "bitAnd";
  var dependencies71 = ["typed", "matrix", "equalScalar"];
  var createBitAnd = /* @__PURE__ */ factory(name70, dependencies71, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name70, {
      "number, number": bitAndNumber,
      "BigNumber, BigNumber": bitAndBigNumber
    }, matrixAlgorithmSuite({
      SS: matAlgo06xS0S0,
      DS: matAlgo02xDS0,
      Ss: matAlgo11xS0s
    }));
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
  var name71 = "bitNot";
  var dependencies72 = ["typed"];
  var createBitNot = /* @__PURE__ */ factory(name71, dependencies72, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name71, {
      number: bitNotNumber,
      BigNumber: bitNotBigNumber,
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
  var name72 = "bitOr";
  var dependencies73 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createBitOr = /* @__PURE__ */ factory(name72, dependencies73, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo04xSidSid = createMatAlgo04xSidSid({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name72, {
      "number, number": bitOrNumber,
      "BigNumber, BigNumber": bitOrBigNumber
    }, matrixAlgorithmSuite({
      SS: matAlgo04xSidSid,
      DS: matAlgo01xDSid,
      Ss: matAlgo10xSids
    }));
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
  var name73 = "matAlgo07xSSf";
  var dependencies74 = ["typed", "DenseMatrix"];
  var createMatAlgo07xSSf = /* @__PURE__ */ factory(name73, dependencies74, (_ref) => {
    var {
      typed,
      DenseMatrix
    } = _ref;
    return function matAlgo07xSSf(a, b, callback) {
      var asize = a._size;
      var adt = a._datatype;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var i, j;
      var cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      var xa = [];
      var xb = [];
      var wa = [];
      var wb = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        _scatter(a, j, wa, xa, mark);
        _scatter(b, j, wb, xb, mark);
        for (i = 0; i < rows; i++) {
          var va = wa[i] === mark ? xa[i] : zero;
          var vb = wb[i] === mark ? xb[i] : zero;
          cdata[i][j] = cf(va, vb);
        }
      }
      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
    function _scatter(m, j, w, x, mark) {
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        var i = index[k];
        w[i] = mark;
        x[i] = values2[k];
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
  var name74 = "bitXor";
  var dependencies75 = ["typed", "matrix", "DenseMatrix"];
  var createBitXor = /* @__PURE__ */ factory(name74, dependencies75, (_ref) => {
    var {
      typed,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name74, {
      "number, number": bitXorNumber,
      "BigNumber, BigNumber": bitXor
    }, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/complex/arg.js
  var name75 = "arg";
  var dependencies76 = ["typed"];
  var createArg = /* @__PURE__ */ factory(name75, dependencies76, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name75, {
      number: function number(x) {
        return Math.atan2(0, x);
      },
      BigNumber: function BigNumber(x) {
        return x.constructor.atan2(0, x);
      },
      Complex: function Complex2(x) {
        return x.arg();
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/conj.js
  var name76 = "conj";
  var dependencies77 = ["typed"];
  var createConj = /* @__PURE__ */ factory(name76, dependencies77, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name76, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.conjugate(),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/im.js
  var name77 = "im";
  var dependencies78 = ["typed"];
  var createIm = /* @__PURE__ */ factory(name77, dependencies78, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name77, {
      number: () => 0,
      "BigNumber | Fraction": (x) => x.mul(0),
      Complex: (x) => x.im,
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/re.js
  var name78 = "re";
  var dependencies79 = ["typed"];
  var createRe = /* @__PURE__ */ factory(name78, dependencies79, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name78, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.re,
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/not.js
  var name79 = "not";
  var dependencies80 = ["typed"];
  var createNot = /* @__PURE__ */ factory(name79, dependencies80, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name79, {
      "null | undefined": () => true,
      number: notNumber,
      Complex: function Complex2(x) {
        return x.re === 0 && x.im === 0;
      },
      BigNumber: function BigNumber(x) {
        return x.isZero() || x.isNaN();
      },
      Unit: typed.referToSelf((self2) => (x) => typed.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/or.js
  var name80 = "or";
  var dependencies81 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createOr = /* @__PURE__ */ factory(name80, dependencies81, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name80, {
      "number, number": orNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
      },
      "Unit, Unit": typed.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
    }, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/logical/xor.js
  var name81 = "xor";
  var dependencies82 = ["typed", "matrix", "DenseMatrix"];
  var createXor = /* @__PURE__ */ factory(name81, dependencies82, (_ref) => {
    var {
      typed,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name81, {
      "number, number": xorNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
      },
      "Unit, Unit": typed.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
    }, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/matrix/concat.js
  var name82 = "concat";
  var dependencies83 = ["typed", "matrix", "isInteger"];
  var createConcat = /* @__PURE__ */ factory(name82, dependencies83, (_ref) => {
    var {
      typed,
      matrix,
      isInteger: isInteger2
    } = _ref;
    return typed(name82, {
      "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
        var i;
        var len = args.length;
        var dim = -1;
        var prevDim;
        var asMatrix = false;
        var matrices = [];
        for (i = 0; i < len; i++) {
          var arg = args[i];
          if (isMatrix(arg)) {
            asMatrix = true;
          }
          if (isNumber(arg) || isBigNumber(arg)) {
            if (i !== len - 1) {
              throw new Error("Dimension must be specified as last argument");
            }
            prevDim = dim;
            dim = arg.valueOf();
            if (!isInteger2(dim)) {
              throw new TypeError("Integer number expected for dimension");
            }
            if (dim < 0 || i > 0 && dim > prevDim) {
              throw new IndexError(dim, prevDim + 1);
            }
          } else {
            var m = clone(arg).valueOf();
            var size = arraySize(m);
            matrices[i] = m;
            prevDim = dim;
            dim = size.length - 1;
            if (i > 0 && dim !== prevDim) {
              throw new DimensionError(prevDim + 1, dim + 1);
            }
          }
        }
        if (matrices.length === 0) {
          throw new SyntaxError("At least one matrix expected");
        }
        var res = matrices.shift();
        while (matrices.length) {
          res = _concat(res, matrices.shift(), dim, 0);
        }
        return asMatrix ? matrix(res) : res;
      },
      "...string": function string(args) {
        return args.join("");
      }
    });
  });
  function _concat(a, b, concatDim, dim) {
    if (dim < concatDim) {
      if (a.length !== b.length) {
        throw new DimensionError(a.length, b.length);
      }
      var c = [];
      for (var i = 0; i < a.length; i++) {
        c[i] = _concat(a[i], b[i], concatDim, dim + 1);
      }
      return c;
    } else {
      return a.concat(b);
    }
  }

  // node_modules/mathjs/lib/esm/function/matrix/column.js
  var name83 = "column";
  var dependencies84 = ["typed", "Index", "matrix", "range"];
  var createColumn = /* @__PURE__ */ factory(name83, dependencies84, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    return typed(name83, {
      "Matrix, number": _column,
      "Array, number": function ArrayNumber(value, column) {
        return _column(matrix(clone(value)), column).valueOf();
      }
    });
    function _column(value, column) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(column, value.size()[1]);
      var rowRange = range(0, value.size()[0]);
      var index = new Index(rowRange, column);
      return value.subset(index);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/count.js
  var name84 = "count";
  var dependencies85 = ["typed", "size", "prod"];
  var createCount = /* @__PURE__ */ factory(name84, dependencies85, (_ref) => {
    var {
      typed,
      size,
      prod
    } = _ref;
    return typed(name84, {
      string: function string(x) {
        return x.length;
      },
      "Matrix | Array": function MatrixArray(x) {
        return prod(size(x));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/cross.js
  var name85 = "cross";
  var dependencies86 = ["typed", "matrix", "subtract", "multiply"];
  var createCross = /* @__PURE__ */ factory(name85, dependencies86, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      multiply
    } = _ref;
    return typed(name85, {
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        return matrix(_cross(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return matrix(_cross(x.toArray(), y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return matrix(_cross(x, y.toArray()));
      },
      "Array, Array": _cross
    });
    function _cross(x, y) {
      var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
      x = squeeze(x);
      y = squeeze(y);
      var xSize = arraySize(x);
      var ySize = arraySize(y);
      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
      }
      var product3 = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
      if (highestDimension > 1) {
        return [product3];
      } else {
        return product3;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/diag.js
  var name86 = "diag";
  var dependencies87 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
  var createDiag = /* @__PURE__ */ factory(name86, dependencies87, (_ref) => {
    var {
      typed,
      matrix,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    return typed(name86, {
      Array: function Array2(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      "Array, number": function ArrayNumber(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      "Array, BigNumber": function ArrayBigNumber(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      "Array, string": function ArrayString(x, format4) {
        return _diag(x, 0, arraySize(x), format4);
      },
      "Array, number, string": function ArrayNumberString(x, k, format4) {
        return _diag(x, k, arraySize(x), format4);
      },
      "Array, BigNumber, string": function ArrayBigNumberString(x, k, format4) {
        return _diag(x, k.toNumber(), arraySize(x), format4);
      },
      Matrix: function Matrix(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      "Matrix, number": function MatrixNumber(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      "Matrix, BigNumber": function MatrixBigNumber(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      "Matrix, string": function MatrixString(x, format4) {
        return _diag(x, 0, x.size(), format4);
      },
      "Matrix, number, string": function MatrixNumberString(x, k, format4) {
        return _diag(x, k, x.size(), format4);
      },
      "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format4) {
        return _diag(x, k.toNumber(), x.size(), format4);
      }
    });
    function _diag(x, k, size, format4) {
      if (!isInteger(k)) {
        throw new TypeError("Second parameter in function diag must be an integer");
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      switch (size.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format4, size[0], kSub, kSuper);
        case 2:
          return _getDiagonal(x, k, format4, size, kSub, kSuper);
      }
      throw new RangeError("Matrix for function diag must be 2 dimensional");
    }
    function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
      var ms = [l + kSub, l + kSuper];
      if (format4 && format4 !== "sparse" && format4 !== "dense") {
        throw new TypeError("Unknown matrix type ".concat(format4, '"'));
      }
      var m = format4 === "sparse" ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);
      return format4 !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format4, s, kSub, kSuper) {
      if (isMatrix(x)) {
        var dm = x.diagonal(k);
        if (format4 !== null) {
          if (format4 !== dm.storage()) {
            return matrix(dm, format4);
          }
          return dm;
        }
        return dm.valueOf();
      }
      var n = Math.min(s[0] - kSub, s[1] - kSuper);
      var vector = [];
      for (var i = 0; i < n; i++) {
        vector[i] = x[i + kSub][i + kSuper];
      }
      return format4 !== null ? matrix(vector) : vector;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/filter.js
  var name87 = "filter";
  var dependencies88 = ["typed"];
  var createFilter = /* @__PURE__ */ factory(name87, dependencies88, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("filter", {
      "Array, function": _filterCallback,
      "Matrix, function": function MatrixFunction(x, test) {
        return x.create(_filterCallback(x.toArray(), test));
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
  });
  function _filterCallback(x, callback) {
    var args = maxArgumentCount(callback);
    return filter(x, function(value, index, array) {
      if (args === 1) {
        return callback(value);
      } else if (args === 2) {
        return callback(value, [index]);
      } else {
        return callback(value, [index], array);
      }
    });
  }

  // node_modules/mathjs/lib/esm/function/matrix/flatten.js
  var name88 = "flatten";
  var dependencies89 = ["typed", "matrix"];
  var createFlatten = /* @__PURE__ */ factory(name88, dependencies89, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name88, {
      Array: function Array2(x) {
        return flatten(x);
      },
      Matrix: function Matrix(x) {
        var flat = flatten(x.toArray());
        return matrix(flat);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/forEach.js
  var name89 = "forEach";
  var dependencies90 = ["typed"];
  var createForEach = /* @__PURE__ */ factory(name89, dependencies90, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name89, {
      "Array, function": _forEach,
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.forEach(callback);
      }
    });
  });
  function _forEach(array, callback) {
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index) {
      if (Array.isArray(value)) {
        forEach(value, function(child, i) {
          recurse2(child, index.concat(i));
        });
      } else {
        if (args === 1) {
          callback(value);
        } else if (args === 2) {
          callback(value, index);
        } else {
          callback(value, index, array);
        }
      }
    };
    recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
  var name90 = "getMatrixDataType";
  var dependencies91 = ["typed"];
  var createGetMatrixDataType = /* @__PURE__ */ factory(name90, dependencies91, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name90, {
      Array: function Array2(x) {
        return getArrayDataType(x, typeOf);
      },
      Matrix: function Matrix(x) {
        return x.getDataType();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/identity.js
  var name91 = "identity";
  var dependencies92 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
  var createIdentity = /* @__PURE__ */ factory(name91, dependencies92, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      BigNumber,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    return typed(name91, {
      "": function _() {
        return config2.matrix === "Matrix" ? matrix([]) : [];
      },
      string: function string(format4) {
        return matrix(format4);
      },
      "number | BigNumber": function numberBigNumber(rows) {
        return _identity(rows, rows, config2.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, string": function numberBigNumberString(rows, format4) {
        return _identity(rows, rows, format4);
      },
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
        return _identity(rows, cols, config2.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format4) {
        return _identity(rows, cols, format4);
      },
      Array: function Array2(size) {
        return _identityVector(size);
      },
      "Array, string": function ArrayString(size, format4) {
        return _identityVector(size, format4);
      },
      Matrix: function Matrix(size) {
        return _identityVector(size.valueOf(), size.storage());
      },
      "Matrix, string": function MatrixString(size, format4) {
        return _identityVector(size.valueOf(), format4);
      }
    });
    function _identityVector(size, format4) {
      switch (size.length) {
        case 0:
          return format4 ? matrix(format4) : [];
        case 1:
          return _identity(size[0], size[0], format4);
        case 2:
          return _identity(size[0], size[1], format4);
        default:
          throw new Error("Vector containing two values expected");
      }
    }
    function _identity(rows, cols, format4) {
      var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
      if (isBigNumber(rows))
        rows = rows.toNumber();
      if (isBigNumber(cols))
        cols = cols.toNumber();
      if (!isInteger(rows) || rows < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      if (!isInteger(cols) || cols < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      var one = Big ? new BigNumber(1) : 1;
      var defaultValue = Big ? new Big(0) : 0;
      var size = [rows, cols];
      if (format4) {
        if (format4 === "sparse") {
          return SparseMatrix.diagonal(size, one, 0, defaultValue);
        }
        if (format4 === "dense") {
          return DenseMatrix.diagonal(size, one, 0, defaultValue);
        }
        throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
      }
      var res = resize([], size, defaultValue);
      var minimum = rows < cols ? rows : cols;
      for (var d = 0; d < minimum; d++) {
        res[d][d] = one;
      }
      return res;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/kron.js
  var name92 = "kron";
  var dependencies93 = ["typed", "matrix", "multiplyScalar"];
  var createKron = /* @__PURE__ */ factory(name92, dependencies93, (_ref) => {
    var {
      typed,
      matrix,
      multiplyScalar
    } = _ref;
    return typed(name92, {
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        return matrix(_kron(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return matrix(_kron(x.toArray(), y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return matrix(_kron(x, y.toArray()));
      },
      "Array, Array": _kron
    });
    function _kron(a, b) {
      if (arraySize(a).length === 1) {
        a = [a];
      }
      if (arraySize(b).length === 1) {
        b = [b];
      }
      if (arraySize(a).length > 2 || arraySize(b).length > 2) {
        throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
      }
      var t = [];
      var r = [];
      return a.map(function(a2) {
        return b.map(function(b2) {
          r = [];
          t.push(r);
          return a2.map(function(y) {
            return b2.map(function(x) {
              return r.push(multiplyScalar(y, x));
            });
          });
        });
      }) && t;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/map.js
  var name93 = "map";
  var dependencies94 = ["typed"];
  var createMap2 = /* @__PURE__ */ factory(name93, dependencies94, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name93, {
      "Array, function": _map,
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.map(callback);
      }
    });
  });
  function _map(array, callback) {
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index) {
      if (Array.isArray(value)) {
        return value.map(function(child, i) {
          return recurse2(child, index.concat(i));
        });
      } else {
        try {
          if (args === 1) {
            return callback(value);
          } else if (args === 2) {
            return callback(value, index);
          } else {
            return callback(value, index, array);
          }
        } catch (err) {
          if (err instanceof TypeError && "data" in err && err.data.category === "wrongType") {
            var newmsg = "map attempted to call '".concat(err.data.fn, "(").concat(value);
            var indexString = JSON.stringify(index);
            if (args === 2) {
              newmsg += "," + indexString;
            } else if (args !== 1) {
              newmsg += ",".concat(indexString, ",").concat(array);
            }
            newmsg += ")' but argument ".concat(err.data.index + 1, " of type ");
            newmsg += "".concat(err.data.actual, " does not match expected type ");
            newmsg += err.data.expected.join(" or ");
            throw new TypeError(newmsg);
          }
          throw err;
        }
      }
    };
    return recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/function/matrix/diff.js
  var name94 = "diff";
  var dependencies95 = ["typed", "matrix", "subtract", "number"];
  var createDiff = /* @__PURE__ */ factory(name94, dependencies95, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      number
    } = _ref;
    return typed(name94, {
      "Array | Matrix": function ArrayMatrix(arr) {
        if (isMatrix(arr)) {
          return matrix(_diff(arr.toArray()));
        } else {
          return _diff(arr);
        }
      },
      "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
        if (!isInteger(dim))
          throw new RangeError("Dimension must be a whole number");
        if (isMatrix(arr)) {
          return matrix(_recursive(arr.toArray(), dim));
        } else {
          return _recursive(arr, dim);
        }
      },
      "Array, BigNumber": typed.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number(dim))),
      "Matrix, BigNumber": typed.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number(dim)))
    });
    function _recursive(arr, dim) {
      if (isMatrix(arr)) {
        arr = arr.toArray();
      }
      if (!Array.isArray(arr)) {
        throw RangeError("Array/Matrix does not have that many dimensions");
      }
      if (dim > 0) {
        var result = [];
        arr.forEach((element) => {
          result.push(_recursive(element, dim - 1));
        });
        return result;
      } else if (dim === 0) {
        return _diff(arr);
      } else {
        throw RangeError("Cannot have negative dimension");
      }
    }
    function _diff(arr) {
      var result = [];
      var size = arr.length;
      for (var i = 1; i < size; i++) {
        result.push(_ElementDiff(arr[i - 1], arr[i]));
      }
      return result;
    }
    function _ElementDiff(obj1, obj2) {
      if (isMatrix(obj1))
        obj1 = obj1.toArray();
      if (isMatrix(obj2))
        obj2 = obj2.toArray();
      var obj1IsArray = Array.isArray(obj1);
      var obj2IsArray = Array.isArray(obj2);
      if (obj1IsArray && obj2IsArray) {
        return _ArrayDiff(obj1, obj2);
      }
      if (!obj1IsArray && !obj2IsArray) {
        return subtract(obj2, obj1);
      }
      throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
    }
    function _ArrayDiff(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        throw RangeError("Not all sub-arrays have the same length");
      }
      var result = [];
      var size = arr1.length;
      for (var i = 0; i < size; i++) {
        result.push(_ElementDiff(arr1[i], arr2[i]));
      }
      return result;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ones.js
  var name95 = "ones";
  var dependencies96 = ["typed", "config", "matrix", "BigNumber"];
  var createOnes = /* @__PURE__ */ factory(name95, dependencies96, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      BigNumber
    } = _ref;
    return typed("ones", {
      "": function _() {
        return config2.matrix === "Array" ? _ones([]) : _ones([], "default");
      },
      "...number | BigNumber | string": function numberBigNumberString(size) {
        var last = size[size.length - 1];
        if (typeof last === "string") {
          var format4 = size.pop();
          return _ones(size, format4);
        } else if (config2.matrix === "Array") {
          return _ones(size);
        } else {
          return _ones(size, "default");
        }
      },
      Array: _ones,
      Matrix: function Matrix(size) {
        var format4 = size.storage();
        return _ones(size.valueOf(), format4);
      },
      "Array | Matrix, string": function ArrayMatrixString(size, format4) {
        return _ones(size.valueOf(), format4);
      }
    });
    function _ones(size, format4) {
      var hasBigNumbers = _normalize(size);
      var defaultValue = hasBigNumbers ? new BigNumber(1) : 1;
      _validate2(size);
      if (format4) {
        var m = matrix(format4);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size) {
      size.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function ones must be positive integers");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/noop.js
  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  // node_modules/mathjs/lib/esm/function/matrix/range.js
  var name96 = "range";
  var dependencies97 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
  var createRange = /* @__PURE__ */ factory(name96, dependencies97, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    } = _ref;
    return typed(name96, {
      string: _strRange,
      "string, boolean": _strRange,
      "number, number": function numberNumber(start, end) {
        return _out(_rangeEx(start, end, 1));
      },
      "number, number, number": function numberNumberNumber(start, end, step) {
        return _out(_rangeEx(start, end, step));
      },
      "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
      },
      "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
        var BigNumber = start.constructor;
        return _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
        return _out(_bigRangeEx(start, end, step));
      },
      "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
        var BigNumber = start.constructor;
        return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
      }
    });
    function _out(arr) {
      if (config2.matrix === "Matrix") {
        return matrix ? matrix(arr) : noMatrix();
      }
      return arr;
    }
    function _strRange(str, includeEnd) {
      var r = _parse(str);
      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }
      var fn;
      if (config2.number === "BigNumber") {
        if (bignumber === void 0) {
          noBignumber();
        }
        fn = includeEnd ? _bigRangeInc : _bigRangeEx;
        return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
      } else {
        fn = includeEnd ? _rangeInc : _rangeEx;
        return _out(fn(r.start, r.end, r.step));
      }
    }
    function _rangeEx(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smaller(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (larger(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    function _rangeInc(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smallerEq(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (largerEq(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    function _bigRangeEx(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smaller(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (larger(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    function _bigRangeInc(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smallerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (largerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    function _parse(str) {
      var args = str.split(":");
      var nums = args.map(function(arg) {
        return Number(arg);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };
        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };
        default:
          return null;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/reshape.js
  var name97 = "reshape";
  var dependencies98 = ["typed", "isInteger", "matrix"];
  var createReshape = /* @__PURE__ */ factory(name97, dependencies98, (_ref) => {
    var {
      typed,
      isInteger: isInteger2
    } = _ref;
    return typed(name97, {
      "Matrix, Array": function MatrixArray(x, sizes) {
        return x.reshape(sizes);
      },
      "Array, Array": function ArrayArray(x, sizes) {
        sizes.forEach(function(size) {
          if (!isInteger2(size)) {
            throw new TypeError("Invalid size for dimension: " + size);
          }
        });
        return reshape(x, sizes);
      }
    });
  });

  // node_modules/mathjs/lib/esm/error/ArgumentsError.js
  function ArgumentsError(fn, count, min2, max2) {
    if (!(this instanceof ArgumentsError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.fn = fn;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min2 + (max2 !== void 0 && max2 !== null ? "-" + max2 : "") + " expected)";
    this.stack = new Error().stack;
  }
  ArgumentsError.prototype = new Error();
  ArgumentsError.prototype.constructor = Error;
  ArgumentsError.prototype.name = "ArgumentsError";
  ArgumentsError.prototype.isArgumentsError = true;

  // node_modules/mathjs/lib/esm/function/matrix/resize.js
  var name98 = "resize";
  var dependencies99 = ["config", "matrix"];
  var createResize = /* @__PURE__ */ factory(name98, dependencies99, (_ref) => {
    var {
      config: config2,
      matrix
    } = _ref;
    return function resize2(x, size, defaultValue) {
      if (arguments.length !== 2 && arguments.length !== 3) {
        throw new ArgumentsError("resize", arguments.length, 2, 3);
      }
      if (isMatrix(size)) {
        size = size.valueOf();
      }
      if (isBigNumber(size[0])) {
        size = size.map(function(value) {
          return !isBigNumber(value) ? value : value.toNumber();
        });
      }
      if (isMatrix(x)) {
        return x.resize(size, defaultValue, true);
      }
      if (typeof x === "string") {
        return _resizeString(x, size, defaultValue);
      }
      var asMatrix = Array.isArray(x) ? false : config2.matrix !== "Array";
      if (size.length === 0) {
        while (Array.isArray(x)) {
          x = x[0];
        }
        return clone(x);
      } else {
        if (!Array.isArray(x)) {
          x = [x];
        }
        x = clone(x);
        var res = resize(x, size, defaultValue);
        return asMatrix ? matrix(res) : res;
      }
    };
    function _resizeString(str, size, defaultChar) {
      if (defaultChar !== void 0) {
        if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
          throw new TypeError("Single character expected as defaultValue");
        }
      } else {
        defaultChar = " ";
      }
      if (size.length !== 1) {
        throw new DimensionError(size.length, 1);
      }
      var len = size[0];
      if (typeof len !== "number" || !isInteger(len)) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size) + ")");
      }
      if (str.length > len) {
        return str.substring(0, len);
      } else if (str.length < len) {
        var res = str;
        for (var i = 0, ii = len - str.length; i < ii; i++) {
          res += defaultChar;
        }
        return res;
      } else {
        return str;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotate.js
  var name99 = "rotate";
  var dependencies100 = ["typed", "multiply", "rotationMatrix"];
  var createRotate = /* @__PURE__ */ factory(name99, dependencies100, (_ref) => {
    var {
      typed,
      multiply,
      rotationMatrix
    } = _ref;
    return typed(name99, {
      "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
        _validateSize(w, 2);
        var matrixRes = multiply(rotationMatrix(theta), w);
        return matrixRes.toArray();
      },
      "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
        _validateSize(w, 2);
        return multiply(rotationMatrix(theta), w);
      },
      "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
        _validateSize(w, 3);
        var matrixRes = multiply(rotationMatrix(theta, v), w);
        return matrixRes;
      },
      "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
        _validateSize(w, 3);
        return multiply(rotationMatrix(theta, v), w);
      }
    });
    function _validateSize(v, expectedSize) {
      var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
      if (actualSize.length > 2) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
      if (actualSize.length === 2 && actualSize[1] !== 1) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
      if (actualSize[0] !== expectedSize) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
  var name100 = "rotationMatrix";
  var dependencies101 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
  var createRotationMatrix = /* @__PURE__ */ factory(name100, dependencies101, (_ref) => {
    var {
      typed,
      config: config2,
      multiplyScalar,
      addScalar,
      unaryMinus,
      norm,
      BigNumber,
      matrix,
      DenseMatrix,
      SparseMatrix,
      cos: cos2,
      sin: sin2
    } = _ref;
    return typed(name100, {
      "": function _() {
        return config2.matrix === "Matrix" ? matrix([]) : [];
      },
      string: function string(format4) {
        return matrix(format4);
      },
      "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
        return _rotationMatrix2x2(theta, config2.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format4) {
        return _rotationMatrix2x2(theta, format4);
      },
      "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
        var matrixV = matrix(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, void 0);
      },
      "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
        _validateVector(v);
        var storageType = v.storage() || (config2.matrix === "Matrix" ? "dense" : void 0);
        return _rotationMatrix3x3(theta, v, storageType);
      },
      "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format4) {
        var matrixV = matrix(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, format4);
      },
      "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format4) {
        _validateVector(v);
        return _rotationMatrix3x3(theta, v, format4);
      }
    });
    function _rotationMatrix2x2(theta, format4) {
      var Big = isBigNumber(theta);
      var minusOne = Big ? new BigNumber(-1) : -1;
      var cosTheta = cos2(theta);
      var sinTheta = sin2(theta);
      var data = [[cosTheta, multiplyScalar(minusOne, sinTheta)], [sinTheta, cosTheta]];
      return _convertToFormat(data, format4);
    }
    function _validateVector(v) {
      var size = v.size();
      if (size.length < 1 || size[0] !== 3) {
        throw new RangeError("Vector must be of dimensions 1x3");
      }
    }
    function _mul(array) {
      return array.reduce((p, curr) => multiplyScalar(p, curr));
    }
    function _convertToFormat(data, format4) {
      if (format4) {
        if (format4 === "sparse") {
          return new SparseMatrix(data);
        }
        if (format4 === "dense") {
          return new DenseMatrix(data);
        }
        throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
      }
      return data;
    }
    function _rotationMatrix3x3(theta, v, format4) {
      var normV = norm(v);
      if (normV === 0) {
        throw new RangeError("Rotation around zero vector");
      }
      var Big = isBigNumber(theta) ? BigNumber : null;
      var one = Big ? new Big(1) : 1;
      var minusOne = Big ? new Big(-1) : -1;
      var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
      var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
      var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
      var c = cos2(theta);
      var oneMinusC = addScalar(one, unaryMinus(c));
      var s = sin2(theta);
      var r11 = addScalar(c, _mul([vx, vx, oneMinusC]));
      var r12 = addScalar(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
      var r13 = addScalar(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
      var r21 = addScalar(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
      var r22 = addScalar(c, _mul([vy, vy, oneMinusC]));
      var r23 = addScalar(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
      var r31 = addScalar(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
      var r32 = addScalar(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
      var r33 = addScalar(c, _mul([vz, vz, oneMinusC]));
      var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
      return _convertToFormat(data, format4);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/row.js
  var name101 = "row";
  var dependencies102 = ["typed", "Index", "matrix", "range"];
  var createRow = /* @__PURE__ */ factory(name101, dependencies102, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    return typed(name101, {
      "Matrix, number": _row,
      "Array, number": function ArrayNumber(value, row) {
        return _row(matrix(clone(value)), row).valueOf();
      }
    });
    function _row(value, row) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(row, value.size()[0]);
      var columnRange = range(0, value.size()[1]);
      var index = new Index(row, columnRange);
      return value.subset(index);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/size.js
  var name102 = "size";
  var dependencies103 = ["typed", "config", "?matrix"];
  var createSize = /* @__PURE__ */ factory(name102, dependencies103, (_ref) => {
    var {
      typed,
      config: config2,
      matrix
    } = _ref;
    return typed(name102, {
      Matrix: function Matrix(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string(x) {
        return config2.matrix === "Array" ? [x.length] : matrix([x.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
        return config2.matrix === "Array" ? [] : matrix ? matrix([]) : noMatrix();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/squeeze.js
  var name103 = "squeeze";
  var dependencies104 = ["typed", "matrix"];
  var createSqueeze = /* @__PURE__ */ factory(name103, dependencies104, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name103, {
      Array: function Array2(x) {
        return squeeze(clone(x));
      },
      Matrix: function Matrix(x) {
        var res = squeeze(x.toArray());
        return Array.isArray(res) ? matrix(res) : res;
      },
      any: function any(x) {
        return clone(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/subset.js
  var name104 = "subset";
  var dependencies105 = ["typed", "matrix"];
  var createSubset = /* @__PURE__ */ factory(name104, dependencies105, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name104, {
      "Array, Index": function ArrayIndex(value, index) {
        var m = matrix(value);
        var subset = m.subset(index);
        return index.isScalar() ? subset : subset.valueOf();
      },
      "Matrix, Index": function MatrixIndex(value, index) {
        return value.subset(index);
      },
      "Object, Index": _getObjectProperty,
      "string, Index": _getSubstring,
      "Array, Index, any": function ArrayIndexAny(value, index, replacement) {
        return matrix(clone(value)).subset(index, replacement, void 0).valueOf();
      },
      "Array, Index, any, any": function ArrayIndexAnyAny(value, index, replacement, defaultValue) {
        return matrix(clone(value)).subset(index, replacement, defaultValue).valueOf();
      },
      "Matrix, Index, any": function MatrixIndexAny(value, index, replacement) {
        return value.clone().subset(index, replacement);
      },
      "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
        return value.clone().subset(index, replacement, defaultValue);
      },
      "string, Index, string": _setSubstring,
      "string, Index, string, string": _setSubstring,
      "Object, Index, any": _setObjectProperty
    });
  });
  function _getSubstring(str, index) {
    if (!isIndex(index)) {
      throw new TypeError("Index expected");
    }
    if (index.size().length !== 1) {
      throw new DimensionError(index.size().length, 1);
    }
    var strLen = str.length;
    validateIndex(index.min()[0], strLen);
    validateIndex(index.max()[0], strLen);
    var range = index.dimension(0);
    var substr = "";
    range.forEach(function(v) {
      substr += str.charAt(v);
    });
    return substr;
  }
  function _setSubstring(str, index, replacement, defaultValue) {
    if (!index || index.isIndex !== true) {
      throw new TypeError("Index expected");
    }
    if (index.size().length !== 1) {
      throw new DimensionError(index.size().length, 1);
    }
    if (defaultValue !== void 0) {
      if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultValue = " ";
    }
    var range = index.dimension(0);
    var len = range.size()[0];
    if (len !== replacement.length) {
      throw new DimensionError(range.size()[0], replacement.length);
    }
    var strLen = str.length;
    validateIndex(index.min()[0]);
    validateIndex(index.max()[0]);
    var chars = [];
    for (var i = 0; i < strLen; i++) {
      chars[i] = str.charAt(i);
    }
    range.forEach(function(v, i2) {
      chars[v] = replacement.charAt(i2[0]);
    });
    if (chars.length > strLen) {
      for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
        if (!chars[_i]) {
          chars[_i] = defaultValue;
        }
      }
    }
    return chars.join("");
  }
  function _getObjectProperty(object, index) {
    if (index.size().length !== 1) {
      throw new DimensionError(index.size(), 1);
    }
    var key = index.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    return getSafeProperty(object, key);
  }
  function _setObjectProperty(object, index, replacement) {
    if (index.size().length !== 1) {
      throw new DimensionError(index.size(), 1);
    }
    var key = index.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    var updated = clone(object);
    setSafeProperty(updated, key, replacement);
    return updated;
  }

  // node_modules/mathjs/lib/esm/function/matrix/transpose.js
  var name105 = "transpose";
  var dependencies106 = ["typed", "matrix"];
  var createTranspose = /* @__PURE__ */ factory(name105, dependencies106, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return typed(name105, {
      Array: (x) => transposeMatrix(matrix(x)).valueOf(),
      Matrix: transposeMatrix,
      any: clone
    });
    function transposeMatrix(x) {
      var size = x.size();
      var c;
      switch (size.length) {
        case 1:
          c = x.clone();
          break;
        case 2:
          {
            var rows = size[0];
            var columns = size[1];
            if (columns === 0) {
              throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size) + ")");
            }
            switch (x.storage()) {
              case "dense":
                c = _denseTranspose(x, rows, columns);
                break;
              case "sparse":
                c = _sparseTranspose(x, rows, columns);
                break;
            }
          }
          break;
        default:
          throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size) + ")");
      }
      return c;
    }
    function _denseTranspose(m, rows, columns) {
      var data = m._data;
      var transposed = [];
      var transposedRow;
      for (var j = 0; j < columns; j++) {
        transposedRow = transposed[j] = [];
        for (var i = 0; i < rows; i++) {
          transposedRow[i] = clone(data[i][j]);
        }
      }
      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
    function _sparseTranspose(m, rows, columns) {
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var cvalues = values2 ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var w = [];
      for (var x = 0; x < rows; x++) {
        w[x] = 0;
      }
      var p, l, j;
      for (p = 0, l = index.length; p < l; p++) {
        w[index[p]]++;
      }
      var sum2 = 0;
      for (var i = 0; i < rows; i++) {
        cptr.push(sum2);
        sum2 += w[i];
        w[i] = cptr[i];
      }
      cptr.push(sum2);
      for (j = 0; j < columns; j++) {
        for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          var q = w[index[k]]++;
          cindex[q] = j;
          if (values2) {
            cvalues[q] = clone(values2[k]);
          }
        }
      }
      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
  var name106 = "ctranspose";
  var dependencies107 = ["typed", "transpose", "conj"];
  var createCtranspose = /* @__PURE__ */ factory(name106, dependencies107, (_ref) => {
    var {
      typed,
      transpose,
      conj
    } = _ref;
    return typed(name106, {
      any: function any(x) {
        return conj(transpose(x));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/zeros.js
  var name107 = "zeros";
  var dependencies108 = ["typed", "config", "matrix", "BigNumber"];
  var createZeros = /* @__PURE__ */ factory(name107, dependencies108, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      BigNumber
    } = _ref;
    return typed(name107, {
      "": function _() {
        return config2.matrix === "Array" ? _zeros([]) : _zeros([], "default");
      },
      "...number | BigNumber | string": function numberBigNumberString(size) {
        var last = size[size.length - 1];
        if (typeof last === "string") {
          var format4 = size.pop();
          return _zeros(size, format4);
        } else if (config2.matrix === "Array") {
          return _zeros(size);
        } else {
          return _zeros(size, "default");
        }
      },
      Array: _zeros,
      Matrix: function Matrix(size) {
        var format4 = size.storage();
        return _zeros(size.valueOf(), format4);
      },
      "Array | Matrix, string": function ArrayMatrixString(size, format4) {
        return _zeros(size.valueOf(), format4);
      }
    });
    function _zeros(size, format4) {
      var hasBigNumbers = _normalize(size);
      var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
      _validate2(size);
      if (format4) {
        var m = matrix(format4);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size) {
      size.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function zeros must be positive integers");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/fft.js
  var name108 = "fft";
  var dependencies109 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i"];
  var createFft = /* @__PURE__ */ factory(name108, dependencies109, (_ref) => {
    var {
      typed,
      matrix,
      addScalar,
      multiplyScalar,
      divideScalar,
      exp: exp2,
      tau: tau2,
      i: I
    } = _ref;
    return typed(name108, {
      Array: _ndFft,
      Matrix: function Matrix(matrix2) {
        return matrix2.create(_ndFft(matrix2.toArray()));
      }
    });
    function _ndFft(arr) {
      var size = arraySize(arr);
      if (size.length === 1)
        return _fft(arr, size[0]);
      return _1dFft(arr.map((slice) => _ndFft(slice, size.slice(1))), 0);
    }
    function _1dFft(arr, dim) {
      var size = arraySize(arr);
      if (dim !== 0)
        return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));
      if (size.length === 1)
        return _fft(arr);
      function _transpose(arr2) {
        var size2 = arraySize(arr2);
        return new Array(size2[1]).fill(0).map((_, j) => new Array(size2[0]).fill(0).map((_2, i) => arr2[i][j]));
      }
      return _transpose(_1dFft(_transpose(arr), 1));
    }
    function _fft(arr) {
      var len = arr.length;
      if (len === 1)
        return [arr[0]];
      if (len % 2 === 0) {
        var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];
        for (var k = 0; k < len / 2; k++) {
          var p = ret[k];
          var q = multiplyScalar(ret[k + len / 2], exp2(multiplyScalar(multiplyScalar(tau2, I), divideScalar(-k, len))));
          ret[k] = addScalar(p, q);
          ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));
        }
        return ret;
      }
      throw new Error("Can only calculate FFT of power-of-two size");
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ifft.js
  var name109 = "ifft";
  var dependencies110 = ["typed", "fft", "dotDivide", "conj"];
  var createIfft = /* @__PURE__ */ factory(name109, dependencies110, (_ref) => {
    var {
      typed,
      fft,
      dotDivide,
      conj
    } = _ref;
    return typed(name109, {
      "Array | Matrix": function ArrayMatrix(arr) {
        var size = isMatrix(arr) ? arr.size() : arraySize(arr);
        return dotDivide(conj(fft(conj(arr))), size.reduce((acc, curr) => acc * curr, 1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/special/erf.js
  var name110 = "erf";
  var dependencies111 = ["typed"];
  var createErf = /* @__PURE__ */ factory(name110, dependencies111, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("name", {
      number: function number(x) {
        var y = Math.abs(x);
        if (y >= MAX_NUM) {
          return sign(x);
        }
        if (y <= THRESH) {
          return sign(x) * erf1(y);
        }
        if (y <= 4) {
          return sign(x) * (1 - erfc2(y));
        }
        return sign(x) * (1 - erfc3(y));
      },
      "Array | Matrix": typed.referToSelf((self2) => (n) => deepMap(n, self2))
    });
    function erf1(y) {
      var ysq = y * y;
      var xnum = P2[0][4] * ysq;
      var xden = ysq;
      var i;
      for (i = 0; i < 3; i += 1) {
        xnum = (xnum + P2[0][i]) * ysq;
        xden = (xden + Q[0][i]) * ysq;
      }
      return y * (xnum + P2[0][3]) / (xden + Q[0][3]);
    }
    function erfc2(y) {
      var xnum = P2[1][8] * y;
      var xden = y;
      var i;
      for (i = 0; i < 7; i += 1) {
        xnum = (xnum + P2[1][i]) * y;
        xden = (xden + Q[1][i]) * y;
      }
      var result = (xnum + P2[1][7]) / (xden + Q[1][7]);
      var ysq = parseInt(y * 16) / 16;
      var del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
    function erfc3(y) {
      var ysq = 1 / (y * y);
      var xnum = P2[2][5] * ysq;
      var xden = ysq;
      var i;
      for (i = 0; i < 4; i += 1) {
        xnum = (xnum + P2[2][i]) * ysq;
        xden = (xden + Q[2][i]) * ysq;
      }
      var result = ysq * (xnum + P2[2][4]) / (xden + Q[2][4]);
      result = (SQRPI - result) / y;
      ysq = parseInt(y * 16) / 16;
      var del = (y - ysq) * (y + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
  });
  var THRESH = 0.46875;
  var SQRPI = 0.5641895835477563;
  var P2 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
  var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
  var MAX_NUM = Math.pow(2, 53);

  // node_modules/mathjs/lib/esm/function/statistics/mode.js
  var name111 = "mode";
  var dependencies112 = ["typed", "isNaN", "isNumeric"];
  var createMode = /* @__PURE__ */ factory(name111, dependencies112, (_ref) => {
    var {
      typed,
      isNaN: isNaN2,
      isNumeric
    } = _ref;
    return typed(name111, {
      "Array | Matrix": _mode,
      "...": function _(args) {
        return _mode(args);
      }
    });
    function _mode(values2) {
      values2 = flatten(values2.valueOf());
      var num = values2.length;
      if (num === 0) {
        throw new Error("Cannot calculate mode of an empty array");
      }
      var count = {};
      var mode = [];
      var max2 = 0;
      for (var i = 0; i < values2.length; i++) {
        var value = values2[i];
        if (isNumeric(value) && isNaN2(value)) {
          throw new Error("Cannot calculate mode of an array containing NaN values");
        }
        if (!(value in count)) {
          count[value] = 0;
        }
        count[value]++;
        if (count[value] === max2) {
          mode.push(value);
        } else if (count[value] > max2) {
          max2 = count[value];
          mode = [value];
        }
      }
      return mode;
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
  function improveErrorMessage(err, fnName, value) {
    var details;
    if (String(err).indexOf("Unexpected type") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
      return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
    }
    if (String(err).indexOf("complex numbers") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
      return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
    }
    return err;
  }

  // node_modules/mathjs/lib/esm/function/statistics/prod.js
  var name112 = "prod";
  var dependencies113 = ["typed", "config", "multiplyScalar", "numeric"];
  var createProd = /* @__PURE__ */ factory(name112, dependencies113, (_ref) => {
    var {
      typed,
      config: config2,
      multiplyScalar,
      numeric: numeric2
    } = _ref;
    return typed(name112, {
      "Array | Matrix": _prod,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        throw new Error("prod(A, dim) is not yet supported");
      },
      "...": function _(args) {
        return _prod(args);
      }
    });
    function _prod(array) {
      var prod;
      deepForEach(array, function(value) {
        try {
          prod = prod === void 0 ? value : multiplyScalar(prod, value);
        } catch (err) {
          throw improveErrorMessage(err, "prod", value);
        }
      });
      if (typeof prod === "string") {
        prod = numeric2(prod, config2.number);
      }
      if (prod === void 0) {
        throw new Error("Cannot calculate prod of an empty array");
      }
      return prod;
    }
  });

  // node_modules/mathjs/lib/esm/function/string/format.js
  var name113 = "format";
  var dependencies114 = ["typed"];
  var createFormat = /* @__PURE__ */ factory(name113, dependencies114, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name113, {
      any: format3,
      "any, Object | function | number": format3
    });
  });

  // node_modules/mathjs/lib/esm/function/string/bin.js
  var name114 = "bin";
  var dependencies115 = ["typed", "format"];
  var createBin = factory(name114, dependencies115, (_ref) => {
    var {
      typed,
      format: format4
    } = _ref;
    return typed(name114, {
      "number | BigNumber": function numberBigNumber(n) {
        return format4(n, {
          notation: "bin"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format4(n, {
          notation: "bin",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/oct.js
  var name115 = "oct";
  var dependencies116 = ["typed", "format"];
  var createOct = factory(name115, dependencies116, (_ref) => {
    var {
      typed,
      format: format4
    } = _ref;
    return typed(name115, {
      "number | BigNumber": function numberBigNumber(n) {
        return format4(n, {
          notation: "oct"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format4(n, {
          notation: "oct",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/hex.js
  var name116 = "hex";
  var dependencies117 = ["typed", "format"];
  var createHex = factory(name116, dependencies117, (_ref) => {
    var {
      typed,
      format: format4
    } = _ref;
    return typed(name116, {
      "number | BigNumber": function numberBigNumber(n) {
        return format4(n, {
          notation: "hex"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format4(n, {
          notation: "hex",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/print.js
  var name117 = "print";
  var dependencies118 = ["typed"];
  var createPrint = /* @__PURE__ */ factory(name117, dependencies118, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name117, {
      "string, Object | Array": _print,
      "string, Object | Array, number | Object": _print
    });
  });
  function _print(template, values2, options) {
    return template.replace(/\$([\w.]+)/g, function(original, key) {
      var keys = key.split(".");
      var value = values2[keys.shift()];
      while (keys.length && value !== void 0) {
        var k = keys.shift();
        value = k ? value[k] : value + ".";
      }
      if (value !== void 0) {
        if (!isString(value)) {
          return format3(value, options);
        } else {
          return value;
        }
      }
      return original;
    });
  }

  // node_modules/mathjs/lib/esm/function/unit/to.js
  var name118 = "to";
  var dependencies119 = ["typed", "matrix"];
  var createTo = /* @__PURE__ */ factory(name118, dependencies119, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name118, {
      "Unit, Unit | string": (x, unit) => x.to(unit)
    }, matrixAlgorithmSuite({
      Ds: true
    }));
  });

  // node_modules/mathjs/lib/esm/function/utils/isPrime.js
  var name119 = "isPrime";
  var dependencies120 = ["typed"];
  var createIsPrime = /* @__PURE__ */ factory(name119, dependencies120, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name119, {
      number: function number(x) {
        if (x * 0 !== 0) {
          return false;
        }
        if (x <= 3) {
          return x > 1;
        }
        if (x % 2 === 0 || x % 3 === 0) {
          return false;
        }
        for (var i = 5; i * i <= x; i += 6) {
          if (x % i === 0 || x % (i + 2) === 0) {
            return false;
          }
        }
        return true;
      },
      BigNumber: function BigNumber(n) {
        if (n.toNumber() * 0 !== 0) {
          return false;
        }
        if (n.lte(3))
          return n.gt(1);
        if (n.mod(2).eq(0) || n.mod(3).eq(0))
          return false;
        if (n.lt(Math.pow(2, 32))) {
          var x = n.toNumber();
          for (var i = 5; i * i <= x; i += 6) {
            if (x % i === 0 || x % (i + 2) === 0) {
              return false;
            }
          }
          return true;
        }
        function modPow(base, exponent, modulus) {
          var accumulator = 1;
          while (!exponent.eq(0)) {
            if (exponent.mod(2).eq(0)) {
              exponent = exponent.div(2);
              base = base.mul(base).mod(modulus);
            } else {
              exponent = exponent.sub(1);
              accumulator = base.mul(accumulator).mod(modulus);
            }
          }
          return accumulator;
        }
        var Decimal2 = n.constructor.clone({
          precision: n.toFixed(0).length * 2
        });
        n = new Decimal2(n);
        var r = 0;
        var d = n.sub(1);
        while (d.mod(2).eq(0)) {
          d = d.div(2);
          r += 1;
        }
        var bases = null;
        if (n.lt("3317044064679887385961981")) {
          bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
        } else {
          var max2 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
          bases = [];
          for (var _i = 2; _i <= max2; _i += 1) {
            bases.push(max2);
          }
        }
        for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
          var a = bases[_i2];
          var adn = modPow(n.sub(n).add(a), d, n);
          if (!adn.eq(1)) {
            for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
              if (_i3 === r - 1) {
                return false;
              }
            }
          }
        }
        return true;
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/numeric.js
  var name120 = "numeric";
  var dependencies121 = ["number", "?bignumber", "?fraction"];
  var createNumeric = /* @__PURE__ */ factory(name120, dependencies121, (_ref) => {
    var {
      number: _number,
      bignumber,
      fraction
    } = _ref;
    var validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    };
    var validOutputTypes = {
      number: (x) => _number(x),
      BigNumber: bignumber ? (x) => bignumber(x) : noBignumber,
      Fraction: fraction ? (x) => fraction(x) : noFraction
    };
    return function numeric2(value) {
      var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
      var check = arguments.length > 2 ? arguments[2] : void 0;
      if (check !== void 0) {
        throw new SyntaxError("numeric() takes one or two arguments");
      }
      var inputType = typeOf(value);
      if (!(inputType in validInputTypes)) {
        throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
      }
      if (!(outputType in validOutputTypes)) {
        throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
      }
      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
  var name121 = "divideScalar";
  var dependencies122 = ["typed", "numeric"];
  var createDivideScalar = /* @__PURE__ */ factory(name121, dependencies122, (_ref) => {
    var {
      typed,
      numeric: numeric2
    } = _ref;
    return typed(name121, {
      "number, number": function numberNumber(x, y) {
        return x / y;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.div(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.div(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.div(y);
      },
      "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
      "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/pow.js
  var name122 = "pow";
  var dependencies123 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
  var createPow = /* @__PURE__ */ factory(name122, dependencies123, (_ref) => {
    var {
      typed,
      config: config2,
      identity,
      multiply,
      matrix,
      inv,
      number,
      fraction,
      Complex: Complex2
    } = _ref;
    return typed(name122, {
      "number, number": _pow,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.pow(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        if (y.isInteger() || x >= 0 || config2.predictable) {
          return x.pow(y);
        } else {
          return new Complex2(x.toNumber(), 0).pow(y.toNumber(), 0);
        }
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        var result = x.pow(y);
        if (result != null) {
          return result;
        }
        if (config2.predictable) {
          throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
        } else {
          return _pow(x.valueOf(), y.valueOf());
        }
      },
      "Array, number": _powArray,
      "Array, BigNumber": function ArrayBigNumber(x, y) {
        return _powArray(x, y.toNumber());
      },
      "Matrix, number": _powMatrix,
      "Matrix, BigNumber": function MatrixBigNumber(x, y) {
        return _powMatrix(x, y.toNumber());
      },
      "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
        return x.pow(y);
      }
    });
    function _pow(x, y) {
      if (config2.predictable && !isInteger(y) && x < 0) {
        try {
          var yFrac = fraction(y);
          var yNum = number(yFrac);
          if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
            if (yFrac.d % 2 === 1) {
              return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
            }
          }
        } catch (ex) {
        }
      }
      if (config2.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
        return NaN;
      }
      if (isInteger(y) || x >= 0 || config2.predictable) {
        return powNumber(x, y);
      } else {
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }
        return new Complex2(x, 0).pow(y, 0);
      }
    }
    function _powArray(x, y) {
      if (!isInteger(y)) {
        throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
      }
      var s = arraySize(x);
      if (s.length !== 2) {
        throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
      }
      if (s[0] !== s[1]) {
        throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
      }
      if (y < 0) {
        try {
          return _powArray(inv(x), -y);
        } catch (error) {
          if (error.message === "Cannot calculate inverse, determinant is zero") {
            throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
          }
          throw error;
        }
      }
      var res = identity(s[0]).valueOf();
      var px = x;
      while (y >= 1) {
        if ((y & 1) === 1) {
          res = multiply(px, res);
        }
        y >>= 1;
        px = multiply(px, px);
      }
      return res;
    }
    function _powMatrix(x, y) {
      return matrix(_powArray(x.valueOf(), y));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/round.js
  var NO_INT = "Number of decimals in function round must be an integer";
  var name123 = "round";
  var dependencies124 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
  var createRound = /* @__PURE__ */ factory(name123, dependencies124, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      BigNumber,
      DenseMatrix
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    return typed(name123, {
      number: roundNumber,
      "number, number": roundNumber,
      "number, BigNumber": function numberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return new BigNumber(x).toDecimalPlaces(n.toNumber());
      },
      Complex: function Complex2(x) {
        return x.round();
      },
      "Complex, number": function ComplexNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        var _n = n.toNumber();
        return x.round(_n);
      },
      BigNumber: function BigNumber2(x) {
        return x.toDecimalPlaces(0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return x.toDecimalPlaces(n.toNumber());
      },
      Fraction: function Fraction2(x) {
        return x.round();
      },
      "Fraction, number": function FractionNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Fraction, BigNumber": function FractionBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return x.round(n.toNumber());
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2, true)),
      "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(x, y, self2, false);
      }),
      "Array, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(matrix(x), y, self2, false).valueOf();
      }),
      "number | Complex | BigNumber | Fraction, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo12xSfs(y, x, self2, true);
      }),
      "number | Complex | BigNumber | Fraction, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo14xDs(y, x, self2, true);
      }),
      "number | Complex | BigNumber | Fraction, Array": typed.referToSelf((self2) => (x, y) => {
        return matAlgo14xDs(matrix(y), x, self2, true).valueOf();
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log.js
  var name124 = "log";
  var dependencies125 = ["config", "typed", "divideScalar", "Complex"];
  var createLog = /* @__PURE__ */ factory(name124, dependencies125, (_ref) => {
    var {
      typed,
      config: config2,
      divideScalar,
      Complex: Complex2
    } = _ref;
    return typed(name124, {
      number: function number(x) {
        if (x >= 0 || config2.predictable) {
          return logNumber(x);
        } else {
          return new Complex2(x, 0).log();
        }
      },
      Complex: function Complex3(x) {
        return x.log();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config2.predictable) {
          return x.ln();
        } else {
          return new Complex2(x.toNumber(), 0).log();
        }
      },
      "any, any": typed.referToSelf((self2) => (x, base) => {
        return divideScalar(self2(x), self2(base));
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
  var name125 = "log1p";
  var dependencies126 = ["typed", "config", "divideScalar", "log", "Complex"];
  var createLog1p = /* @__PURE__ */ factory(name125, dependencies126, (_ref) => {
    var {
      typed,
      config: config2,
      divideScalar,
      log: log3,
      Complex: Complex2
    } = _ref;
    return typed(name125, {
      number: function number(x) {
        if (x >= -1 || config2.predictable) {
          return log1p(x);
        } else {
          return _log1pComplex(new Complex2(x, 0));
        }
      },
      Complex: _log1pComplex,
      BigNumber: function BigNumber(x) {
        var y = x.plus(1);
        if (!y.isNegative() || config2.predictable) {
          return y.ln();
        } else {
          return _log1pComplex(new Complex2(x.toNumber(), 0));
        }
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2)),
      "any, any": typed.referToSelf((self2) => (x, base) => {
        return divideScalar(self2(x), log3(base));
      })
    });
    function _log1pComplex(x) {
      var xRe1p = x.re + 1;
      return new Complex2(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
  var name126 = "nthRoots";
  var dependencies127 = ["config", "typed", "divideScalar", "Complex"];
  var createNthRoots = /* @__PURE__ */ factory(name126, dependencies127, (_ref) => {
    var {
      typed,
      config: config2,
      divideScalar,
      Complex: Complex2
    } = _ref;
    var _calculateExactResult = [function realPos(val) {
      return new Complex2(val, 0);
    }, function imagPos(val) {
      return new Complex2(0, val);
    }, function realNeg(val) {
      return new Complex2(-val, 0);
    }, function imagNeg(val) {
      return new Complex2(0, -val);
    }];
    function _nthComplexRoots(a, root2) {
      if (root2 < 0)
        throw new Error("Root must be greater than zero");
      if (root2 === 0)
        throw new Error("Root must be non-zero");
      if (root2 % 1 !== 0)
        throw new Error("Root must be an integer");
      if (a === 0 || a.abs() === 0)
        return [new Complex2(0, 0)];
      var aIsNumeric = typeof a === "number";
      var offset;
      if (aIsNumeric || a.re === 0 || a.im === 0) {
        if (aIsNumeric) {
          offset = 2 * +(a < 0);
        } else if (a.im === 0) {
          offset = 2 * +(a.re < 0);
        } else {
          offset = 2 * +(a.im < 0) + 1;
        }
      }
      var arg = a.arg();
      var abs2 = a.abs();
      var roots = [];
      var r = Math.pow(abs2, 1 / root2);
      for (var k = 0; k < root2; k++) {
        var halfPiFactor = (offset + 4 * k) / root2;
        if (halfPiFactor === Math.round(halfPiFactor)) {
          roots.push(_calculateExactResult[halfPiFactor % 4](r));
          continue;
        }
        roots.push(new Complex2({
          r,
          phi: (arg + 2 * Math.PI * k) / root2
        }));
      }
      return roots;
    }
    return typed(name126, {
      Complex: function Complex3(x) {
        return _nthComplexRoots(x, 2);
      },
      "Complex, number": _nthComplexRoots
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
  var name127 = "dotPow";
  var dependencies128 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix"];
  var createDotPow = /* @__PURE__ */ factory(name127, dependencies128, (_ref) => {
    var {
      typed,
      equalScalar,
      matrix,
      pow: pow2,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var powScalarSignatures = {};
    for (var signature in pow2.signatures) {
      if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
        if (!signature.includes("Matrix") && !signature.includes("Array")) {
          powScalarSignatures[signature] = pow2.signatures[signature];
        }
      }
    }
    var powScalar = typed(powScalarSignatures);
    return typed(name127, matrixAlgorithmSuite({
      elop: powScalar,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
  var name128 = "dotDivide";
  var dependencies129 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix"];
  var createDotDivide = /* @__PURE__ */ factory(name128, dependencies129, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      divideScalar,
      DenseMatrix
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name128, matrixAlgorithmSuite({
      elop: divideScalar,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
  function createSolveValidation(_ref) {
    var {
      DenseMatrix
    } = _ref;
    return function solveValidation(m, b, copy) {
      var mSize = m.size();
      if (mSize.length !== 2) {
        throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
      }
      var rows = mSize[0];
      var columns = mSize[1];
      if (rows !== columns) {
        throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
      }
      var data = [];
      if (isMatrix(b)) {
        var bSize = b.size();
        var bdata = b._data;
        if (bSize.length === 1) {
          if (bSize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var i = 0; i < rows; i++) {
            data[i] = [bdata[i]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
        if (bSize.length === 2) {
          if (bSize[0] !== rows || bSize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          if (isDenseMatrix(b)) {
            if (copy) {
              data = [];
              for (var _i = 0; _i < rows; _i++) {
                data[_i] = [bdata[_i][0]];
              }
              return new DenseMatrix({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
            return b;
          }
          if (isSparseMatrix(b)) {
            for (var _i2 = 0; _i2 < rows; _i2++) {
              data[_i2] = [0];
            }
            var values2 = b._values;
            var index = b._index;
            var ptr = b._ptr;
            for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
              var _i3 = index[k];
              data[_i3][0] = values2[k];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
      if (isArray(b)) {
        var bsize = arraySize(b);
        if (bsize.length === 1) {
          if (bsize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i4 = 0; _i4 < rows; _i4++) {
            data[_i4] = [b[_i4]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1]
          });
        }
        if (bsize.length === 2) {
          if (bsize[0] !== rows || bsize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i5 = 0; _i5 < rows; _i5++) {
            data[_i5] = [b[_i5][0]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1]
          });
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
    };
  }

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
  var name129 = "lsolve";
  var dependencies130 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createLsolve = /* @__PURE__ */ factory(name129, dependencies130, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name129, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var r = _denseForwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseForwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = 0; j < columns; j++) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar(bj, vjj);
          for (var i = j + 1; i < rows; i++) {
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseForwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = 0; j < columns; j++) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = firstIndex; k < lastIndex; k++) {
            var i = index[k];
            if (i === j) {
              vjj = values2[k];
            } else if (i > j) {
              jValues.push(values2[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar(bj, vjj);
          for (var _k = 0, l = jIndices.length; _k < l; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
  var name130 = "usolve";
  var dependencies131 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createUsolve = /* @__PURE__ */ factory(name130, dependencies131, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name130, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var r = _denseBackwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar(bj, vjj);
          for (var i = j - 1; i >= 0; i--) {
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = lastIndex - 1; k >= firstIndex; k--) {
            var i = index[k];
            if (i === j) {
              vjj = values2[k];
            } else if (i < j) {
              jValues.push(values2[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar(bj, vjj);
          for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
  var name131 = "lsolveAll";
  var dependencies132 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createLsolveAll = /* @__PURE__ */ factory(name131, dependencies132, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name131, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var R = _denseForwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseForwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i = 0; i < columns; i++) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            b[i] = divideScalar(b[i], M[i][i]);
            for (var j = i + 1; j < columns; j++) {
              b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j = i + 1; _j < columns; _j++) {
              bNew[_j] = subtract(bNew[_j], M[_j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
    function _sparseForwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var i = 0; i < columns; i++) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i];
          var lastIndex = ptr[i + 1];
          var Mii = 0;
          for (var j = firstIndex; j < lastIndex; j++) {
            var J = index[j];
            if (J === i) {
              Mii = values2[j];
            } else if (J > i) {
              iValues.push(values2[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            b[i] = divideScalar(b[i], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
  var name132 = "usolveAll";
  var dependencies133 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createUsolveAll = /* @__PURE__ */ factory(name132, dependencies133, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name132, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var R = _denseBackwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseBackwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            b[i] = divideScalar(b[i], M[i][i]);
            for (var j = i - 1; j >= 0; j--) {
              b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j = i - 1; _j >= 0; _j--) {
              bNew[_j] = subtract(bNew[_j], M[_j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
    function _sparseBackwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i];
          var lastIndex = ptr[i + 1];
          var Mii = 0;
          for (var j = lastIndex - 1; j >= firstIndex; j--) {
            var J = index[j];
            if (J === i) {
              Mii = values2[j];
            } else if (J < i) {
              iValues.push(values2[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            b[i] = divideScalar(b[i], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
            }
          } else if (!equalScalar(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix({
        data: x.map((e2) => [e2]),
        size: [rows, 1]
      }));
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
  var name133 = "matAlgo08xS0Sid";
  var dependencies134 = ["typed", "equalScalar"];
  var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name133, dependencies134, (_ref) => {
    var {
      typed,
      equalScalar
    } = _ref;
    return function matAlgo08xS0Sid(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!avalues || !bvalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrices");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed.find(equalScalar, [dt, dt]);
        zero = typed.convert(0, dt);
        cf = typed.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var x = [];
      var w = [];
      var k, k0, k1, i;
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          w[i] = mark;
          x[i] = avalues[k];
          cindex.push(i);
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (w[i] === mark) {
            x[i] = cf(x[i], bvalues[k]);
          }
        }
        k = cptr[j];
        while (k < cindex.length) {
          i = cindex[k];
          var v = x[i];
          if (!eq(v, zero)) {
            cvalues.push(v);
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
  var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    return {
      "Array, number": typed.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix(x), y).valueOf()),
      "Array, BigNumber": typed.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix(x), y).valueOf()),
      "number, Array": typed.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix(y)).valueOf()),
      "BigNumber, Array": typed.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix(y)).valueOf())
    };
  });

  // node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
  var name134 = "leftShift";
  var dependencies135 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createLeftShift = /* @__PURE__ */ factory(name134, dependencies135, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed,
      matrix
    });
    return typed(name134, {
      "number, number": leftShiftNumber,
      "BigNumber, BigNumber": leftShiftBigNumber,
      "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return matAlgo14xDs(x, y, self2, false);
      }),
      "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo10xSids(y, x, self2, true);
      }),
      "number | BigNumber, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo14xDs(y, x, self2, true);
      })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
      SS: matAlgo08xS0Sid,
      DS: matAlgo01xDSid,
      SD: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
  var name135 = "rightArithShift";
  var dependencies136 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createRightArithShift = /* @__PURE__ */ factory(name135, dependencies136, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed,
      matrix
    });
    return typed(name135, {
      "number, number": rightArithShiftNumber,
      "BigNumber, BigNumber": rightArithShiftBigNumber,
      "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return matAlgo14xDs(x, y, self2, false);
      }),
      "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo10xSids(y, x, self2, true);
      }),
      "number | BigNumber, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo14xDs(y, x, self2, true);
      })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
      SS: matAlgo08xS0Sid,
      DS: matAlgo01xDSid,
      SD: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
  var name136 = "rightLogShift";
  var dependencies137 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createRightLogShift = /* @__PURE__ */ factory(name136, dependencies137, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      DenseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed,
      matrix
    });
    return typed(name136, {
      "number, number": rightLogShiftNumber,
      "SparseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(y, 0)) {
          return x.clone();
        }
        return matAlgo14xDs(x, y, self2, false);
      }),
      "number | BigNumber, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo10xSids(y, x, self2, true);
      }),
      "number | BigNumber, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (equalScalar(x, 0)) {
          return zeros2(y.size(), y.storage());
        }
        return matAlgo14xDs(y, x, self2, true);
      })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
      SS: matAlgo08xS0Sid,
      DS: matAlgo01xDSid,
      SD: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/logical/and.js
  var name137 = "and";
  var dependencies138 = ["typed", "matrix", "equalScalar", "zeros", "not"];
  var createAnd = /* @__PURE__ */ factory(name137, dependencies138, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      zeros: zeros2,
      not
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name137, {
      "number, number": andNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
      },
      "Unit, Unit": typed.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0)),
      "SparseMatrix, any": typed.referToSelf((self2) => (x, y) => {
        if (not(y)) {
          return zeros2(x.size(), x.storage());
        }
        return matAlgo11xS0s(x, y, self2, false);
      }),
      "DenseMatrix, any": typed.referToSelf((self2) => (x, y) => {
        if (not(y)) {
          return zeros2(x.size(), x.storage());
        }
        return matAlgo14xDs(x, y, self2, false);
      }),
      "any, SparseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (not(x)) {
          return zeros2(x.size(), x.storage());
        }
        return matAlgo11xS0s(y, x, self2, true);
      }),
      "any, DenseMatrix": typed.referToSelf((self2) => (x, y) => {
        if (not(x)) {
          return zeros2(x.size(), x.storage());
        }
        return matAlgo14xDs(y, x, self2, true);
      }),
      "Array, any": typed.referToSelf((self2) => (x, y) => {
        return self2(matrix(x), y).valueOf();
      }),
      "any, Array": typed.referToSelf((self2) => (x, y) => {
        return self2(x, matrix(y)).valueOf();
      })
    }, matrixAlgorithmSuite({
      SS: matAlgo06xS0S0,
      DS: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/relational/compare.js
  var name138 = "compare";
  var dependencies139 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix"];
  var createCompare = /* @__PURE__ */ factory(name138, dependencies139, (_ref) => {
    var {
      typed,
      config: config2,
      equalScalar,
      matrix,
      BigNumber,
      Fraction: Fraction2,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var compareUnits = createCompareUnits({
      typed
    });
    return typed(name138, createCompareNumber({
      typed,
      config: config2
    }), {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x === y ? 0 : x > y ? 1 : -1;
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return nearlyEqual2(x, y, config2.epsilon) ? new BigNumber(0) : new BigNumber(x.cmp(y));
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return new Fraction2(x.compare(y));
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createCompareNumber = /* @__PURE__ */ factory(name138, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config: config2
    } = _ref2;
    return typed(name138, {
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config2.epsilon) ? 0 : x > y ? 1 : -1;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/compareNatural.js
  var import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
  var name139 = "compareNatural";
  var dependencies140 = ["typed", "compare"];
  var createCompareNatural = /* @__PURE__ */ factory(name139, dependencies140, (_ref) => {
    var {
      typed,
      compare
    } = _ref;
    var compareBooleans = compare.signatures["boolean,boolean"];
    return typed(name139, {
      "any, any": _compareNatural
    });
    function _compareNatural(x, y) {
      var typeX = typeOf(x);
      var typeY = typeOf(y);
      var c;
      if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
        c = compare(x, y);
        if (c.toString() !== "0") {
          return c > 0 ? 1 : -1;
        } else {
          return (0, import_javascript_natural_sort.default)(typeX, typeY);
        }
      }
      var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
      if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
        c = compareMatricesAndArrays(_compareNatural, x, y);
        if (c !== 0) {
          return c;
        } else {
          return (0, import_javascript_natural_sort.default)(typeX, typeY);
        }
      }
      if (typeX !== typeY) {
        return (0, import_javascript_natural_sort.default)(typeX, typeY);
      }
      if (typeX === "Complex") {
        return compareComplexNumbers(x, y);
      }
      if (typeX === "Unit") {
        if (x.equalBase(y)) {
          return _compareNatural(x.value, y.value);
        }
        return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
      }
      if (typeX === "boolean") {
        return compareBooleans(x, y);
      }
      if (typeX === "string") {
        return (0, import_javascript_natural_sort.default)(x, y);
      }
      if (typeX === "Object") {
        return compareObjects(_compareNatural, x, y);
      }
      if (typeX === "null") {
        return 0;
      }
      if (typeX === "undefined") {
        return 0;
      }
      throw new TypeError('Unsupported type of value "' + typeX + '"');
    }
    function compareMatricesAndArrays(compareNatural, x, y) {
      if (isSparseMatrix(x) && isSparseMatrix(y)) {
        return compareArrays(compareNatural, x.toJSON().values, y.toJSON().values);
      }
      if (isSparseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural, x.toArray(), y);
      }
      if (isSparseMatrix(y)) {
        return compareMatricesAndArrays(compareNatural, x, y.toArray());
      }
      if (isDenseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural, x.toJSON().data, y);
      }
      if (isDenseMatrix(y)) {
        return compareMatricesAndArrays(compareNatural, x, y.toJSON().data);
      }
      if (!Array.isArray(x)) {
        return compareMatricesAndArrays(compareNatural, [x], y);
      }
      if (!Array.isArray(y)) {
        return compareMatricesAndArrays(compareNatural, x, [y]);
      }
      return compareArrays(compareNatural, x, y);
    }
    function compareArrays(compareNatural, x, y) {
      for (var i = 0, ii = Math.min(x.length, y.length); i < ii; i++) {
        var v = compareNatural(x[i], y[i]);
        if (v !== 0) {
          return v;
        }
      }
      if (x.length > y.length) {
        return 1;
      }
      if (x.length < y.length) {
        return -1;
      }
      return 0;
    }
    function compareObjects(compareNatural, x, y) {
      var keysX = Object.keys(x);
      var keysY = Object.keys(y);
      keysX.sort(import_javascript_natural_sort.default);
      keysY.sort(import_javascript_natural_sort.default);
      var c = compareArrays(compareNatural, keysX, keysY);
      if (c !== 0) {
        return c;
      }
      for (var i = 0; i < keysX.length; i++) {
        var v = compareNatural(x[keysX[i]], y[keysY[i]]);
        if (v !== 0) {
          return v;
        }
      }
      return 0;
    }
  });
  function compareComplexNumbers(x, y) {
    if (x.re > y.re) {
      return 1;
    }
    if (x.re < y.re) {
      return -1;
    }
    if (x.im > y.im) {
      return 1;
    }
    if (x.im < y.im) {
      return -1;
    }
    return 0;
  }

  // node_modules/mathjs/lib/esm/function/relational/compareText.js
  var name140 = "compareText";
  var dependencies141 = ["typed", "matrix"];
  compareText.signature = "any, any";
  var createCompareText = /* @__PURE__ */ factory(name140, dependencies141, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name140, compareText, matrixAlgorithmSuite({
      elop: compareText,
      Ds: true
    }));
  });

  // node_modules/mathjs/lib/esm/function/relational/equal.js
  var name141 = "equal";
  var dependencies142 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createEqual = /* @__PURE__ */ factory(name141, dependencies142, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name141, createEqualNumber({
      typed,
      equalScalar
    }), matrixAlgorithmSuite({
      elop: equalScalar,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createEqualNumber = factory(name141, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed,
      equalScalar
    } = _ref2;
    return typed(name141, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === void 0) {
          return y === void 0;
        }
        if (y === void 0) {
          return x === void 0;
        }
        return equalScalar(x, y);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/equalText.js
  var name142 = "equalText";
  var dependencies143 = ["typed", "compareText", "isZero"];
  var createEqualText = /* @__PURE__ */ factory(name142, dependencies143, (_ref) => {
    var {
      typed,
      compareText: compareText2,
      isZero
    } = _ref;
    return typed(name142, {
      "any, any": function anyAny(x, y) {
        return isZero(compareText2(x, y));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/smaller.js
  var name143 = "smaller";
  var dependencies144 = ["typed", "config", "matrix", "DenseMatrix"];
  var createSmaller = /* @__PURE__ */ factory(name143, dependencies144, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var compareUnits = createCompareUnits({
      typed
    });
    return typed(name143, createSmallerNumber({
      typed,
      config: config2
    }), {
      "boolean, boolean": (x, y) => x < y,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.lt(y) && !nearlyEqual2(x, y, config2.epsilon);
      },
      "Fraction, Fraction": (x, y) => x.compare(y) === -1,
      "Complex, Complex": function ComplexComplex(x, y) {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createSmallerNumber = /* @__PURE__ */ factory(name143, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config: config2
    } = _ref2;
    return typed(name143, {
      "number, number": function numberNumber(x, y) {
        return x < y && !nearlyEqual(x, y, config2.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/smallerEq.js
  var name144 = "smallerEq";
  var dependencies145 = ["typed", "config", "matrix", "DenseMatrix"];
  var createSmallerEq = /* @__PURE__ */ factory(name144, dependencies145, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var compareUnits = createCompareUnits({
      typed
    });
    return typed(name144, createSmallerEqNumber({
      typed,
      config: config2
    }), {
      "boolean, boolean": (x, y) => x <= y,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.lte(y) || nearlyEqual2(x, y, config2.epsilon);
      },
      "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createSmallerEqNumber = /* @__PURE__ */ factory(name144, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config: config2
    } = _ref2;
    return typed(name144, {
      "number, number": function numberNumber(x, y) {
        return x <= y || nearlyEqual(x, y, config2.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/larger.js
  var name145 = "larger";
  var dependencies146 = ["typed", "config", "matrix", "DenseMatrix"];
  var createLarger = /* @__PURE__ */ factory(name145, dependencies146, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var compareUnits = createCompareUnits({
      typed
    });
    return typed(name145, createLargerNumber({
      typed,
      config: config2
    }), {
      "boolean, boolean": (x, y) => x > y,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.gt(y) && !nearlyEqual2(x, y, config2.epsilon);
      },
      "Fraction, Fraction": (x, y) => x.compare(y) === 1,
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createLargerNumber = /* @__PURE__ */ factory(name145, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config: config2
    } = _ref2;
    return typed(name145, {
      "number, number": function numberNumber(x, y) {
        return x > y && !nearlyEqual(x, y, config2.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/largerEq.js
  var name146 = "largerEq";
  var dependencies147 = ["typed", "config", "matrix", "DenseMatrix"];
  var createLargerEq = /* @__PURE__ */ factory(name146, dependencies147, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    var compareUnits = createCompareUnits({
      typed
    });
    return typed(name146, createLargerEqNumber({
      typed,
      config: config2
    }), {
      "boolean, boolean": (x, y) => x >= y,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.gte(y) || nearlyEqual2(x, y, config2.epsilon);
      },
      "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createLargerEqNumber = /* @__PURE__ */ factory(name146, ["typed", "config"], (_ref2) => {
    var {
      typed,
      config: config2
    } = _ref2;
    return typed(name146, {
      "number, number": function numberNumber(x, y) {
        return x >= y || nearlyEqual(x, y, config2.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/deepEqual.js
  var name147 = "deepEqual";
  var dependencies148 = ["typed", "equal"];
  var createDeepEqual = /* @__PURE__ */ factory(name147, dependencies148, (_ref) => {
    var {
      typed,
      equal
    } = _ref;
    return typed(name147, {
      "any, any": function anyAny(x, y) {
        return _deepEqual(x.valueOf(), y.valueOf());
      }
    });
    function _deepEqual(x, y) {
      if (Array.isArray(x)) {
        if (Array.isArray(y)) {
          var len = x.length;
          if (len !== y.length) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            if (!_deepEqual(x[i], y[i])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      } else {
        if (Array.isArray(y)) {
          return false;
        } else {
          return equal(x, y);
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/unequal.js
  var name148 = "unequal";
  var dependencies149 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix"];
  var createUnequal = /* @__PURE__ */ factory(name148, dependencies149, (_ref) => {
    var {
      typed,
      config: config2,
      equalScalar,
      matrix,
      DenseMatrix
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed,
      DenseMatrix
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name148, createUnequalNumber({
      typed,
      equalScalar
    }), matrixAlgorithmSuite({
      elop: _unequal,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
    function _unequal(x, y) {
      return !equalScalar(x, y);
    }
  });
  var createUnequalNumber = factory(name148, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed,
      equalScalar
    } = _ref2;
    return typed(name148, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y !== null;
        }
        if (y === null) {
          return x !== null;
        }
        if (x === void 0) {
          return y !== void 0;
        }
        if (y === void 0) {
          return x !== void 0;
        }
        return !equalScalar(x, y);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
  var name149 = "partitionSelect";
  var dependencies150 = ["typed", "isNumeric", "isNaN", "compare"];
  var createPartitionSelect = /* @__PURE__ */ factory(name149, dependencies150, (_ref) => {
    var {
      typed,
      isNumeric,
      isNaN: isNaN2,
      compare
    } = _ref;
    var asc = compare;
    var desc = (a, b) => -compare(a, b);
    return typed(name149, {
      "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
        return _partitionSelect(x, k, asc);
      },
      "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare2) {
        if (compare2 === "asc") {
          return _partitionSelect(x, k, asc);
        } else if (compare2 === "desc") {
          return _partitionSelect(x, k, desc);
        } else {
          throw new Error('Compare string must be "asc" or "desc"');
        }
      },
      "Array | Matrix, number, function": _partitionSelect
    });
    function _partitionSelect(x, k, compare2) {
      if (!isInteger(k) || k < 0) {
        throw new Error("k must be a non-negative integer");
      }
      if (isMatrix(x)) {
        var size = x.size();
        if (size.length > 1) {
          throw new Error("Only one dimensional matrices supported");
        }
        return quickSelect(x.valueOf(), k, compare2);
      }
      if (Array.isArray(x)) {
        return quickSelect(x, k, compare2);
      }
    }
    function quickSelect(arr, k, compare2) {
      if (k >= arr.length) {
        throw new Error("k out of bounds");
      }
      for (var i = 0; i < arr.length; i++) {
        if (isNumeric(arr[i]) && isNaN2(arr[i])) {
          return arr[i];
        }
      }
      var from = 0;
      var to = arr.length - 1;
      while (from < to) {
        var r = from;
        var w = to;
        var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];
        while (r < w) {
          if (compare2(arr[r], pivot) >= 0) {
            var tmp = arr[w];
            arr[w] = arr[r];
            arr[r] = tmp;
            --w;
          } else {
            ++r;
          }
        }
        if (compare2(arr[r], pivot) > 0) {
          --r;
        }
        if (k <= r) {
          to = r;
        } else {
          from = r + 1;
        }
      }
      return arr[k];
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sort.js
  var name150 = "sort";
  var dependencies151 = ["typed", "matrix", "compare", "compareNatural"];
  var createSort = /* @__PURE__ */ factory(name150, dependencies151, (_ref) => {
    var {
      typed,
      matrix,
      compare,
      compareNatural
    } = _ref;
    var compareAsc = compare;
    var compareDesc = (a, b) => -compare(a, b);
    return typed(name150, {
      Array: function Array2(x) {
        _arrayIsVector(x);
        return x.sort(compareAsc);
      },
      Matrix: function Matrix(x) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(compareAsc), x.storage());
      },
      "Array, function": function ArrayFunction(x, _comparator2) {
        _arrayIsVector(x);
        return x.sort(_comparator2);
      },
      "Matrix, function": function MatrixFunction(x, _comparator2) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(_comparator2), x.storage());
      },
      "Array, string": function ArrayString(x, order) {
        _arrayIsVector(x);
        return x.sort(_comparator(order));
      },
      "Matrix, string": function MatrixString(x, order) {
        _matrixIsVector(x);
        return matrix(x.toArray().sort(_comparator(order)), x.storage());
      }
    });
    function _comparator(order) {
      if (order === "asc") {
        return compareAsc;
      } else if (order === "desc") {
        return compareDesc;
      } else if (order === "natural") {
        return compareNatural;
      } else {
        throw new Error('String "asc", "desc", or "natural" expected');
      }
    }
    function _arrayIsVector(array) {
      if (arraySize(array).length !== 1) {
        throw new Error("One dimensional array expected");
      }
    }
    function _matrixIsVector(matrix2) {
      if (matrix2.size().length !== 1) {
        throw new Error("One dimensional matrix expected");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/max.js
  var name151 = "max";
  var dependencies152 = ["typed", "config", "numeric", "larger"];
  var createMax = /* @__PURE__ */ factory(name151, dependencies152, (_ref) => {
    var {
      typed,
      config: config2,
      numeric: numeric2,
      larger
    } = _ref;
    return typed(name151, {
      "Array | Matrix": _max,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _largest);
      },
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function max");
        }
        return _max(args);
      }
    });
    function _largest(x, y) {
      try {
        return larger(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, "max", y);
      }
    }
    function _max(array) {
      var res;
      deepForEach(array, function(value) {
        try {
          if (isNaN(value) && typeof value === "number") {
            res = NaN;
          } else if (res === void 0 || larger(value, res)) {
            res = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "max", value);
        }
      });
      if (res === void 0) {
        throw new Error("Cannot calculate max of an empty array");
      }
      if (typeof res === "string") {
        res = numeric2(res, config2.number);
      }
      return res;
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/min.js
  var name152 = "min";
  var dependencies153 = ["typed", "config", "numeric", "smaller"];
  var createMin = /* @__PURE__ */ factory(name152, dependencies153, (_ref) => {
    var {
      typed,
      config: config2,
      numeric: numeric2,
      smaller
    } = _ref;
    return typed(name152, {
      "Array | Matrix": _min,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _smallest);
      },
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function min");
        }
        return _min(args);
      }
    });
    function _smallest(x, y) {
      try {
        return smaller(x, y) ? x : y;
      } catch (err) {
        throw improveErrorMessage(err, "min", y);
      }
    }
    function _min(array) {
      var min2;
      deepForEach(array, function(value) {
        try {
          if (isNaN(value) && typeof value === "number") {
            min2 = NaN;
          } else if (min2 === void 0 || smaller(value, min2)) {
            min2 = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "min", value);
        }
      });
      if (min2 === void 0) {
        throw new Error("Cannot calculate min of an empty array");
      }
      if (typeof min2 === "string") {
        min2 = numeric2(min2, config2.number);
      }
      return min2;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
  var name153 = "ImmutableDenseMatrix";
  var dependencies154 = ["smaller", "DenseMatrix"];
  var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name153, dependencies154, (_ref) => {
    var {
      smaller,
      DenseMatrix
    } = _ref;
    function ImmutableDenseMatrix(data, datatype) {
      if (!(this instanceof ImmutableDenseMatrix)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data) || isArray(data)) {
        var matrix = new DenseMatrix(data, datatype);
        this._data = matrix._data;
        this._size = matrix._size;
        this._datatype = matrix._datatype;
        this._min = null;
        this._max = null;
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        this._datatype = data.datatype;
        this._min = typeof data.min !== "undefined" ? data.min : null;
        this._max = typeof data.max !== "undefined" ? data.max : null;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
        this._min = null;
        this._max = null;
      }
    }
    ImmutableDenseMatrix.prototype = new DenseMatrix();
    ImmutableDenseMatrix.prototype.type = "ImmutableDenseMatrix";
    ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
    ImmutableDenseMatrix.prototype.subset = function(index) {
      switch (arguments.length) {
        case 1: {
          var m = DenseMatrix.prototype.subset.call(this, index);
          if (isMatrix(m)) {
            return new ImmutableDenseMatrix({
              data: m._data,
              size: m._size,
              datatype: m._datatype
            });
          }
          return m;
        }
        case 2:
        case 3:
          throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    ImmutableDenseMatrix.prototype.set = function() {
      throw new Error("Cannot invoke set on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.resize = function() {
      throw new Error("Cannot invoke resize on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.reshape = function() {
      throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.clone = function() {
      return new ImmutableDenseMatrix({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
    };
    ImmutableDenseMatrix.prototype.toJSON = function() {
      return {
        mathjs: "ImmutableDenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    ImmutableDenseMatrix.fromJSON = function(json) {
      return new ImmutableDenseMatrix(json);
    };
    ImmutableDenseMatrix.prototype.swapRows = function() {
      throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix.prototype.min = function() {
      if (this._min === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller(v, m)) {
            m = v;
          }
        });
        this._min = m !== null ? m : void 0;
      }
      return this._min;
    };
    ImmutableDenseMatrix.prototype.max = function() {
      if (this._max === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller(m, v)) {
            m = v;
          }
        });
        this._max = m !== null ? m : void 0;
      }
      return this._max;
    };
    return ImmutableDenseMatrix;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
  var name154 = "Index";
  var dependencies155 = ["ImmutableDenseMatrix"];
  var createIndexClass = /* @__PURE__ */ factory(name154, dependencies155, (_ref) => {
    var {
      ImmutableDenseMatrix
    } = _ref;
    function Index(ranges) {
      if (!(this instanceof Index)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._dimensions = [];
      this._isScalar = true;
      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];
        if (isRange(arg)) {
          this._dimensions.push(arg);
          this._isScalar = false;
        } else if (Array.isArray(arg) || isMatrix(arg)) {
          var m = _createImmutableMatrix(arg.valueOf());
          this._dimensions.push(m);
          var size = m.size();
          if (size.length !== 1 || size[0] !== 1) {
            this._isScalar = false;
          }
        } else if (typeof arg === "number") {
          this._dimensions.push(_createImmutableMatrix([arg]));
        } else if (typeof arg === "string") {
          this._dimensions.push(arg);
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
      }
    }
    Index.prototype.type = "Index";
    Index.prototype.isIndex = true;
    function _createImmutableMatrix(arg) {
      for (var i = 0, l = arg.length; i < l; i++) {
        if (typeof arg[i] !== "number" || !isInteger(arg[i])) {
          throw new TypeError("Index parameters must be positive integer numbers");
        }
      }
      return new ImmutableDenseMatrix(arg);
    }
    Index.prototype.clone = function() {
      var index = new Index();
      index._dimensions = clone(this._dimensions);
      index._isScalar = this._isScalar;
      return index;
    };
    Index.create = function(ranges) {
      var index = new Index();
      Index.apply(index, ranges);
      return index;
    };
    Index.prototype.size = function() {
      var size = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var d = this._dimensions[i];
        size[i] = typeof d === "string" ? 1 : d.size()[0];
      }
      return size;
    };
    Index.prototype.max = function() {
      var values2 = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values2[i] = typeof range === "string" ? range : range.max();
      }
      return values2;
    };
    Index.prototype.min = function() {
      var values2 = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values2[i] = typeof range === "string" ? range : range.min();
      }
      return values2;
    };
    Index.prototype.forEach = function(callback) {
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        callback(this._dimensions[i], i, this);
      }
    };
    Index.prototype.dimension = function(dim) {
      return this._dimensions[dim] || null;
    };
    Index.prototype.isObjectProperty = function() {
      return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
    };
    Index.prototype.getObjectProperty = function() {
      return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    Index.prototype.isScalar = function() {
      return this._isScalar;
    };
    Index.prototype.toArray = function() {
      var array = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        array.push(typeof dimension === "string" ? dimension : dimension.toArray());
      }
      return array;
    };
    Index.prototype.valueOf = Index.prototype.toArray;
    Index.prototype.toString = function() {
      var strings = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        if (typeof dimension === "string") {
          strings.push(JSON.stringify(dimension));
        } else {
          strings.push(dimension.toString());
        }
      }
      return "[" + strings.join(", ") + "]";
    };
    Index.prototype.toJSON = function() {
      return {
        mathjs: "Index",
        dimensions: this._dimensions
      };
    };
    Index.fromJSON = function(json) {
      return Index.create(json.dimensions);
    };
    return Index;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
  var name155 = "FibonacciHeap";
  var dependencies156 = ["smaller", "larger"];
  var createFibonacciHeapClass = /* @__PURE__ */ factory(name155, dependencies156, (_ref) => {
    var {
      smaller,
      larger
    } = _ref;
    var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
    function FibonacciHeap() {
      if (!(this instanceof FibonacciHeap)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._minimum = null;
      this._size = 0;
    }
    FibonacciHeap.prototype.type = "FibonacciHeap";
    FibonacciHeap.prototype.isFibonacciHeap = true;
    FibonacciHeap.prototype.insert = function(key, value) {
      var node = {
        key,
        value,
        degree: 0
      };
      if (this._minimum) {
        var minimum = this._minimum;
        node.left = minimum;
        node.right = minimum.right;
        minimum.right = node;
        node.right.left = node;
        if (smaller(key, minimum.key)) {
          this._minimum = node;
        }
      } else {
        node.left = node;
        node.right = node;
        this._minimum = node;
      }
      this._size++;
      return node;
    };
    FibonacciHeap.prototype.size = function() {
      return this._size;
    };
    FibonacciHeap.prototype.clear = function() {
      this._minimum = null;
      this._size = 0;
    };
    FibonacciHeap.prototype.isEmpty = function() {
      return this._size === 0;
    };
    FibonacciHeap.prototype.extractMinimum = function() {
      var node = this._minimum;
      if (node === null) {
        return node;
      }
      var minimum = this._minimum;
      var numberOfChildren = node.degree;
      var x = node.child;
      while (numberOfChildren > 0) {
        var tempRight = x.right;
        x.left.right = x.right;
        x.right.left = x.left;
        x.left = minimum;
        x.right = minimum.right;
        minimum.right = x;
        x.right.left = x;
        x.parent = null;
        x = tempRight;
        numberOfChildren--;
      }
      node.left.right = node.right;
      node.right.left = node.left;
      if (node === node.right) {
        minimum = null;
      } else {
        minimum = node.right;
        minimum = _findMinimumNode(minimum, this._size);
      }
      this._size--;
      this._minimum = minimum;
      return node;
    };
    FibonacciHeap.prototype.remove = function(node) {
      this._minimum = _decreaseKey(this._minimum, node, -1);
      this.extractMinimum();
    };
    function _decreaseKey(minimum, node, key) {
      node.key = key;
      var parent = node.parent;
      if (parent && smaller(node.key, parent.key)) {
        _cut(minimum, node, parent);
        _cascadingCut(minimum, parent);
      }
      if (smaller(node.key, minimum.key)) {
        minimum = node;
      }
      return minimum;
    }
    function _cut(minimum, node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      parent.degree--;
      if (parent.child === node) {
        parent.child = node.right;
      }
      if (parent.degree === 0) {
        parent.child = null;
      }
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      node.parent = null;
      node.mark = false;
    }
    function _cascadingCut(minimum, node) {
      var parent = node.parent;
      if (!parent) {
        return;
      }
      if (!node.mark) {
        node.mark = true;
      } else {
        _cut(minimum, node, parent);
        _cascadingCut(parent);
      }
    }
    var _linkNodes = function _linkNodes2(node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      node.parent = parent;
      if (!parent.child) {
        parent.child = node;
        node.right = node;
        node.left = node;
      } else {
        node.left = parent.child;
        node.right = parent.child.right;
        parent.child.right = node;
        node.right.left = node;
      }
      parent.degree++;
      node.mark = false;
    };
    function _findMinimumNode(minimum, size) {
      var arraySize2 = Math.floor(Math.log(size) * oneOverLogPhi) + 1;
      var array = new Array(arraySize2);
      var numRoots = 0;
      var x = minimum;
      if (x) {
        numRoots++;
        x = x.right;
        while (x !== minimum) {
          numRoots++;
          x = x.right;
        }
      }
      var y;
      while (numRoots > 0) {
        var d = x.degree;
        var next = x.right;
        while (true) {
          y = array[d];
          if (!y) {
            break;
          }
          if (larger(x.key, y.key)) {
            var temp = y;
            y = x;
            x = temp;
          }
          _linkNodes(y, x);
          array[d] = null;
          d++;
        }
        array[d] = x;
        x = next;
        numRoots--;
      }
      minimum = null;
      for (var i = 0; i < arraySize2; i++) {
        y = array[i];
        if (!y) {
          continue;
        }
        if (minimum) {
          y.left.right = y.right;
          y.right.left = y.left;
          y.left = minimum;
          y.right = minimum.right;
          minimum.right = y;
          y.right.left = y;
          if (smaller(y.key, minimum.key)) {
            minimum = y;
          }
        } else {
          minimum = y;
        }
      }
      return minimum;
    }
    return FibonacciHeap;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Spa.js
  var name156 = "Spa";
  var dependencies157 = ["addScalar", "equalScalar", "FibonacciHeap"];
  var createSpaClass = /* @__PURE__ */ factory(name156, dependencies157, (_ref) => {
    var {
      addScalar,
      equalScalar,
      FibonacciHeap
    } = _ref;
    function Spa() {
      if (!(this instanceof Spa)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._values = [];
      this._heap = new FibonacciHeap();
    }
    Spa.prototype.type = "Spa";
    Spa.prototype.isSpa = true;
    Spa.prototype.set = function(i, v) {
      if (!this._values[i]) {
        var node = this._heap.insert(i, v);
        this._values[i] = node;
      } else {
        this._values[i].value = v;
      }
    };
    Spa.prototype.get = function(i) {
      var node = this._values[i];
      if (node) {
        return node.value;
      }
      return 0;
    };
    Spa.prototype.accumulate = function(i, v) {
      var node = this._values[i];
      if (!node) {
        node = this._heap.insert(i, v);
        this._values[i] = node;
      } else {
        node.value = addScalar(node.value, v);
      }
    };
    Spa.prototype.forEach = function(from, to, callback) {
      var heap = this._heap;
      var values2 = this._values;
      var nodes = [];
      var node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
      while (node && node.key <= to) {
        if (node.key >= from) {
          if (!equalScalar(node.value, 0)) {
            callback(node.key, node.value, this);
          }
        }
        node = heap.extractMinimum();
        if (node) {
          nodes.push(node);
        }
      }
      for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        node = heap.insert(n.key, n.value);
        values2[node.key] = node;
      }
    };
    Spa.prototype.swap = function(i, j) {
      var nodei = this._values[i];
      var nodej = this._values[j];
      if (!nodei && nodej) {
        nodei = this._heap.insert(i, nodej.value);
        this._heap.remove(nodej);
        this._values[i] = nodei;
        this._values[j] = void 0;
      } else if (nodei && !nodej) {
        nodej = this._heap.insert(j, nodei.value);
        this._heap.remove(nodei);
        this._values[j] = nodej;
        this._values[i] = void 0;
      } else if (nodei && nodej) {
        var v = nodei.value;
        nodei.value = nodej.value;
        nodej.value = v;
      }
    };
    return Spa;
  }, {
    isClass: true
  });

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/mathjs/lib/esm/utils/bignumber/constants.js
  var createBigNumberE = memoize(function(BigNumber) {
    return new BigNumber(1).exp();
  }, {
    hasher
  });
  var createBigNumberPhi = memoize(function(BigNumber) {
    return new BigNumber(1).plus(new BigNumber(5).sqrt()).div(2);
  }, {
    hasher
  });
  var createBigNumberPi = memoize(function(BigNumber) {
    return BigNumber.acos(-1);
  }, {
    hasher
  });
  var createBigNumberTau = memoize(function(BigNumber) {
    return createBigNumberPi(BigNumber).times(2);
  }, {
    hasher
  });
  function hasher(args) {
    return args[0].precision;
  }

  // node_modules/mathjs/lib/esm/type/unit/Unit.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var name157 = "Unit";
  var dependencies158 = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
  var createUnitClass = /* @__PURE__ */ factory(name157, dependencies158, (_ref) => {
    var {
      on,
      config: config2,
      addScalar,
      subtract,
      multiplyScalar,
      divideScalar,
      pow: pow2,
      abs: abs2,
      fix,
      round: round2,
      equal,
      isNumeric,
      format: format4,
      number,
      Complex: Complex2,
      BigNumber: _BigNumber,
      Fraction: _Fraction
    } = _ref;
    var toNumber = number;
    function Unit(value, valuelessUnit) {
      if (!(this instanceof Unit)) {
        throw new Error("Constructor must be called with the new operator");
      }
      if (!(value === null || value === void 0 || isNumeric(value) || isComplex(value))) {
        throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
      }
      this.fixPrefix = false;
      this.skipAutomaticSimplification = true;
      if (valuelessUnit === void 0) {
        this.units = [];
        this.dimensions = BASE_DIMENSIONS.map((x) => 0);
      } else if (typeof valuelessUnit === "string") {
        var u = Unit.parse(valuelessUnit);
        this.units = u.units;
        this.dimensions = u.dimensions;
      } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
        this.fixPrefix = valuelessUnit.fixPrefix;
        this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
        this.dimensions = valuelessUnit.dimensions.slice(0);
        this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
      } else {
        throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
      }
      this.value = this._normalize(value);
    }
    Object.defineProperty(Unit, "name", {
      value: "Unit"
    });
    Unit.prototype.constructor = Unit;
    Unit.prototype.type = "Unit";
    Unit.prototype.isUnit = true;
    var text, index, c;
    function skipWhitespace() {
      while (c === " " || c === "	") {
        next();
      }
    }
    function isDigitDot(c2) {
      return c2 >= "0" && c2 <= "9" || c2 === ".";
    }
    function isDigit(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function next() {
      index++;
      c = text.charAt(index);
    }
    function revert(oldIndex) {
      index = oldIndex;
      c = text.charAt(index);
    }
    function parseNumber() {
      var number2 = "";
      var oldIndex = index;
      if (c === "+") {
        next();
      } else if (c === "-") {
        number2 += c;
        next();
      }
      if (!isDigitDot(c)) {
        revert(oldIndex);
        return null;
      }
      if (c === ".") {
        number2 += c;
        next();
        if (!isDigit(c)) {
          revert(oldIndex);
          return null;
        }
      } else {
        while (isDigit(c)) {
          number2 += c;
          next();
        }
        if (c === ".") {
          number2 += c;
          next();
        }
      }
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === "E" || c === "e") {
        var tentativeNumber = "";
        var tentativeIndex = index;
        tentativeNumber += c;
        next();
        if (c === "+" || c === "-") {
          tentativeNumber += c;
          next();
        }
        if (!isDigit(c)) {
          revert(tentativeIndex);
          return number2;
        }
        number2 = number2 + tentativeNumber;
        while (isDigit(c)) {
          number2 += c;
          next();
        }
      }
      return number2;
    }
    function parseUnit() {
      var unitName = "";
      while (isDigit(c) || Unit.isValidAlpha(c)) {
        unitName += c;
        next();
      }
      var firstC = unitName.charAt(0);
      if (Unit.isValidAlpha(firstC)) {
        return unitName;
      } else {
        return null;
      }
    }
    function parseCharacter(toFind) {
      if (c === toFind) {
        next();
        return toFind;
      } else {
        return null;
      }
    }
    Unit.parse = function(str, options) {
      options = options || {};
      text = str;
      index = -1;
      c = "";
      if (typeof text !== "string") {
        throw new TypeError("Invalid argument in Unit.parse, string expected");
      }
      var unit2 = new Unit();
      unit2.units = [];
      var powerMultiplierCurrent = 1;
      var expectingUnit = false;
      next();
      skipWhitespace();
      var valueStr = parseNumber();
      var value = null;
      if (valueStr) {
        if (config2.number === "BigNumber") {
          value = new _BigNumber(valueStr);
        } else if (config2.number === "Fraction") {
          try {
            value = new _Fraction(valueStr);
          } catch (err) {
            value = parseFloat(valueStr);
          }
        } else {
          value = parseFloat(valueStr);
        }
        skipWhitespace();
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        }
      }
      var powerMultiplierStack = [];
      var powerMultiplierStackProduct = 1;
      while (true) {
        skipWhitespace();
        while (c === "(") {
          powerMultiplierStack.push(powerMultiplierCurrent);
          powerMultiplierStackProduct *= powerMultiplierCurrent;
          powerMultiplierCurrent = 1;
          next();
          skipWhitespace();
        }
        var uStr = void 0;
        if (c) {
          var oldC = c;
          uStr = parseUnit();
          if (uStr === null) {
            throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
          }
        } else {
          break;
        }
        var res = _findUnit(uStr);
        if (res === null) {
          throw new SyntaxError('Unit "' + uStr + '" not found.');
        }
        var power = powerMultiplierCurrent * powerMultiplierStackProduct;
        skipWhitespace();
        if (parseCharacter("^")) {
          skipWhitespace();
          var p = parseNumber();
          if (p === null) {
            throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
          }
          power *= p;
        }
        unit2.units.push({
          unit: res.unit,
          prefix: res.prefix,
          power
        });
        for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
          unit2.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
        }
        skipWhitespace();
        while (c === ")") {
          if (powerMultiplierStack.length === 0) {
            throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
          }
          powerMultiplierStackProduct /= powerMultiplierStack.pop();
          next();
          skipWhitespace();
        }
        expectingUnit = false;
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        } else {
          powerMultiplierCurrent = 1;
        }
        if (res.unit.base) {
          var baseDim = res.unit.base.key;
          UNIT_SYSTEMS.auto[baseDim] = {
            unit: res.unit,
            prefix: res.prefix
          };
        }
      }
      skipWhitespace();
      if (c) {
        throw new SyntaxError('Could not parse: "' + str + '"');
      }
      if (expectingUnit) {
        throw new SyntaxError('Trailing characters: "' + str + '"');
      }
      if (powerMultiplierStack.length !== 0) {
        throw new SyntaxError('Unmatched "(" in "' + text + '"');
      }
      if (unit2.units.length === 0 && !options.allowNoUnits) {
        throw new SyntaxError('"' + str + '" contains no units');
      }
      unit2.value = value !== void 0 ? unit2._normalize(value) : null;
      return unit2;
    };
    Unit.prototype.clone = function() {
      var unit2 = new Unit();
      unit2.fixPrefix = this.fixPrefix;
      unit2.skipAutomaticSimplification = this.skipAutomaticSimplification;
      unit2.value = clone(this.value);
      unit2.dimensions = this.dimensions.slice(0);
      unit2.units = [];
      for (var i = 0; i < this.units.length; i++) {
        unit2.units[i] = {};
        for (var p in this.units[i]) {
          if (hasOwnProperty2(this.units[i], p)) {
            unit2.units[i][p] = this.units[i][p];
          }
        }
      }
      return unit2;
    };
    Unit.prototype.valueType = function() {
      return typeOf(this.value);
    };
    Unit.prototype._isDerived = function() {
      if (this.units.length === 0) {
        return false;
      }
      return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
    };
    Unit.prototype._normalize = function(value) {
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      }
      var res = value;
      var convert = Unit._getNumberConverter(typeOf(value));
      for (var i = 0; i < this.units.length; i++) {
        var unitValue = convert(this.units[i].unit.value);
        var unitPrefixValue = convert(this.units[i].prefix.value);
        var unitPower = convert(this.units[i].power);
        res = multiplyScalar(res, pow2(multiplyScalar(unitValue, unitPrefixValue), unitPower));
      }
      return res;
    };
    Unit.prototype._denormalize = function(value, prefixValue) {
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      }
      var res = value;
      var convert = Unit._getNumberConverter(typeOf(value));
      for (var i = 0; i < this.units.length; i++) {
        var unitValue = convert(this.units[i].unit.value);
        var unitPrefixValue = convert(this.units[i].prefix.value);
        var unitPower = convert(this.units[i].power);
        res = divideScalar(res, pow2(multiplyScalar(unitValue, unitPrefixValue), unitPower));
      }
      return res;
    };
    var _findUnit = memoize((str) => {
      if (hasOwnProperty2(UNITS, str)) {
        var unit2 = UNITS[str];
        var prefix = unit2.prefixes[""];
        return {
          unit: unit2,
          prefix
        };
      }
      for (var _name in UNITS) {
        if (hasOwnProperty2(UNITS, _name)) {
          if (endsWith(str, _name)) {
            var _unit = UNITS[_name];
            var prefixLen = str.length - _name.length;
            var prefixName = str.substring(0, prefixLen);
            var _prefix = hasOwnProperty2(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
            if (_prefix !== void 0) {
              return {
                unit: _unit,
                prefix: _prefix
              };
            }
          }
        }
      }
      return null;
    }, {
      hasher: (args) => args[0],
      limit: 100
    });
    Unit.isValuelessUnit = function(name297) {
      return _findUnit(name297) !== null;
    };
    Unit.prototype.hasBase = function(base) {
      if (typeof base === "string") {
        base = BASE_UNITS[base];
      }
      if (!base) {
        return false;
      }
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit.prototype.equalBase = function(other) {
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit.prototype.equals = function(other) {
      return this.equalBase(other) && equal(this.value, other.value);
    };
    Unit.prototype.multiply = function(_other) {
      var res = this.clone();
      var other = isUnit(_other) ? _other : new Unit(_other);
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
      }
      for (var _i = 0; _i < other.units.length; _i++) {
        var inverted = _objectSpread({}, other.units[_i]);
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = multiplyScalar(valThis, valOther);
      } else {
        res.value = null;
      }
      if (isUnit(_other)) {
        res.skipAutomaticSimplification = false;
      }
      return getNumericIfUnitless(res);
    };
    Unit.prototype.divideInto = function(numerator) {
      return new Unit(numerator).divide(this);
    };
    Unit.prototype.divide = function(_other) {
      var res = this.clone();
      var other = isUnit(_other) ? _other : new Unit(_other);
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
      }
      for (var _i2 = 0; _i2 < other.units.length; _i2++) {
        var inverted = _objectSpread(_objectSpread({}, other.units[_i2]), {}, {
          power: -other.units[_i2].power
        });
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = divideScalar(valThis, valOther);
      } else {
        res.value = null;
      }
      if (isUnit(_other)) {
        res.skipAutomaticSimplification = false;
      }
      return getNumericIfUnitless(res);
    };
    Unit.prototype.pow = function(p) {
      var res = this.clone();
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        res.dimensions[i] = (this.dimensions[i] || 0) * p;
      }
      for (var _i3 = 0; _i3 < res.units.length; _i3++) {
        res.units[_i3].power *= p;
      }
      if (res.value !== null) {
        res.value = pow2(res.value, p);
      } else {
        res.value = null;
      }
      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    function getNumericIfUnitless(unit2) {
      if (unit2.equalBase(BASE_UNITS.NONE) && unit2.value !== null && !config2.predictable) {
        return unit2.value;
      } else {
        return unit2;
      }
    }
    Unit.prototype.abs = function() {
      var ret = this.clone();
      if (ret.value !== null) {
        if (ret._isDerived() || ret.units[0].unit.offset === 0) {
          ret.value = abs2(ret.value);
        } else {
          var convert = ret._numberConverter();
          var unitValue = convert(ret.units[0].unit.value);
          var nominalOffset = convert(ret.units[0].unit.offset);
          var unitOffset = multiplyScalar(unitValue, nominalOffset);
          ret.value = subtract(abs2(addScalar(ret.value, unitOffset)), unitOffset);
        }
      }
      for (var i in ret.units) {
        if (ret.units[i].unit.name === "VA" || ret.units[i].unit.name === "VAR") {
          ret.units[i].unit = UNITS.W;
        }
      }
      return ret;
    };
    Unit.prototype.to = function(valuelessUnit) {
      var value = this.value === null ? this._normalize(1) : this.value;
      var other;
      if (typeof valuelessUnit === "string") {
        other = Unit.parse(valuelessUnit);
      } else if (isUnit(valuelessUnit)) {
        other = valuelessUnit.clone();
      } else {
        throw new Error("String or Unit expected as parameter");
      }
      if (!this.equalBase(other)) {
        throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
      }
      if (other.value !== null) {
        throw new Error("Cannot convert to a unit with a value");
      }
      if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
        other.value = clone(value);
      } else {
        var convert = Unit._getNumberConverter(typeOf(value));
        var thisUnitValue = convert(this.units[0].unit.value);
        var thisNominalOffset = convert(this.units[0].unit.offset);
        var thisUnitOffset = multiplyScalar(thisUnitValue, thisNominalOffset);
        var otherUnitValue = convert(other.units[0].unit.value);
        var otherNominalOffset = convert(other.units[0].unit.offset);
        var otherUnitOffset = multiplyScalar(otherUnitValue, otherNominalOffset);
        other.value = subtract(addScalar(value, thisUnitOffset), otherUnitOffset);
      }
      other.fixPrefix = true;
      other.skipAutomaticSimplification = true;
      return other;
    };
    Unit.prototype.toNumber = function(valuelessUnit) {
      return toNumber(this.toNumeric(valuelessUnit));
    };
    Unit.prototype.toNumeric = function(valuelessUnit) {
      var other;
      if (valuelessUnit) {
        other = this.to(valuelessUnit);
      } else {
        other = this.clone();
      }
      if (other._isDerived() || other.units.length === 0) {
        return other._denormalize(other.value);
      } else {
        return other._denormalize(other.value, other.units[0].prefix.value);
      }
    };
    Unit.prototype.toString = function() {
      return this.format();
    };
    Unit.prototype.toJSON = function() {
      return {
        mathjs: "Unit",
        value: this._denormalize(this.value),
        unit: this.formatUnits(),
        fixPrefix: this.fixPrefix
      };
    };
    Unit.fromJSON = function(json) {
      var unit2 = new Unit(json.value, json.unit);
      unit2.fixPrefix = json.fixPrefix || false;
      return unit2;
    };
    Unit.prototype.valueOf = Unit.prototype.toString;
    Unit.prototype.simplify = function() {
      var ret = this.clone();
      var proposedUnitList = [];
      var matchingBase;
      for (var key2 in currentUnitSystem) {
        if (hasOwnProperty2(currentUnitSystem, key2)) {
          if (ret.hasBase(BASE_UNITS[key2])) {
            matchingBase = key2;
            break;
          }
        }
      }
      if (matchingBase === "NONE") {
        ret.units = [];
      } else {
        var matchingUnit;
        if (matchingBase) {
          if (hasOwnProperty2(currentUnitSystem, matchingBase)) {
            matchingUnit = currentUnitSystem[matchingBase];
          }
        }
        if (matchingUnit) {
          ret.units = [{
            unit: matchingUnit.unit,
            prefix: matchingUnit.prefix,
            power: 1
          }];
        } else {
          var missingBaseDim = false;
          for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
            var baseDim = BASE_DIMENSIONS[i];
            if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
              if (hasOwnProperty2(currentUnitSystem, baseDim)) {
                proposedUnitList.push({
                  unit: currentUnitSystem[baseDim].unit,
                  prefix: currentUnitSystem[baseDim].prefix,
                  power: ret.dimensions[i] || 0
                });
              } else {
                missingBaseDim = true;
              }
            }
          }
          if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
            ret.units = proposedUnitList;
          }
        }
      }
      return ret;
    };
    Unit.prototype.toSI = function() {
      var ret = this.clone();
      var proposedUnitList = [];
      for (var i = 0; i < BASE_DIMENSIONS.length; i++) {
        var baseDim = BASE_DIMENSIONS[i];
        if (Math.abs(ret.dimensions[i] || 0) > 1e-12) {
          if (hasOwnProperty2(UNIT_SYSTEMS.si, baseDim)) {
            proposedUnitList.push({
              unit: UNIT_SYSTEMS.si[baseDim].unit,
              prefix: UNIT_SYSTEMS.si[baseDim].prefix,
              power: ret.dimensions[i] || 0
            });
          } else {
            throw new Error("Cannot express custom unit " + baseDim + " in SI units");
          }
        }
      }
      ret.units = proposedUnitList;
      ret.fixPrefix = true;
      ret.skipAutomaticSimplification = true;
      return ret;
    };
    Unit.prototype.formatUnits = function() {
      var strNum = "";
      var strDen = "";
      var nNum = 0;
      var nDen = 0;
      for (var i = 0; i < this.units.length; i++) {
        if (this.units[i].power > 0) {
          nNum++;
          strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
          if (Math.abs(this.units[i].power - 1) > 1e-15) {
            strNum += "^" + this.units[i].power;
          }
        } else if (this.units[i].power < 0) {
          nDen++;
        }
      }
      if (nDen > 0) {
        for (var _i4 = 0; _i4 < this.units.length; _i4++) {
          if (this.units[_i4].power < 0) {
            if (nNum > 0) {
              strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
                strDen += "^" + -this.units[_i4].power;
              }
            } else {
              strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              strDen += "^" + this.units[_i4].power;
            }
          }
        }
      }
      strNum = strNum.substr(1);
      strDen = strDen.substr(1);
      if (nNum > 1 && nDen > 0) {
        strNum = "(" + strNum + ")";
      }
      if (nDen > 1 && nNum > 0) {
        strDen = "(" + strDen + ")";
      }
      var str = strNum;
      if (nNum > 0 && nDen > 0) {
        str += " / ";
      }
      str += strDen;
      return str;
    };
    Unit.prototype.format = function(options) {
      var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
      var isImaginary = false;
      if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
        isImaginary = Math.abs(simp.value.re) < 1e-14;
      }
      for (var i in simp.units) {
        if (hasOwnProperty2(simp.units, i)) {
          if (simp.units[i].unit) {
            if (simp.units[i].unit.name === "VA" && isImaginary) {
              simp.units[i].unit = UNITS.VAR;
            } else if (simp.units[i].unit.name === "VAR" && !isImaginary) {
              simp.units[i].unit = UNITS.VA;
            }
          }
        }
      }
      if (simp.units.length === 1 && !simp.fixPrefix) {
        if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
          simp.units[0].prefix = simp._bestPrefix();
        }
      }
      var value = simp._denormalize(simp.value);
      var str = simp.value !== null ? format4(value, options || {}) : "";
      var unitStr = simp.formatUnits();
      if (simp.value && isComplex(simp.value)) {
        str = "(" + str + ")";
      }
      if (unitStr.length > 0 && str.length > 0) {
        str += " ";
      }
      str += unitStr;
      return str;
    };
    Unit.prototype._bestPrefix = function() {
      if (this.units.length !== 1) {
        throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
      }
      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
        throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
      }
      var absValue = this.value !== null ? abs2(this.value) : 0;
      var absUnitValue = abs2(this.units[0].unit.value);
      var bestPrefix = this.units[0].prefix;
      if (absValue === 0) {
        return bestPrefix;
      }
      var power = this.units[0].power;
      var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
      if (bestDiff > -2.200001 && bestDiff < 1.800001)
        return bestPrefix;
      bestDiff = Math.abs(bestDiff);
      var prefixes = this.units[0].unit.prefixes;
      for (var p in prefixes) {
        if (hasOwnProperty2(prefixes, p)) {
          var prefix = prefixes[p];
          if (prefix.scientific) {
            var diff = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
            if (diff < bestDiff || diff === bestDiff && prefix.name.length < bestPrefix.name.length) {
              bestPrefix = prefix;
              bestDiff = diff;
            }
          }
        }
      }
      return bestPrefix;
    };
    Unit.prototype.splitUnit = function(parts) {
      var x = this.clone();
      var ret = [];
      for (var i = 0; i < parts.length; i++) {
        x = x.to(parts[i]);
        if (i === parts.length - 1)
          break;
        var xNumeric = x.toNumeric();
        var xRounded = round2(xNumeric);
        var xFixed = void 0;
        var isNearlyEqual = equal(xRounded, xNumeric);
        if (isNearlyEqual) {
          xFixed = xRounded;
        } else {
          xFixed = fix(x.toNumeric());
        }
        var y = new Unit(xFixed, parts[i].toString());
        ret.push(y);
        x = subtract(x, y);
      }
      var testSum = 0;
      for (var _i5 = 0; _i5 < ret.length; _i5++) {
        testSum = addScalar(testSum, ret[_i5].value);
      }
      if (equal(testSum, this.value)) {
        x.value = 0;
      }
      ret.push(x);
      return ret;
    };
    var PREFIXES = {
      NONE: {
        "": {
          name: "",
          value: 1,
          scientific: true
        }
      },
      SHORT: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 10,
          scientific: false
        },
        h: {
          name: "h",
          value: 100,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e3,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e6,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e9,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e12,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e15,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e18,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e21,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e24,
          scientific: true
        },
        d: {
          name: "d",
          value: 0.1,
          scientific: false
        },
        c: {
          name: "c",
          value: 0.01,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-3,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-6,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-9,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-12,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-15,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-18,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-21,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-24,
          scientific: true
        }
      },
      LONG: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        deca: {
          name: "deca",
          value: 10,
          scientific: false
        },
        hecto: {
          name: "hecto",
          value: 100,
          scientific: false
        },
        kilo: {
          name: "kilo",
          value: 1e3,
          scientific: true
        },
        mega: {
          name: "mega",
          value: 1e6,
          scientific: true
        },
        giga: {
          name: "giga",
          value: 1e9,
          scientific: true
        },
        tera: {
          name: "tera",
          value: 1e12,
          scientific: true
        },
        peta: {
          name: "peta",
          value: 1e15,
          scientific: true
        },
        exa: {
          name: "exa",
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: "zetta",
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: "yotta",
          value: 1e24,
          scientific: true
        },
        deci: {
          name: "deci",
          value: 0.1,
          scientific: false
        },
        centi: {
          name: "centi",
          value: 0.01,
          scientific: false
        },
        milli: {
          name: "milli",
          value: 1e-3,
          scientific: true
        },
        micro: {
          name: "micro",
          value: 1e-6,
          scientific: true
        },
        nano: {
          name: "nano",
          value: 1e-9,
          scientific: true
        },
        pico: {
          name: "pico",
          value: 1e-12,
          scientific: true
        },
        femto: {
          name: "femto",
          value: 1e-15,
          scientific: true
        },
        atto: {
          name: "atto",
          value: 1e-18,
          scientific: true
        },
        zepto: {
          name: "zepto",
          value: 1e-21,
          scientific: true
        },
        yocto: {
          name: "yocto",
          value: 1e-24,
          scientific: true
        }
      },
      SQUARED: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 100,
          scientific: false
        },
        h: {
          name: "h",
          value: 1e4,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e6,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e12,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e18,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e24,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e30,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e36,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e42,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e48,
          scientific: true
        },
        d: {
          name: "d",
          value: 0.01,
          scientific: false
        },
        c: {
          name: "c",
          value: 1e-4,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-6,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-12,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-18,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-24,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-30,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-36,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-42,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-48,
          scientific: true
        }
      },
      CUBIC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 1e3,
          scientific: false
        },
        h: {
          name: "h",
          value: 1e6,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e9,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e18,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e27,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e36,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e45,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e54,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e63,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e72,
          scientific: true
        },
        d: {
          name: "d",
          value: 1e-3,
          scientific: false
        },
        c: {
          name: "c",
          value: 1e-6,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-9,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-18,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-27,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-36,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-45,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-54,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-63,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-72,
          scientific: true
        }
      },
      BINARY_SHORT_SI: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        k: {
          name: "k",
          value: 1e3,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e6,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e9,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e12,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e15,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e18,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e21,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e24,
          scientific: true
        }
      },
      BINARY_SHORT_IEC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        Ki: {
          name: "Ki",
          value: 1024,
          scientific: true
        },
        Mi: {
          name: "Mi",
          value: Math.pow(1024, 2),
          scientific: true
        },
        Gi: {
          name: "Gi",
          value: Math.pow(1024, 3),
          scientific: true
        },
        Ti: {
          name: "Ti",
          value: Math.pow(1024, 4),
          scientific: true
        },
        Pi: {
          name: "Pi",
          value: Math.pow(1024, 5),
          scientific: true
        },
        Ei: {
          name: "Ei",
          value: Math.pow(1024, 6),
          scientific: true
        },
        Zi: {
          name: "Zi",
          value: Math.pow(1024, 7),
          scientific: true
        },
        Yi: {
          name: "Yi",
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BINARY_LONG_SI: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        kilo: {
          name: "kilo",
          value: 1e3,
          scientific: true
        },
        mega: {
          name: "mega",
          value: 1e6,
          scientific: true
        },
        giga: {
          name: "giga",
          value: 1e9,
          scientific: true
        },
        tera: {
          name: "tera",
          value: 1e12,
          scientific: true
        },
        peta: {
          name: "peta",
          value: 1e15,
          scientific: true
        },
        exa: {
          name: "exa",
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: "zetta",
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: "yotta",
          value: 1e24,
          scientific: true
        }
      },
      BINARY_LONG_IEC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        kibi: {
          name: "kibi",
          value: 1024,
          scientific: true
        },
        mebi: {
          name: "mebi",
          value: Math.pow(1024, 2),
          scientific: true
        },
        gibi: {
          name: "gibi",
          value: Math.pow(1024, 3),
          scientific: true
        },
        tebi: {
          name: "tebi",
          value: Math.pow(1024, 4),
          scientific: true
        },
        pebi: {
          name: "pebi",
          value: Math.pow(1024, 5),
          scientific: true
        },
        exi: {
          name: "exi",
          value: Math.pow(1024, 6),
          scientific: true
        },
        zebi: {
          name: "zebi",
          value: Math.pow(1024, 7),
          scientific: true
        },
        yobi: {
          name: "yobi",
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BTU: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        MM: {
          name: "MM",
          value: 1e6,
          scientific: true
        }
      }
    };
    PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
    PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
    PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
    var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
    var BASE_UNITS = {
      NONE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      MASS: {
        dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      LENGTH: {
        dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
      },
      TIME: {
        dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
      },
      CURRENT: {
        dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
      },
      TEMPERATURE: {
        dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
      },
      LUMINOUS_INTENSITY: {
        dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
      },
      AMOUNT_OF_SUBSTANCE: {
        dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
      },
      FORCE: {
        dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
      },
      SURFACE: {
        dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      VOLUME: {
        dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
      },
      ENERGY: {
        dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
      },
      POWER: {
        dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
      },
      PRESSURE: {
        dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CHARGE: {
        dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CAPACITANCE: {
        dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_POTENTIAL: {
        dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_RESISTANCE: {
        dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_INDUCTANCE: {
        dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CONDUCTANCE: {
        dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX: {
        dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX_DENSITY: {
        dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
      },
      FREQUENCY: {
        dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
      },
      ANGLE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
      },
      BIT: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
      }
    };
    for (var key in BASE_UNITS) {
      if (hasOwnProperty2(BASE_UNITS, key)) {
        BASE_UNITS[key].key = key;
      }
    }
    var BASE_UNIT_NONE = {};
    var UNIT_NONE = {
      name: "",
      base: BASE_UNIT_NONE,
      value: 1,
      offset: 0,
      dimensions: BASE_DIMENSIONS.map((x) => 0)
    };
    var UNITS = {
      meter: {
        name: "meter",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      inch: {
        name: "inch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      foot: {
        name: "foot",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yard: {
        name: "yard",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mile: {
        name: "mile",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      link: {
        name: "link",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rod: {
        name: "rod",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.0292,
        offset: 0
      },
      chain: {
        name: "chain",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      angstrom: {
        name: "angstrom",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1e-10,
        offset: 0
      },
      m: {
        name: "m",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      in: {
        name: "in",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      ft: {
        name: "ft",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yd: {
        name: "yd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mi: {
        name: "mi",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      li: {
        name: "li",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rd: {
        name: "rd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.02921,
        offset: 0
      },
      ch: {
        name: "ch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      mil: {
        name: "mil",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 254e-7,
        offset: 0
      },
      m2: {
        name: "m2",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.SQUARED,
        value: 1,
        offset: 0
      },
      sqin: {
        name: "sqin",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-8,
        offset: 0
      },
      sqft: {
        name: "sqft",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.09290304,
        offset: 0
      },
      sqyd: {
        name: "sqyd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.83612736,
        offset: 0
      },
      sqmi: {
        name: "sqmi",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 2589988110336e-6,
        offset: 0
      },
      sqrd: {
        name: "sqrd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 25.29295,
        offset: 0
      },
      sqch: {
        name: "sqch",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 404.6873,
        offset: 0
      },
      sqmil: {
        name: "sqmil",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-14,
        offset: 0
      },
      acre: {
        name: "acre",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 4046.86,
        offset: 0
      },
      hectare: {
        name: "hectare",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 1e4,
        offset: 0
      },
      m3: {
        name: "m3",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.CUBIC,
        value: 1,
        offset: 0
      },
      L: {
        name: "L",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      l: {
        name: "l",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      litre: {
        name: "litre",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      cuin: {
        name: "cuin",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 16387064e-12,
        offset: 0
      },
      cuft: {
        name: "cuft",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.028316846592,
        offset: 0
      },
      cuyd: {
        name: "cuyd",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.764554857984,
        offset: 0
      },
      teaspoon: {
        name: "teaspoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-6,
        offset: 0
      },
      tablespoon: {
        name: "tablespoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 15e-6,
        offset: 0
      },
      drop: {
        name: "drop",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      gtt: {
        name: "gtt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      minim: {
        name: "minim",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 6161152e-14,
        offset: 0
      },
      fluiddram: {
        name: "fluiddram",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911e-13,
        offset: 0
      },
      fluidounce: {
        name: "fluidounce",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2957353e-11,
        offset: 0
      },
      gill: {
        name: "gill",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1182941e-10,
        offset: 0
      },
      cc: {
        name: "cc",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1e-6,
        offset: 0
      },
      cup: {
        name: "cup",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882e-10,
        offset: 0
      },
      pint: {
        name: "pint",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 4731765e-10,
        offset: 0
      },
      quart: {
        name: "quart",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 9463529e-10,
        offset: 0
      },
      gallon: {
        name: "gallon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 3785412e-9,
        offset: 0
      },
      beerbarrel: {
        name: "beerbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      oilbarrel: {
        name: "oilbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      hogshead: {
        name: "hogshead",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.238481,
        offset: 0
      },
      fldr: {
        name: "fldr",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911e-13,
        offset: 0
      },
      floz: {
        name: "floz",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2957353e-11,
        offset: 0
      },
      gi: {
        name: "gi",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1182941e-10,
        offset: 0
      },
      cp: {
        name: "cp",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882e-10,
        offset: 0
      },
      pt: {
        name: "pt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 4731765e-10,
        offset: 0
      },
      qt: {
        name: "qt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 9463529e-10,
        offset: 0
      },
      gal: {
        name: "gal",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 3785412e-9,
        offset: 0
      },
      bbl: {
        name: "bbl",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      obl: {
        name: "obl",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      g: {
        name: "g",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      gram: {
        name: "gram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      ton: {
        name: "ton",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 907.18474,
        offset: 0
      },
      t: {
        name: "t",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e3,
        offset: 0
      },
      tonne: {
        name: "tonne",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e3,
        offset: 0
      },
      grain: {
        name: "grain",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dram: {
        name: "dram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      ounce: {
        name: "ounce",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      poundmass: {
        name: "poundmass",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      hundredweight: {
        name: "hundredweight",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      stick: {
        name: "stick",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.115,
        offset: 0
      },
      stone: {
        name: "stone",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6.35029318,
        offset: 0
      },
      gr: {
        name: "gr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dr: {
        name: "dr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      oz: {
        name: "oz",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      lbm: {
        name: "lbm",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      cwt: {
        name: "cwt",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      s: {
        name: "s",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      min: {
        name: "min",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      h: {
        name: "h",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      second: {
        name: "second",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      sec: {
        name: "sec",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      minute: {
        name: "minute",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      hour: {
        name: "hour",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      day: {
        name: "day",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 86400,
        offset: 0
      },
      week: {
        name: "week",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 7 * 86400,
        offset: 0
      },
      month: {
        name: "month",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 2629800,
        offset: 0
      },
      year: {
        name: "year",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 31557600,
        offset: 0
      },
      decade: {
        name: "decade",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e3,
        offset: 0
      },
      century: {
        name: "century",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e4,
        offset: 0
      },
      millennium: {
        name: "millennium",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e5,
        offset: 0
      },
      hertz: {
        name: "Hertz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      Hz: {
        name: "Hz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      rad: {
        name: "rad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      radian: {
        name: "radian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      deg: {
        name: "deg",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        offset: 0
      },
      degree: {
        name: "degree",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        offset: 0
      },
      grad: {
        name: "grad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        offset: 0
      },
      gradian: {
        name: "gradian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        offset: 0
      },
      cycle: {
        name: "cycle",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        offset: 0
      },
      arcsec: {
        name: "arcsec",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        offset: 0
      },
      arcmin: {
        name: "arcmin",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        offset: 0
      },
      A: {
        name: "A",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ampere: {
        name: "ampere",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      K: {
        name: "K",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      degC: {
        name: "degC",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 273.15
      },
      degF: {
        name: "degF",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1 / 1.8,
        offset: 459.67
      },
      degR: {
        name: "degR",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1 / 1.8,
        offset: 0
      },
      kelvin: {
        name: "kelvin",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      celsius: {
        name: "celsius",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 273.15
      },
      fahrenheit: {
        name: "fahrenheit",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1 / 1.8,
        offset: 459.67
      },
      rankine: {
        name: "rankine",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1 / 1.8,
        offset: 0
      },
      mol: {
        name: "mol",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      mole: {
        name: "mole",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      cd: {
        name: "cd",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      candela: {
        name: "candela",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      N: {
        name: "N",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      newton: {
        name: "newton",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      dyn: {
        name: "dyn",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1e-5,
        offset: 0
      },
      dyne: {
        name: "dyne",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1e-5,
        offset: 0
      },
      lbf: {
        name: "lbf",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      poundforce: {
        name: "poundforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      kip: {
        name: "kip",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 4448.2216,
        offset: 0
      },
      kilogramforce: {
        name: "kilogramforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      J: {
        name: "J",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      joule: {
        name: "joule",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      erg: {
        name: "erg",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.NONE,
        value: 1e-7,
        offset: 0
      },
      Wh: {
        name: "Wh",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 3600,
        offset: 0
      },
      BTU: {
        name: "BTU",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.BTU,
        value: 1055.05585262,
        offset: 0
      },
      eV: {
        name: "eV",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1602176565e-28,
        offset: 0
      },
      electronvolt: {
        name: "electronvolt",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1602176565e-28,
        offset: 0
      },
      W: {
        name: "W",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      watt: {
        name: "watt",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      hp: {
        name: "hp",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.NONE,
        value: 745.6998715386,
        offset: 0
      },
      VAR: {
        name: "VAR",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: Complex2.I,
        offset: 0
      },
      VA: {
        name: "VA",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      Pa: {
        name: "Pa",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      psi: {
        name: "psi",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 6894.75729276459,
        offset: 0
      },
      atm: {
        name: "atm",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 101325,
        offset: 0
      },
      bar: {
        name: "bar",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORTLONG,
        value: 1e5,
        offset: 0
      },
      torr: {
        name: "torr",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmHg: {
        name: "mmHg",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmH2O: {
        name: "mmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      cmH2O: {
        name: "cmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 98.0665,
        offset: 0
      },
      coulomb: {
        name: "coulomb",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      C: {
        name: "C",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      farad: {
        name: "farad",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      F: {
        name: "F",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      volt: {
        name: "volt",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      V: {
        name: "V",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ohm: {
        name: "ohm",
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORTLONG,
        value: 1,
        offset: 0
      },
      henry: {
        name: "henry",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      H: {
        name: "H",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      siemens: {
        name: "siemens",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      S: {
        name: "S",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      weber: {
        name: "weber",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      Wb: {
        name: "Wb",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      tesla: {
        name: "tesla",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      T: {
        name: "T",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      b: {
        name: "b",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 1,
        offset: 0
      },
      bits: {
        name: "bits",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 1,
        offset: 0
      },
      B: {
        name: "B",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 8,
        offset: 0
      },
      bytes: {
        name: "bytes",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 8,
        offset: 0
      }
    };
    var ALIASES = {
      meters: "meter",
      inches: "inch",
      feet: "foot",
      yards: "yard",
      miles: "mile",
      links: "link",
      rods: "rod",
      chains: "chain",
      angstroms: "angstrom",
      lt: "l",
      litres: "litre",
      liter: "litre",
      liters: "litre",
      teaspoons: "teaspoon",
      tablespoons: "tablespoon",
      minims: "minim",
      fluiddrams: "fluiddram",
      fluidounces: "fluidounce",
      gills: "gill",
      cups: "cup",
      pints: "pint",
      quarts: "quart",
      gallons: "gallon",
      beerbarrels: "beerbarrel",
      oilbarrels: "oilbarrel",
      hogsheads: "hogshead",
      gtts: "gtt",
      grams: "gram",
      tons: "ton",
      tonnes: "tonne",
      grains: "grain",
      drams: "dram",
      ounces: "ounce",
      poundmasses: "poundmass",
      hundredweights: "hundredweight",
      sticks: "stick",
      lb: "lbm",
      lbs: "lbm",
      kips: "kip",
      kgf: "kilogramforce",
      acres: "acre",
      hectares: "hectare",
      sqfeet: "sqft",
      sqyard: "sqyd",
      sqmile: "sqmi",
      sqmiles: "sqmi",
      mmhg: "mmHg",
      mmh2o: "mmH2O",
      cmh2o: "cmH2O",
      seconds: "second",
      secs: "second",
      minutes: "minute",
      mins: "minute",
      hours: "hour",
      hr: "hour",
      hrs: "hour",
      days: "day",
      weeks: "week",
      months: "month",
      years: "year",
      decades: "decade",
      centuries: "century",
      millennia: "millennium",
      hertz: "hertz",
      radians: "radian",
      degrees: "degree",
      gradians: "gradian",
      cycles: "cycle",
      arcsecond: "arcsec",
      arcseconds: "arcsec",
      arcminute: "arcmin",
      arcminutes: "arcmin",
      BTUs: "BTU",
      watts: "watt",
      joules: "joule",
      amperes: "ampere",
      coulombs: "coulomb",
      volts: "volt",
      ohms: "ohm",
      farads: "farad",
      webers: "weber",
      teslas: "tesla",
      electronvolts: "electronvolt",
      moles: "mole",
      bit: "bits",
      byte: "bytes"
    };
    function calculateAngleValues(config3) {
      if (config3.number === "BigNumber") {
        var pi2 = createBigNumberPi(_BigNumber);
        UNITS.rad.value = new _BigNumber(1);
        UNITS.deg.value = pi2.div(180);
        UNITS.grad.value = pi2.div(200);
        UNITS.cycle.value = pi2.times(2);
        UNITS.arcsec.value = pi2.div(648e3);
        UNITS.arcmin.value = pi2.div(10800);
      } else {
        UNITS.rad.value = 1;
        UNITS.deg.value = Math.PI / 180;
        UNITS.grad.value = Math.PI / 200;
        UNITS.cycle.value = Math.PI * 2;
        UNITS.arcsec.value = Math.PI / 648e3;
        UNITS.arcmin.value = Math.PI / 10800;
      }
      UNITS.radian.value = UNITS.rad.value;
      UNITS.degree.value = UNITS.deg.value;
      UNITS.gradian.value = UNITS.grad.value;
    }
    calculateAngleValues(config2);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.number !== prev.number) {
          calculateAngleValues(curr);
        }
      });
    }
    var UNIT_SYSTEMS = {
      si: {
        NONE: {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE[""]
        },
        LENGTH: {
          unit: UNITS.m,
          prefix: PREFIXES.SHORT[""]
        },
        MASS: {
          unit: UNITS.g,
          prefix: PREFIXES.SHORT.k
        },
        TIME: {
          unit: UNITS.s,
          prefix: PREFIXES.SHORT[""]
        },
        CURRENT: {
          unit: UNITS.A,
          prefix: PREFIXES.SHORT[""]
        },
        TEMPERATURE: {
          unit: UNITS.K,
          prefix: PREFIXES.SHORT[""]
        },
        LUMINOUS_INTENSITY: {
          unit: UNITS.cd,
          prefix: PREFIXES.SHORT[""]
        },
        AMOUNT_OF_SUBSTANCE: {
          unit: UNITS.mol,
          prefix: PREFIXES.SHORT[""]
        },
        ANGLE: {
          unit: UNITS.rad,
          prefix: PREFIXES.SHORT[""]
        },
        BIT: {
          unit: UNITS.bits,
          prefix: PREFIXES.SHORT[""]
        },
        FORCE: {
          unit: UNITS.N,
          prefix: PREFIXES.SHORT[""]
        },
        ENERGY: {
          unit: UNITS.J,
          prefix: PREFIXES.SHORT[""]
        },
        POWER: {
          unit: UNITS.W,
          prefix: PREFIXES.SHORT[""]
        },
        PRESSURE: {
          unit: UNITS.Pa,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CHARGE: {
          unit: UNITS.C,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CAPACITANCE: {
          unit: UNITS.F,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_POTENTIAL: {
          unit: UNITS.V,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_RESISTANCE: {
          unit: UNITS.ohm,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_INDUCTANCE: {
          unit: UNITS.H,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CONDUCTANCE: {
          unit: UNITS.S,
          prefix: PREFIXES.SHORT[""]
        },
        MAGNETIC_FLUX: {
          unit: UNITS.Wb,
          prefix: PREFIXES.SHORT[""]
        },
        MAGNETIC_FLUX_DENSITY: {
          unit: UNITS.T,
          prefix: PREFIXES.SHORT[""]
        },
        FREQUENCY: {
          unit: UNITS.Hz,
          prefix: PREFIXES.SHORT[""]
        }
      }
    };
    UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.cgs.LENGTH = {
      unit: UNITS.m,
      prefix: PREFIXES.SHORT.c
    };
    UNIT_SYSTEMS.cgs.MASS = {
      unit: UNITS.g,
      prefix: PREFIXES.SHORT[""]
    };
    UNIT_SYSTEMS.cgs.FORCE = {
      unit: UNITS.dyn,
      prefix: PREFIXES.SHORT[""]
    };
    UNIT_SYSTEMS.cgs.ENERGY = {
      unit: UNITS.erg,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.us.LENGTH = {
      unit: UNITS.ft,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.MASS = {
      unit: UNITS.lbm,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.TEMPERATURE = {
      unit: UNITS.degF,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.FORCE = {
      unit: UNITS.lbf,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.ENERGY = {
      unit: UNITS.BTU,
      prefix: PREFIXES.BTU[""]
    };
    UNIT_SYSTEMS.us.POWER = {
      unit: UNITS.hp,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.PRESSURE = {
      unit: UNITS.psi,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    var currentUnitSystem = UNIT_SYSTEMS.auto;
    Unit.setUnitSystem = function(name297) {
      if (hasOwnProperty2(UNIT_SYSTEMS, name297)) {
        currentUnitSystem = UNIT_SYSTEMS[name297];
      } else {
        throw new Error("Unit system " + name297 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
      }
    };
    Unit.getUnitSystem = function() {
      for (var _key in UNIT_SYSTEMS) {
        if (hasOwnProperty2(UNIT_SYSTEMS, _key)) {
          if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
            return _key;
          }
        }
      }
    };
    Unit.typeConverters = {
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x + "");
      },
      Fraction: function Fraction2(x) {
        return new _Fraction(x);
      },
      Complex: function Complex3(x) {
        return x;
      },
      number: function number2(x) {
        return x;
      }
    };
    Unit.prototype._numberConverter = function() {
      var convert = Unit.typeConverters[this.valueType()];
      if (convert) {
        return convert;
      }
      throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
    };
    Unit._getNumberConverter = function(type) {
      if (!Unit.typeConverters[type]) {
        throw new TypeError('Unsupported type "' + type + '"');
      }
      return Unit.typeConverters[type];
    };
    for (var _key2 in UNITS) {
      if (hasOwnProperty2(UNITS, _key2)) {
        var unit = UNITS[_key2];
        unit.dimensions = unit.base.dimensions;
      }
    }
    for (var _name2 in ALIASES) {
      if (hasOwnProperty2(ALIASES, _name2)) {
        var _unit2 = UNITS[ALIASES[_name2]];
        var alias = {};
        for (var _key3 in _unit2) {
          if (hasOwnProperty2(_unit2, _key3)) {
            alias[_key3] = _unit2[_key3];
          }
        }
        alias.name = _name2;
        UNITS[_name2] = alias;
      }
    }
    Unit.isValidAlpha = function isValidAlpha(c2) {
      return /^[a-zA-Z]$/.test(c2);
    };
    function assertUnitNameIsValid(name297) {
      for (var i = 0; i < name297.length; i++) {
        c = name297.charAt(i);
        if (i === 0 && !Unit.isValidAlpha(c)) {
          throw new Error('Invalid unit name (must begin with alpha character): "' + name297 + '"');
        }
        if (i > 0 && !(Unit.isValidAlpha(c) || isDigit(c))) {
          throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name297 + '"');
        }
      }
    }
    Unit.createUnit = function(obj, options) {
      if (typeof obj !== "object") {
        throw new TypeError("createUnit expects first parameter to be of type 'Object'");
      }
      if (options && options.override) {
        for (var _key4 in obj) {
          if (hasOwnProperty2(obj, _key4)) {
            Unit.deleteUnit(_key4);
          }
          if (obj[_key4].aliases) {
            for (var i = 0; i < obj[_key4].aliases.length; i++) {
              Unit.deleteUnit(obj[_key4].aliases[i]);
            }
          }
        }
      }
      var lastUnit;
      for (var _key5 in obj) {
        if (hasOwnProperty2(obj, _key5)) {
          lastUnit = Unit.createUnitSingle(_key5, obj[_key5]);
        }
      }
      return lastUnit;
    };
    Unit.createUnitSingle = function(name297, obj) {
      if (typeof obj === "undefined" || obj === null) {
        obj = {};
      }
      if (typeof name297 !== "string") {
        throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
      }
      if (hasOwnProperty2(UNITS, name297)) {
        throw new Error('Cannot create unit "' + name297 + '": a unit with that name already exists');
      }
      assertUnitNameIsValid(name297);
      var defUnit = null;
      var aliases = [];
      var offset = 0;
      var definition;
      var prefixes;
      var baseName;
      if (obj && obj.type === "Unit") {
        defUnit = obj.clone();
      } else if (typeof obj === "string") {
        if (obj !== "") {
          definition = obj;
        }
      } else if (typeof obj === "object") {
        definition = obj.definition;
        prefixes = obj.prefixes;
        offset = obj.offset;
        baseName = obj.baseName;
        if (obj.aliases) {
          aliases = obj.aliases.valueOf();
        }
      } else {
        throw new TypeError('Cannot create unit "' + name297 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
      }
      if (aliases) {
        for (var i = 0; i < aliases.length; i++) {
          if (hasOwnProperty2(UNITS, aliases[i])) {
            throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
          }
        }
      }
      if (definition && typeof definition === "string" && !defUnit) {
        try {
          defUnit = Unit.parse(definition, {
            allowNoUnits: true
          });
        } catch (ex) {
          ex.message = 'Could not create unit "' + name297 + '" from "' + definition + '": ' + ex.message;
          throw ex;
        }
      } else if (definition && definition.type === "Unit") {
        defUnit = definition.clone();
      }
      aliases = aliases || [];
      offset = offset || 0;
      if (prefixes && prefixes.toUpperCase) {
        prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
      } else {
        prefixes = PREFIXES.NONE;
      }
      var newUnit = {};
      if (!defUnit) {
        baseName = baseName || name297 + "_STUFF";
        if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
          throw new Error('Cannot create new base unit "' + name297 + '": a base unit with that name already exists (and cannot be overridden)');
        }
        BASE_DIMENSIONS.push(baseName);
        for (var b in BASE_UNITS) {
          if (hasOwnProperty2(BASE_UNITS, b)) {
            BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
          }
        }
        var newBaseUnit = {
          dimensions: []
        };
        for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
          newBaseUnit.dimensions[_i6] = 0;
        }
        newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
        newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = newBaseUnit;
        newUnit = {
          name: name297,
          value: 1,
          dimensions: BASE_UNITS[baseName].dimensions.slice(0),
          prefixes,
          offset,
          base: BASE_UNITS[baseName]
        };
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
      } else {
        newUnit = {
          name: name297,
          value: defUnit.value,
          dimensions: defUnit.dimensions.slice(0),
          prefixes,
          offset
        };
        var anyMatch = false;
        for (var _i7 in BASE_UNITS) {
          if (hasOwnProperty2(BASE_UNITS, _i7)) {
            var match = true;
            for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
              if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                match = false;
                break;
              }
            }
            if (match) {
              anyMatch = true;
              newUnit.base = BASE_UNITS[_i7];
              break;
            }
          }
        }
        if (!anyMatch) {
          baseName = baseName || name297 + "_STUFF";
          var _newBaseUnit = {
            dimensions: defUnit.dimensions.slice(0)
          };
          _newBaseUnit.key = baseName;
          BASE_UNITS[baseName] = _newBaseUnit;
          currentUnitSystem[baseName] = {
            unit: newUnit,
            prefix: PREFIXES.NONE[""]
          };
          newUnit.base = BASE_UNITS[baseName];
        }
      }
      Unit.UNITS[name297] = newUnit;
      for (var _i8 = 0; _i8 < aliases.length; _i8++) {
        var aliasName = aliases[_i8];
        var _alias = {};
        for (var _key6 in newUnit) {
          if (hasOwnProperty2(newUnit, _key6)) {
            _alias[_key6] = newUnit[_key6];
          }
        }
        _alias.name = aliasName;
        Unit.UNITS[aliasName] = _alias;
      }
      delete _findUnit.cache;
      return new Unit(null, name297);
    };
    Unit.deleteUnit = function(name297) {
      delete Unit.UNITS[name297];
    };
    Unit.PREFIXES = PREFIXES;
    Unit.BASE_DIMENSIONS = BASE_DIMENSIONS;
    Unit.BASE_UNITS = BASE_UNITS;
    Unit.UNIT_SYSTEMS = UNIT_SYSTEMS;
    Unit.UNITS = UNITS;
    return Unit;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/unit/function/unit.js
  var name158 = "unit";
  var dependencies159 = ["typed", "Unit"];
  var createUnitFunction = /* @__PURE__ */ factory(name158, dependencies159, (_ref) => {
    var {
      typed,
      Unit
    } = _ref;
    return typed(name158, {
      Unit: function Unit2(x) {
        return x.clone();
      },
      string: function string(x) {
        if (Unit.isValuelessUnit(x)) {
          return new Unit(null, x);
        }
        return Unit.parse(x, {
          allowNoUnits: true
        });
      },
      "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit) {
        return new Unit(value, unit);
      },
      "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
        return new Unit(value);
      },
      "Array | Matrix": typed.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
  var name159 = "sparse";
  var dependencies160 = ["typed", "SparseMatrix"];
  var createSparse = /* @__PURE__ */ factory(name159, dependencies160, (_ref) => {
    var {
      typed,
      SparseMatrix
    } = _ref;
    return typed(name159, {
      "": function _() {
        return new SparseMatrix([]);
      },
      string: function string(datatype) {
        return new SparseMatrix([], datatype);
      },
      "Array | Matrix": function ArrayMatrix(data) {
        return new SparseMatrix(data);
      },
      "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
        return new SparseMatrix(data, datatype);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
  var name160 = "createUnit";
  var dependencies161 = ["typed", "Unit"];
  var createCreateUnit = /* @__PURE__ */ factory(name160, dependencies161, (_ref) => {
    var {
      typed,
      Unit
    } = _ref;
    return typed(name160, {
      "Object, Object": function ObjectObject(obj, options) {
        return Unit.createUnit(obj, options);
      },
      Object: function Object2(obj) {
        return Unit.createUnit(obj, {});
      },
      "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name297, def, options) {
        var obj = {};
        obj[name297] = def;
        return Unit.createUnit(obj, options);
      },
      "string, Unit | string | Object": function stringUnitStringObject(name297, def) {
        var obj = {};
        obj[name297] = def;
        return Unit.createUnit(obj, {});
      },
      string: function string(name297) {
        var obj = {};
        obj[name297] = {};
        return Unit.createUnit(obj, {});
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acos.js
  var name161 = "acos";
  var dependencies162 = ["typed", "config", "Complex"];
  var createAcos = /* @__PURE__ */ factory(name161, dependencies162, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2
    } = _ref;
    return typed(name161, {
      number: function number(x) {
        if (x >= -1 && x <= 1 || config2.predictable) {
          return Math.acos(x);
        } else {
          return new Complex2(x, 0).acos();
        }
      },
      Complex: function Complex3(x) {
        return x.acos();
      },
      BigNumber: function BigNumber(x) {
        return x.acos();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
  var name162 = "acosh";
  var dependencies163 = ["typed", "config", "Complex"];
  var createAcosh = /* @__PURE__ */ factory(name162, dependencies163, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2
    } = _ref;
    return typed(name162, {
      number: function number(x) {
        if (x >= 1 || config2.predictable) {
          return acoshNumber(x);
        }
        if (x <= -1) {
          return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
        }
        return new Complex2(x, 0).acosh();
      },
      Complex: function Complex3(x) {
        return x.acosh();
      },
      BigNumber: function BigNumber(x) {
        return x.acosh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acot.js
  var name163 = "acot";
  var dependencies164 = ["typed", "BigNumber"];
  var createAcot = /* @__PURE__ */ factory(name163, dependencies164, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name163, {
      number: acotNumber,
      Complex: function Complex2(x) {
        return x.acot();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).atan();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
  var name164 = "acoth";
  var dependencies165 = ["typed", "config", "Complex", "BigNumber"];
  var createAcoth = /* @__PURE__ */ factory(name164, dependencies165, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name164, {
      number: function number(x) {
        if (x >= 1 || x <= -1 || config2.predictable) {
          return acothNumber(x);
        }
        return new Complex2(x, 0).acoth();
      },
      Complex: function Complex3(x) {
        return x.acoth();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).atanh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
  var name165 = "acsc";
  var dependencies166 = ["typed", "config", "Complex", "BigNumber"];
  var createAcsc = /* @__PURE__ */ factory(name165, dependencies166, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name165, {
      number: function number(x) {
        if (x <= -1 || x >= 1 || config2.predictable) {
          return acscNumber(x);
        }
        return new Complex2(x, 0).acsc();
      },
      Complex: function Complex3(x) {
        return x.acsc();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).asin();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
  var name166 = "acsch";
  var dependencies167 = ["typed", "BigNumber"];
  var createAcsch = /* @__PURE__ */ factory(name166, dependencies167, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name166, {
      number: acschNumber,
      Complex: function Complex2(x) {
        return x.acsch();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).asinh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asec.js
  var name167 = "asec";
  var dependencies168 = ["typed", "config", "Complex", "BigNumber"];
  var createAsec = /* @__PURE__ */ factory(name167, dependencies168, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name167, {
      number: function number(x) {
        if (x <= -1 || x >= 1 || config2.predictable) {
          return asecNumber(x);
        }
        return new Complex2(x, 0).asec();
      },
      Complex: function Complex3(x) {
        return x.asec();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).acos();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asech.js
  var name168 = "asech";
  var dependencies169 = ["typed", "config", "Complex", "BigNumber"];
  var createAsech = /* @__PURE__ */ factory(name168, dependencies169, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name168, {
      number: function number(x) {
        if (x <= 1 && x >= -1 || config2.predictable) {
          var xInv = 1 / x;
          if (xInv > 0 || config2.predictable) {
            return asechNumber(x);
          }
          var ret = Math.sqrt(xInv * xInv - 1);
          return new Complex2(Math.log(ret - xInv), Math.PI);
        }
        return new Complex2(x, 0).asech();
      },
      Complex: function Complex3(x) {
        return x.asech();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(1).div(x).acosh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asin.js
  var name169 = "asin";
  var dependencies170 = ["typed", "config", "Complex"];
  var createAsin = /* @__PURE__ */ factory(name169, dependencies170, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2
    } = _ref;
    return typed(name169, {
      number: function number(x) {
        if (x >= -1 && x <= 1 || config2.predictable) {
          return Math.asin(x);
        } else {
          return new Complex2(x, 0).asin();
        }
      },
      Complex: function Complex3(x) {
        return x.asin();
      },
      BigNumber: function BigNumber(x) {
        return x.asin();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
  var name170 = "asinh";
  var dependencies171 = ["typed"];
  var createAsinh = /* @__PURE__ */ factory(name170, dependencies171, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("asinh", {
      number: asinhNumber,
      Complex: function Complex2(x) {
        return x.asinh();
      },
      BigNumber: function BigNumber(x) {
        return x.asinh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan.js
  var name171 = "atan";
  var dependencies172 = ["typed"];
  var createAtan = /* @__PURE__ */ factory(name171, dependencies172, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("atan", {
      number: function number(x) {
        return Math.atan(x);
      },
      Complex: function Complex2(x) {
        return x.atan();
      },
      BigNumber: function BigNumber(x) {
        return x.atan();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
  var name172 = "atan2";
  var dependencies173 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
  var createAtan2 = /* @__PURE__ */ factory(name172, dependencies173, (_ref) => {
    var {
      typed,
      matrix,
      equalScalar,
      BigNumber,
      DenseMatrix
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed,
      equalScalar
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed
    });
    var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
      typed,
      equalScalar
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name172, {
      "number, number": Math.atan2,
      "BigNumber, BigNumber": (y, x) => BigNumber.atan2(y, x)
    }, matrixAlgorithmSuite({
      scalar: "number | BigNumber",
      SS: matAlgo09xS0Sf,
      DS: matAlgo03xDSf,
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
  var name173 = "atanh";
  var dependencies174 = ["typed", "config", "Complex"];
  var createAtanh = /* @__PURE__ */ factory(name173, dependencies174, (_ref) => {
    var {
      typed,
      config: config2,
      Complex: Complex2
    } = _ref;
    return typed(name173, {
      number: function number(x) {
        if (x <= 1 && x >= -1 || config2.predictable) {
          return atanhNumber(x);
        }
        return new Complex2(x, 0).atanh();
      },
      Complex: function Complex3(x) {
        return x.atanh();
      },
      BigNumber: function BigNumber(x) {
        return x.atanh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
  var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
    var {
      typed
    } = _ref;
    return {
      Unit: typed.referToSelf((self2) => (x) => {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function cot is no angle");
        }
        return typed.find(self2, x.valueType())(x.value);
      })
    };
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cos.js
  var name174 = "cos";
  var dependencies175 = ["typed"];
  var createCos = /* @__PURE__ */ factory(name174, dependencies175, (_ref) => {
    var {
      typed
    } = _ref;
    var trigUnit = createTrigUnit({
      typed
    });
    return typed(name174, {
      number: Math.cos,
      "Complex | BigNumber": (x) => x.cos()
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
  var name175 = "cosh";
  var dependencies176 = ["typed"];
  var createCosh = /* @__PURE__ */ factory(name175, dependencies176, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name175, {
      number: cosh,
      "Complex | BigNumber": (x) => x.cosh()
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cot.js
  var name176 = "cot";
  var dependencies177 = ["typed", "BigNumber"];
  var createCot = /* @__PURE__ */ factory(name176, dependencies177, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    var trigUnit = createTrigUnit({
      typed
    });
    return typed(name176, {
      number: cotNumber,
      Complex: (x) => x.cot(),
      BigNumber: (x) => new _BigNumber(1).div(x.tan())
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/coth.js
  var name177 = "coth";
  var dependencies178 = ["typed", "BigNumber"];
  var createCoth = /* @__PURE__ */ factory(name177, dependencies178, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name177, {
      number: cothNumber,
      Complex: (x) => x.coth(),
      BigNumber: (x) => new _BigNumber(1).div(x.tanh())
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csc.js
  var name178 = "csc";
  var dependencies179 = ["typed", "BigNumber"];
  var createCsc = /* @__PURE__ */ factory(name178, dependencies179, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    var trigUnit = createTrigUnit({
      typed
    });
    return typed(name178, {
      number: cscNumber,
      Complex: (x) => x.csc(),
      BigNumber: (x) => new _BigNumber(1).div(x.sin())
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csch.js
  var name179 = "csch";
  var dependencies180 = ["typed", "BigNumber"];
  var createCsch = /* @__PURE__ */ factory(name179, dependencies180, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name179, {
      number: cschNumber,
      Complex: (x) => x.csch(),
      BigNumber: (x) => new _BigNumber(1).div(x.sinh())
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sec.js
  var name180 = "sec";
  var dependencies181 = ["typed", "BigNumber"];
  var createSec = /* @__PURE__ */ factory(name180, dependencies181, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    var trigUnit = createTrigUnit({
      typed
    });
    return typed(name180, {
      number: secNumber,
      Complex: (x) => x.sec(),
      BigNumber: (x) => new _BigNumber(1).div(x.cos())
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sech.js
  var name181 = "sech";
  var dependencies182 = ["typed", "BigNumber"];
  var createSech = /* @__PURE__ */ factory(name181, dependencies182, (_ref) => {
    var {
      typed,
      BigNumber: _BigNumber
    } = _ref;
    return typed(name181, {
      number: sechNumber,
      Complex: (x) => x.sech(),
      BigNumber: (x) => new _BigNumber(1).div(x.cosh())
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sin.js
  var name182 = "sin";
  var dependencies183 = ["typed"];
  var createSin = /* @__PURE__ */ factory(name182, dependencies183, (_ref) => {
    var {
      typed
    } = _ref;
    var trigUnit = createTrigUnit({
      typed
    });
    return typed(name182, {
      number: Math.sin,
      "Complex | BigNumber": (x) => x.sin()
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
  var name183 = "sinh";
  var dependencies184 = ["typed"];
  var createSinh = /* @__PURE__ */ factory(name183, dependencies184, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name183, {
      number: sinhNumber,
      "Complex | BigNumber": (x) => x.sinh()
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tan.js
  var name184 = "tan";
  var dependencies185 = ["typed"];
  var createTan = /* @__PURE__ */ factory(name184, dependencies185, (_ref) => {
    var {
      typed
    } = _ref;
    var trigUnit = createTrigUnit({
      typed
    });
    return typed(name184, {
      number: Math.tan,
      "Complex | BigNumber": (x) => x.tan()
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
  var name185 = "tanh";
  var dependencies186 = ["typed"];
  var createTanh = /* @__PURE__ */ factory(name185, dependencies186, (_ref) => {
    var {
      typed
    } = _ref;
    return typed("tanh", {
      number: tanh,
      "Complex | BigNumber": (x) => x.tanh()
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setCartesian.js
  var name186 = "setCartesian";
  var dependencies187 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetCartesian = /* @__PURE__ */ factory(name186, dependencies187, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name186, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result = [];
        if (subset(size(a1), new Index(0)) !== 0 && subset(size(a2), new Index(0)) !== 0) {
          var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural);
          var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural);
          result = [];
          for (var i = 0; i < b1.length; i++) {
            for (var j = 0; j < b2.length; j++) {
              result.push([b1[i], b2[j]]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return result;
        }
        return new DenseMatrix(result);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setDifference.js
  var name187 = "setDifference";
  var dependencies188 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetDifference = /* @__PURE__ */ factory(name187, dependencies188, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name187, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result;
        if (subset(size(a1), new Index(0)) === 0) {
          result = [];
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1.toArray());
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
          result = [];
          var inb2;
          for (var i = 0; i < b1.length; i++) {
            inb2 = false;
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                inb2 = true;
                break;
              }
            }
            if (!inb2) {
              result.push(b1[i]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix(generalize(result));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setDistinct.js
  var name188 = "setDistinct";
  var dependencies189 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetDistinct = /* @__PURE__ */ factory(name188, dependencies189, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name188, {
      "Array | Matrix": function ArrayMatrix(a) {
        var result;
        if (subset(size(a), new Index(0)) === 0) {
          result = [];
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
          result = [];
          result.push(b[0]);
          for (var i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              result.push(b[i]);
            }
          }
        }
        if (Array.isArray(a)) {
          return result;
        }
        return new DenseMatrix(result);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setIntersect.js
  var name189 = "setIntersect";
  var dependencies190 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetIntersect = /* @__PURE__ */ factory(name189, dependencies190, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index,
      DenseMatrix
    } = _ref;
    return typed(name189, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result;
        if (subset(size(a1), new Index(0)) === 0 || subset(size(a2), new Index(0)) === 0) {
          result = [];
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
          result = [];
          for (var i = 0; i < b1.length; i++) {
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
                result.push(b1[i]);
                break;
              }
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix(generalize(result));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setIsSubset.js
  var name190 = "setIsSubset";
  var dependencies191 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetIsSubset = /* @__PURE__ */ factory(name190, dependencies191, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index
    } = _ref;
    return typed(name190, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          return true;
        } else if (subset(size(a2), new Index(0)) === 0) {
          return false;
        }
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural));
        var inb2;
        for (var i = 0; i < b1.length; i++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural(b1[i].value, b2[j].value) === 0 && b1[i].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (inb2 === false) {
            return false;
          }
        }
        return true;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
  var name191 = "setMultiplicity";
  var dependencies192 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetMultiplicity = /* @__PURE__ */ factory(name191, dependencies192, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index
    } = _ref;
    return typed(name191, {
      "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e2, a) {
        if (subset(size(a), new Index(0)) === 0) {
          return 0;
        }
        var b = flatten(Array.isArray(a) ? a : a.toArray());
        var count = 0;
        for (var i = 0; i < b.length; i++) {
          if (compareNatural(b[i], e2) === 0) {
            count++;
          }
        }
        return count;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setPowerset.js
  var name192 = "setPowerset";
  var dependencies193 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetPowerset = /* @__PURE__ */ factory(name192, dependencies193, (_ref) => {
    var {
      typed,
      size,
      subset,
      compareNatural,
      Index
    } = _ref;
    return typed(name192, {
      "Array | Matrix": function ArrayMatrix(a) {
        if (subset(size(a), new Index(0)) === 0) {
          return [];
        }
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
        var result = [];
        var number = 0;
        while (number.toString(2).length <= b.length) {
          result.push(_subset(b, number.toString(2).split("").reverse()));
          number++;
        }
        return _sort(result);
      }
    });
    function _subset(array, bitarray) {
      var result = [];
      for (var i = 0; i < bitarray.length; i++) {
        if (bitarray[i] === "1") {
          result.push(array[i]);
        }
      }
      return result;
    }
    function _sort(array) {
      var temp = [];
      for (var i = array.length - 1; i > 0; i--) {
        for (var j = 0; j < i; j++) {
          if (array[j].length > array[j + 1].length) {
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
          }
        }
      }
      return array;
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setSize.js
  var name193 = "setSize";
  var dependencies194 = ["typed", "compareNatural"];
  var createSetSize = /* @__PURE__ */ factory(name193, dependencies194, (_ref) => {
    var {
      typed,
      compareNatural
    } = _ref;
    return typed(name193, {
      "Array | Matrix": function ArrayMatrix(a) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      },
      "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
        if (unique === false || a.length === 0) {
          return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural);
          var count = 1;
          for (var i = 1; i < b.length; i++) {
            if (compareNatural(b[i], b[i - 1]) !== 0) {
              count++;
            }
          }
          return count;
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setSymDifference.js
  var name194 = "setSymDifference";
  var dependencies195 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
  var createSetSymDifference = /* @__PURE__ */ factory(name194, dependencies195, (_ref) => {
    var {
      typed,
      size,
      concat,
      subset,
      setDifference,
      Index
    } = _ref;
    return typed(name194, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          return flatten(a2);
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1);
        }
        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat(setDifference(b1, b2), setDifference(b2, b1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setUnion.js
  var name195 = "setUnion";
  var dependencies196 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
  var createSetUnion = /* @__PURE__ */ factory(name195, dependencies196, (_ref) => {
    var {
      typed,
      size,
      concat,
      subset,
      setIntersect,
      setSymDifference,
      Index
    } = _ref;
    return typed(name195, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset(size(a1), new Index(0)) === 0) {
          return flatten(a2);
        } else if (subset(size(a2), new Index(0)) === 0) {
          return flatten(a1);
        }
        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat(setSymDifference(b1, b2), setIntersect(b1, b2));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/add.js
  var name196 = "add";
  var dependencies197 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix"];
  var createAdd = /* @__PURE__ */ factory(name196, dependencies197, (_ref) => {
    var {
      typed,
      matrix,
      addScalar,
      equalScalar,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed
    });
    var matAlgo04xSidSid = createMatAlgo04xSidSid({
      typed,
      equalScalar
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed,
      DenseMatrix
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed,
      matrix
    });
    return typed(name196, {
      "any, any": addScalar,
      "any, any, ...any": typed.referToSelf((self2) => (x, y, rest) => {
        var result = self2(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = self2(result, rest[i]);
        }
        return result;
      })
    }, matrixAlgorithmSuite({
      elop: addScalar,
      DS: matAlgo01xDSid,
      SS: matAlgo04xSidSid,
      Ss: matAlgo10xSids
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
  var name197 = "hypot";
  var dependencies198 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
  var createHypot = /* @__PURE__ */ factory(name197, dependencies198, (_ref) => {
    var {
      typed,
      abs: abs2,
      addScalar,
      divideScalar,
      multiplyScalar,
      sqrt: sqrt2,
      smaller,
      isPositive
    } = _ref;
    return typed(name197, {
      "... number | BigNumber": _hypot,
      Array: _hypot,
      Matrix: (M) => _hypot(flatten(M.toArray()))
    });
    function _hypot(args) {
      var result = 0;
      var largest = 0;
      for (var i = 0; i < args.length; i++) {
        if (isComplex(args[i])) {
          throw new TypeError("Unexpected type of argument to hypot");
        }
        var value = abs2(args[i]);
        if (smaller(largest, value)) {
          result = multiplyScalar(result, multiplyScalar(divideScalar(largest, value), divideScalar(largest, value)));
          result = addScalar(result, 1);
          largest = value;
        } else {
          result = addScalar(result, isPositive(value) ? multiplyScalar(divideScalar(value, largest), divideScalar(value, largest)) : value);
        }
      }
      return multiplyScalar(largest, sqrt2(result));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/norm.js
  var name198 = "norm";
  var dependencies199 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
  var createNorm = /* @__PURE__ */ factory(name198, dependencies199, (_ref) => {
    var {
      typed,
      abs: abs2,
      add: add2,
      pow: pow2,
      conj,
      sqrt: sqrt2,
      multiply,
      equalScalar,
      larger,
      smaller,
      matrix,
      ctranspose,
      eigs
    } = _ref;
    return typed(name198, {
      number: Math.abs,
      Complex: function Complex2(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        return x.abs();
      },
      boolean: function boolean(x) {
        return Math.abs(x);
      },
      Array: function Array2(x) {
        return _norm(matrix(x), 2);
      },
      Matrix: function Matrix(x) {
        return _norm(x, 2);
      },
      "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
        return _norm(matrix(x), p);
      },
      "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
        return _norm(x, p);
      }
    });
    function _vectorNormPlusInfinity(x) {
      var pinf = 0;
      x.forEach(function(value) {
        var v = abs2(value);
        if (larger(v, pinf)) {
          pinf = v;
        }
      }, true);
      return pinf;
    }
    function _vectorNormMinusInfinity(x) {
      var ninf;
      x.forEach(function(value) {
        var v = abs2(value);
        if (!ninf || smaller(v, ninf)) {
          ninf = v;
        }
      }, true);
      return ninf || 0;
    }
    function _vectorNorm(x, p) {
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _vectorNormPlusInfinity(x);
      }
      if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
        return _vectorNormMinusInfinity(x);
      }
      if (p === "fro") {
        return _norm(x, 2);
      }
      if (typeof p === "number" && !isNaN(p)) {
        if (!equalScalar(p, 0)) {
          var n = 0;
          x.forEach(function(value) {
            n = add2(pow2(abs2(value), p), n);
          }, true);
          return pow2(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      throw new Error("Unsupported parameter value");
    }
    function _matrixNormFrobenius(x) {
      var fro = 0;
      x.forEach(function(value, index) {
        fro = add2(fro, multiply(value, conj(value)));
      });
      return abs2(sqrt2(fro));
    }
    function _matrixNormOne(x) {
      var c = [];
      var maxc = 0;
      x.forEach(function(value, index) {
        var j = index[1];
        var cj = add2(c[j] || 0, abs2(value));
        if (larger(cj, maxc)) {
          maxc = cj;
        }
        c[j] = cj;
      }, true);
      return maxc;
    }
    function _matrixNormTwo(x) {
      var sizeX = x.size();
      if (sizeX[0] !== sizeX[1]) {
        throw new RangeError("Invalid matrix dimensions");
      }
      var tx = ctranspose(x);
      var squaredX = multiply(tx, x);
      var eigenVals = eigs(squaredX).values.toArray();
      var rho = eigenVals[eigenVals.length - 1];
      return abs2(sqrt2(rho));
    }
    function _matrixNormInfinity(x) {
      var r = [];
      var maxr = 0;
      x.forEach(function(value, index) {
        var i = index[0];
        var ri = add2(r[i] || 0, abs2(value));
        if (larger(ri, maxr)) {
          maxr = ri;
        }
        r[i] = ri;
      }, true);
      return maxr;
    }
    function _matrixNorm(x, p) {
      if (p === 1) {
        return _matrixNormOne(x);
      }
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _matrixNormInfinity(x);
      }
      if (p === "fro") {
        return _matrixNormFrobenius(x);
      }
      if (p === 2) {
        return _matrixNormTwo(x);
      }
      throw new Error("Unsupported parameter value " + p);
    }
    function _norm(x, p) {
      var sizeX = x.size();
      if (sizeX.length === 1) {
        return _vectorNorm(x, p);
      }
      if (sizeX.length === 2) {
        if (sizeX[0] && sizeX[1]) {
          return _matrixNorm(x, p);
        } else {
          throw new RangeError("Invalid matrix dimensions");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/dot.js
  var name199 = "dot";
  var dependencies200 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
  var createDot = /* @__PURE__ */ factory(name199, dependencies200, (_ref) => {
    var {
      typed,
      addScalar,
      multiplyScalar,
      conj,
      size
    } = _ref;
    return typed(name199, {
      "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
      "SparseMatrix, SparseMatrix": _sparseDot
    });
    function _validateDim(x, y) {
      var xSize = _size(x);
      var ySize = _size(y);
      var xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
      }
      if (xLen !== yLen)
        throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
      if (xLen === 0)
        throw new RangeError("Cannot calculate the dot product of empty vectors");
      return xLen;
    }
    function _denseDot(a, b) {
      var N = _validateDim(a, b);
      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype : void 0;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype : void 0;
      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add2 = addScalar;
      var mul2 = multiplyScalar;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        var dt = adt;
        add2 = typed.find(addScalar, [dt, dt]);
        mul2 = typed.find(multiplyScalar, [dt, dt]);
      }
      if (!aIsColumn && !bIsColumn) {
        var c = mul2(conj(adata[0]), bdata[0]);
        for (var i = 1; i < N; i++) {
          c = add2(c, mul2(conj(adata[i]), bdata[i]));
        }
        return c;
      }
      if (!aIsColumn && bIsColumn) {
        var _c = mul2(conj(adata[0]), bdata[0][0]);
        for (var _i = 1; _i < N; _i++) {
          _c = add2(_c, mul2(conj(adata[_i]), bdata[_i][0]));
        }
        return _c;
      }
      if (aIsColumn && !bIsColumn) {
        var _c2 = mul2(conj(adata[0][0]), bdata[0]);
        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add2(_c2, mul2(conj(adata[_i2][0]), bdata[_i2]));
        }
        return _c2;
      }
      if (aIsColumn && bIsColumn) {
        var _c3 = mul2(conj(adata[0][0]), bdata[0][0]);
        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add2(_c3, mul2(conj(adata[_i3][0]), bdata[_i3][0]));
        }
        return _c3;
      }
    }
    function _sparseDot(x, y) {
      _validateDim(x, y);
      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y._index;
      var yvalues = y._values;
      var c = 0;
      var add2 = addScalar;
      var mul2 = multiplyScalar;
      var i = 0;
      var j = 0;
      while (i < xindex.length && j < yindex.length) {
        var I = xindex[i];
        var J = yindex[j];
        if (I < J) {
          i++;
          continue;
        }
        if (I > J) {
          j++;
          continue;
        }
        if (I === J) {
          c = add2(c, mul2(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }
      return c;
    }
    function _size(x) {
      return isMatrix(x) ? x.size() : size(x);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/trace.js
  var name200 = "trace";
  var dependencies201 = ["typed", "matrix", "add"];
  var createTrace = /* @__PURE__ */ factory(name200, dependencies201, (_ref) => {
    var {
      typed,
      matrix,
      add: add2
    } = _ref;
    return typed("trace", {
      Array: function _arrayTrace(x) {
        return _denseTrace(matrix(x));
      },
      SparseMatrix: _sparseTrace,
      DenseMatrix: _denseTrace,
      any: clone
    });
    function _denseTrace(m) {
      var size = m._size;
      var data = m._data;
      switch (size.length) {
        case 1:
          if (size[0] === 1) {
            return clone(data[0]);
          }
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        case 2: {
          var rows = size[0];
          var cols = size[1];
          if (rows === cols) {
            var sum2 = 0;
            for (var i = 0; i < rows; i++) {
              sum2 = add2(sum2, data[i][i]);
            }
            return sum2;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
      }
    }
    function _sparseTrace(m) {
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var size = m._size;
      var rows = size[0];
      var columns = size[1];
      if (rows === columns) {
        var sum2 = 0;
        if (values2.length > 0) {
          for (var j = 0; j < columns; j++) {
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            for (var k = k0; k < k1; k++) {
              var i = index[k];
              if (i === j) {
                sum2 = add2(sum2, values2[k]);
                break;
              }
              if (i > j) {
                break;
              }
            }
          }
        }
        return sum2;
      }
      throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/index.js
  var name201 = "index";
  var dependencies202 = ["typed", "Index"];
  var createIndex = /* @__PURE__ */ factory(name201, dependencies202, (_ref) => {
    var {
      typed,
      Index
    } = _ref;
    return typed(name201, {
      "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
        var ranges = args.map(function(arg) {
          if (isBigNumber(arg)) {
            return arg.toNumber();
          } else if (Array.isArray(arg) || isMatrix(arg)) {
            return arg.map(function(elem) {
              return isBigNumber(elem) ? elem.toNumber() : elem;
            });
          } else {
            return arg;
          }
        });
        var res = new Index();
        Index.apply(res, ranges);
        return res;
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/keywords.js
  var keywords = /* @__PURE__ */ new Set(["end"]);

  // node_modules/mathjs/lib/esm/expression/node/Node.js
  var name202 = "Node";
  var dependencies203 = ["mathWithTransform"];
  var createNode = /* @__PURE__ */ factory(name202, dependencies203, (_ref) => {
    var {
      mathWithTransform
    } = _ref;
    function _validateScope(scope) {
      for (var symbol of [...keywords]) {
        if (scope.has(symbol)) {
          throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
        }
      }
    }
    class Node {
      get type() {
        return "Node";
      }
      get isNode() {
        return true;
      }
      evaluate(scope) {
        return this.compile().evaluate(scope);
      }
      compile() {
        var expr = this._compile(mathWithTransform, {});
        var args = {};
        var context = null;
        function evaluate(scope) {
          var s = createMap(scope);
          _validateScope(s);
          return expr(s, args, context);
        }
        return {
          evaluate
        };
      }
      _compile(math2, argNames) {
        throw new Error("Method _compile must be implemented by type " + this.type);
      }
      forEach(callback) {
        throw new Error("Cannot run forEach on a Node interface");
      }
      map(callback) {
        throw new Error("Cannot run map on a Node interface");
      }
      _ifNode(node) {
        if (!isNode(node)) {
          throw new TypeError("Callback function must return a Node");
        }
        return node;
      }
      traverse(callback) {
        callback(this, null, null);
        function _traverse(node, callback2) {
          node.forEach(function(child, path, parent) {
            callback2(child, path, parent);
            _traverse(child, callback2);
          });
        }
        _traverse(this, callback);
      }
      transform(callback) {
        function _transform(child, path, parent) {
          var replacement = callback(child, path, parent);
          if (replacement !== child) {
            return replacement;
          }
          return child.map(_transform);
        }
        return _transform(this, null, null);
      }
      filter(callback) {
        var nodes = [];
        this.traverse(function(node, path, parent) {
          if (callback(node, path, parent)) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      clone() {
        throw new Error("Cannot clone a Node interface");
      }
      cloneDeep() {
        return this.map(function(node) {
          return node.cloneDeep();
        });
      }
      equals(other) {
        return other ? this.type === other.type && deepStrictEqual(this, other) : false;
      }
      toString(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toString(options);
      }
      toJSON() {
        throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
      }
      toHTML(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this.toHTML(options);
      }
      _toString() {
        throw new Error("_toString not implemented for " + this.type);
      }
      toTex(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toTex(options);
      }
      _toTex(options) {
        throw new Error("_toTex not implemented for " + this.type);
      }
      _getCustomString(options) {
        if (options && typeof options === "object") {
          switch (typeof options.handler) {
            case "object":
            case "undefined":
              return;
            case "function":
              return options.handler(this, options);
            default:
              throw new TypeError("Object or function expected as callback");
          }
        }
      }
      getIdentifier() {
        return this.type;
      }
      getContent() {
        return this;
      }
    }
    return Node;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
  function errorTransform(err) {
    if (err && err.isIndexError) {
      return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
    }
    return err;
  }

  // node_modules/mathjs/lib/esm/expression/node/utils/access.js
  function accessFactory(_ref) {
    var {
      subset
    } = _ref;
    return function access(object, index) {
      try {
        if (Array.isArray(object)) {
          return subset(object, index);
        } else if (object && typeof object.subset === "function") {
          return object.subset(index);
        } else if (typeof object === "string") {
          return subset(object, index);
        } else if (typeof object === "object") {
          if (!index.isObjectProperty()) {
            throw new TypeError("Cannot apply a numeric index as object property");
          }
          return getSafeProperty(object, index.getObjectProperty());
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
  var name203 = "AccessorNode";
  var dependencies204 = ["subset", "Node"];
  var createAccessorNode = /* @__PURE__ */ factory(name203, dependencies204, (_ref) => {
    var {
      subset,
      Node
    } = _ref;
    var access = accessFactory({
      subset
    });
    function needParenthesis(node) {
      return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
    }
    class AccessorNode extends Node {
      constructor(object, index) {
        super();
        if (!isNode(object)) {
          throw new TypeError('Node expected for parameter "object"');
        }
        if (!isIndexNode(index)) {
          throw new TypeError('IndexNode expected for parameter "index"');
        }
        this.object = object;
        this.index = index;
      }
      get name() {
        if (this.index) {
          return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
        } else {
          return this.object.name || "";
        }
      }
      get type() {
        return name203;
      }
      get isAccessorNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalObject = this.object._compile(math2, argNames);
        var evalIndex = this.index._compile(math2, argNames);
        if (this.index.isObjectProperty()) {
          var prop = this.index.getObjectProperty();
          return function evalAccessorNode(scope, args, context) {
            return getSafeProperty(evalObject(scope, args, context), prop);
          };
        } else {
          return function evalAccessorNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var index = evalIndex(scope, args, object);
            return access(object, index);
          };
        }
      }
      forEach(callback) {
        callback(this.object, "object", this);
        callback(this.index, "index", this);
      }
      map(callback) {
        return new AccessorNode(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
      }
      clone() {
        return new AccessorNode(this.object, this.index);
      }
      _toString(options) {
        var object = this.object.toString(options);
        if (needParenthesis(this.object)) {
          object = "(" + object + ")";
        }
        return object + this.index.toString(options);
      }
      toHTML(options) {
        var object = this.object.toHTML(options);
        if (needParenthesis(this.object)) {
          object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return object + this.index.toHTML(options);
      }
      _toTex(options) {
        var object = this.object.toTex(options);
        if (needParenthesis(this.object)) {
          object = "\\left(' + object + '\\right)";
        }
        return object + this.index.toTex(options);
      }
      toJSON() {
        return {
          mathjs: name203,
          object: this.object,
          index: this.index
        };
      }
      static fromJSON(json) {
        return new AccessorNode(json.object, json.index);
      }
    }
    _defineProperty(AccessorNode, "name", name203);
    return AccessorNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
  var name204 = "ArrayNode";
  var dependencies205 = ["Node"];
  var createArrayNode = /* @__PURE__ */ factory(name204, dependencies205, (_ref) => {
    var {
      Node
    } = _ref;
    class ArrayNode extends Node {
      constructor(items) {
        super();
        this.items = items || [];
        if (!Array.isArray(this.items) || !this.items.every(isNode)) {
          throw new TypeError("Array containing Nodes expected");
        }
      }
      get type() {
        return name204;
      }
      get isArrayNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalItems = map(this.items, function(item) {
          return item._compile(math2, argNames);
        });
        var asMatrix = math2.config.matrix !== "Array";
        if (asMatrix) {
          var matrix = math2.matrix;
          return function evalArrayNode(scope, args, context) {
            return matrix(map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            }));
          };
        } else {
          return function evalArrayNode(scope, args, context) {
            return map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            });
          };
        }
      }
      forEach(callback) {
        for (var i = 0; i < this.items.length; i++) {
          var node = this.items[i];
          callback(node, "items[" + i + "]", this);
        }
      }
      map(callback) {
        var items = [];
        for (var i = 0; i < this.items.length; i++) {
          items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
        }
        return new ArrayNode(items);
      }
      clone() {
        return new ArrayNode(this.items.slice(0));
      }
      _toString(options) {
        var items = this.items.map(function(node) {
          return node.toString(options);
        });
        return "[" + items.join(", ") + "]";
      }
      toJSON() {
        return {
          mathjs: name204,
          items: this.items
        };
      }
      static fromJSON(json) {
        return new ArrayNode(json.items);
      }
      toHTML(options) {
        var items = this.items.map(function(node) {
          return node.toHTML(options);
        });
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
      _toTex(options) {
        function itemsToTex(items, nested) {
          var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
          var itemsFormRow = nested || mixedItems;
          var itemSep = itemsFormRow ? "&" : "\\\\";
          var itemsTex = items.map(function(node) {
            if (node.items) {
              return itemsToTex(node.items, !nested);
            } else {
              return node.toTex(options);
            }
          }).join(itemSep);
          return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
        }
        return itemsToTex(this.items, false);
      }
    }
    _defineProperty(ArrayNode, "name", name204);
    return ArrayNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/utils/assign.js
  function assignFactory(_ref) {
    var {
      subset,
      matrix
    } = _ref;
    return function assign2(object, index, value) {
      try {
        if (Array.isArray(object)) {
          return matrix(object).subset(index, value).valueOf();
        } else if (object && typeof object.subset === "function") {
          return object.subset(index, value);
        } else if (typeof object === "string") {
          return subset(object, index, value);
        } else if (typeof object === "object") {
          if (!index.isObjectProperty()) {
            throw TypeError("Cannot apply a numeric index as object property");
          }
          setSafeProperty(object, index.getObjectProperty(), value);
          return object;
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // node_modules/mathjs/lib/esm/expression/operators.js
  var properties = [{
    AssignmentNode: {},
    FunctionAssignmentNode: {}
  }, {
    ConditionalNode: {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
    }
  }, {
    "OperatorNode:or": {
      op: "or",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:xor": {
      op: "xor",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:and": {
      op: "and",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:bitOr": {
      op: "|",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:bitXor": {
      op: "^|",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:bitAnd": {
      op: "&",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:equal": {
      op: "==",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:unequal": {
      op: "!=",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smaller": {
      op: "<",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:larger": {
      op: ">",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smallerEq": {
      op: "<=",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:largerEq": {
      op: ">=",
      associativity: "left",
      associativeWith: []
    },
    RelationalNode: {
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:leftShift": {
      op: "<<",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightArithShift": {
      op: ">>",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightLogShift": {
      op: ">>>",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:to": {
      op: "to",
      associativity: "left",
      associativeWith: []
    }
  }, {
    RangeNode: {}
  }, {
    "OperatorNode:add": {
      op: "+",
      associativity: "left",
      associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
    },
    "OperatorNode:subtract": {
      op: "-",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:multiply": {
      op: "*",
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
    },
    "OperatorNode:divide": {
      op: "/",
      associativity: "left",
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
    },
    "OperatorNode:dotMultiply": {
      op: ".*",
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
    },
    "OperatorNode:dotDivide": {
      op: "./",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:mod": {
      op: "mod",
      associativity: "left",
      associativeWith: []
    }
  }, {
    "OperatorNode:multiply": {
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
    }
  }, {
    "OperatorNode:unaryPlus": {
      op: "+",
      associativity: "right"
    },
    "OperatorNode:unaryMinus": {
      op: "-",
      associativity: "right"
    },
    "OperatorNode:bitNot": {
      op: "~",
      associativity: "right"
    },
    "OperatorNode:not": {
      op: "not",
      associativity: "right"
    }
  }, {
    "OperatorNode:pow": {
      op: "^",
      associativity: "right",
      associativeWith: [],
      latexRightParens: false
    },
    "OperatorNode:dotPow": {
      op: ".^",
      associativity: "right",
      associativeWith: []
    }
  }, {
    "OperatorNode:factorial": {
      op: "!",
      associativity: "left"
    }
  }, {
    "OperatorNode:ctranspose": {
      op: "'",
      associativity: "left"
    }
  }];
  function unwrapParen(_node, parenthesis) {
    if (!parenthesis || parenthesis !== "auto")
      return _node;
    var node = _node;
    while (isParenthesisNode(node)) {
      node = node.content;
    }
    return node;
  }
  function getPrecedence(_node, parenthesis, implicit, parent) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var precedence = null;
    for (var i = 0; i < properties.length; i++) {
      if (identifier in properties[i]) {
        precedence = i;
        break;
      }
    }
    if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
      var leftArg = unwrapParen(node.args[0], parenthesis);
      if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
        precedence += 1;
      }
    }
    return precedence;
  }
  function getAssociativity(_node, parenthesis) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var index = getPrecedence(node, parenthesis);
    if (index === null) {
      return null;
    }
    var property = properties[index][identifier];
    if (hasOwnProperty2(property, "associativity")) {
      if (property.associativity === "left") {
        return "left";
      }
      if (property.associativity === "right") {
        return "right";
      }
      throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
    }
    return null;
  }
  function isAssociativeWith(nodeA, nodeB, parenthesis) {
    var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
    var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
    var identifierA = a.getIdentifier();
    var identifierB = b.getIdentifier();
    var index = getPrecedence(a, parenthesis);
    if (index === null) {
      return null;
    }
    var property = properties[index][identifierA];
    if (hasOwnProperty2(property, "associativeWith") && property.associativeWith instanceof Array) {
      for (var i = 0; i < property.associativeWith.length; i++) {
        if (property.associativeWith[i] === identifierB) {
          return true;
        }
      }
      return false;
    }
    return null;
  }
  function getOperator(fn) {
    var identifier = "OperatorNode:" + fn;
    for (var group of properties) {
      if (identifier in group) {
        return group[identifier].op;
      }
    }
    return null;
  }

  // node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
  var name205 = "AssignmentNode";
  var dependencies206 = [
    "subset",
    "?matrix",
    "Node"
  ];
  var createAssignmentNode = /* @__PURE__ */ factory(name205, dependencies206, (_ref) => {
    var {
      subset,
      matrix,
      Node
    } = _ref;
    var access = accessFactory({
      subset
    });
    var assign2 = assignFactory({
      subset,
      matrix
    });
    function needParenthesis(node, parenthesis, implicit) {
      if (!parenthesis) {
        parenthesis = "keep";
      }
      var precedence = getPrecedence(node, parenthesis, implicit);
      var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    class AssignmentNode extends Node {
      constructor(object, index, value) {
        super();
        this.object = object;
        this.index = value ? index : null;
        this.value = value || index;
        if (!isSymbolNode(object) && !isAccessorNode(object)) {
          throw new TypeError('SymbolNode or AccessorNode expected as "object"');
        }
        if (isSymbolNode(object) && object.name === "end") {
          throw new Error('Cannot assign to symbol "end"');
        }
        if (this.index && !isIndexNode(this.index)) {
          throw new TypeError('IndexNode expected as "index"');
        }
        if (!isNode(this.value)) {
          throw new TypeError('Node expected as "value"');
        }
      }
      get name() {
        if (this.index) {
          return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
        } else {
          return this.object.name || "";
        }
      }
      get type() {
        return name205;
      }
      get isAssignmentNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalObject = this.object._compile(math2, argNames);
        var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
        var evalValue = this.value._compile(math2, argNames);
        var name297 = this.object.name;
        if (!this.index) {
          if (!isSymbolNode(this.object)) {
            throw new TypeError("SymbolNode expected as object");
          }
          return function evalAssignmentNode(scope, args, context) {
            var value = evalValue(scope, args, context);
            scope.set(name297, value);
            return value;
          };
        } else if (this.index.isObjectProperty()) {
          var prop = this.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var value = evalValue(scope, args, context);
            setSafeProperty(object, prop, value);
            return value;
          };
        } else if (isSymbolNode(this.object)) {
          return function evalAssignmentNode(scope, args, context) {
            var childObject = evalObject(scope, args, context);
            var value = evalValue(scope, args, context);
            var index = evalIndex(scope, args, childObject);
            scope.set(name297, assign2(childObject, index, value));
            return value;
          };
        } else {
          var evalParentObject = this.object.object._compile(math2, argNames);
          if (this.object.index.isObjectProperty()) {
            var parentProp = this.object.index.getObjectProperty();
            return function evalAssignmentNode(scope, args, context) {
              var parent = evalParentObject(scope, args, context);
              var childObject = getSafeProperty(parent, parentProp);
              var index = evalIndex(scope, args, childObject);
              var value = evalValue(scope, args, context);
              setSafeProperty(parent, parentProp, assign2(childObject, index, value));
              return value;
            };
          } else {
            var evalParentIndex = this.object.index._compile(math2, argNames);
            return function evalAssignmentNode(scope, args, context) {
              var parent = evalParentObject(scope, args, context);
              var parentIndex = evalParentIndex(scope, args, parent);
              var childObject = access(parent, parentIndex);
              var index = evalIndex(scope, args, childObject);
              var value = evalValue(scope, args, context);
              assign2(parent, parentIndex, assign2(childObject, index, value));
              return value;
            };
          }
        }
      }
      forEach(callback) {
        callback(this.object, "object", this);
        if (this.index) {
          callback(this.index, "index", this);
        }
        callback(this.value, "value", this);
      }
      map(callback) {
        var object = this._ifNode(callback(this.object, "object", this));
        var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
        var value = this._ifNode(callback(this.value, "value", this));
        return new AssignmentNode(object, index, value);
      }
      clone() {
        return new AssignmentNode(this.object, this.index, this.value);
      }
      _toString(options) {
        var object = this.object.toString(options);
        var index = this.index ? this.index.toString(options) : "";
        var value = this.value.toString(options);
        if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
          value = "(" + value + ")";
        }
        return object + index + " = " + value;
      }
      toJSON() {
        return {
          mathjs: name205,
          object: this.object,
          index: this.index,
          value: this.value
        };
      }
      static fromJSON(json) {
        return new AssignmentNode(json.object, json.index, json.value);
      }
      toHTML(options) {
        var object = this.object.toHTML(options);
        var index = this.index ? this.index.toHTML(options) : "";
        var value = this.value.toHTML(options);
        if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
          value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
        return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
      }
      _toTex(options) {
        var object = this.object.toTex(options);
        var index = this.index ? this.index.toTex(options) : "";
        var value = this.value.toTex(options);
        if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
          value = "\\left(".concat(value, "\\right)");
        }
        return object + index + ":=" + value;
      }
    }
    _defineProperty(AssignmentNode, "name", name205);
    return AssignmentNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/BlockNode.js
  var name206 = "BlockNode";
  var dependencies207 = ["ResultSet", "Node"];
  var createBlockNode = /* @__PURE__ */ factory(name206, dependencies207, (_ref) => {
    var {
      ResultSet,
      Node
    } = _ref;
    class BlockNode extends Node {
      constructor(blocks) {
        super();
        if (!Array.isArray(blocks))
          throw new Error("Array expected");
        this.blocks = blocks.map(function(block) {
          var node = block && block.node;
          var visible = block && block.visible !== void 0 ? block.visible : true;
          if (!isNode(node))
            throw new TypeError('Property "node" must be a Node');
          if (typeof visible !== "boolean") {
            throw new TypeError('Property "visible" must be a boolean');
          }
          return {
            node,
            visible
          };
        });
      }
      get type() {
        return name206;
      }
      get isBlockNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalBlocks = map(this.blocks, function(block) {
          return {
            evaluate: block.node._compile(math2, argNames),
            visible: block.visible
          };
        });
        return function evalBlockNodes(scope, args, context) {
          var results = [];
          forEach(evalBlocks, function evalBlockNode(block) {
            var result = block.evaluate(scope, args, context);
            if (block.visible) {
              results.push(result);
            }
          });
          return new ResultSet(results);
        };
      }
      forEach(callback) {
        for (var i = 0; i < this.blocks.length; i++) {
          callback(this.blocks[i].node, "blocks[" + i + "].node", this);
        }
      }
      map(callback) {
        var blocks = [];
        for (var i = 0; i < this.blocks.length; i++) {
          var block = this.blocks[i];
          var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
          blocks[i] = {
            node,
            visible: block.visible
          };
        }
        return new BlockNode(blocks);
      }
      clone() {
        var blocks = this.blocks.map(function(block) {
          return {
            node: block.node,
            visible: block.visible
          };
        });
        return new BlockNode(blocks);
      }
      _toString(options) {
        return this.blocks.map(function(param) {
          return param.node.toString(options) + (param.visible ? "" : ";");
        }).join("\n");
      }
      toJSON() {
        return {
          mathjs: name206,
          blocks: this.blocks
        };
      }
      static fromJSON(json) {
        return new BlockNode(json.blocks);
      }
      toHTML(options) {
        return this.blocks.map(function(param) {
          return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
        }).join('<span class="math-separator"><br /></span>');
      }
      _toTex(options) {
        return this.blocks.map(function(param) {
          return param.node.toTex(options) + (param.visible ? "" : ";");
        }).join("\\;\\;\n");
      }
    }
    _defineProperty(BlockNode, "name", name206);
    return BlockNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
  var name207 = "ConditionalNode";
  var dependencies208 = ["Node"];
  var createConditionalNode = /* @__PURE__ */ factory(name207, dependencies208, (_ref) => {
    var {
      Node
    } = _ref;
    function testCondition(condition) {
      if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
        return !!condition;
      }
      if (condition) {
        if (isBigNumber(condition)) {
          return !condition.isZero();
        }
        if (isComplex(condition)) {
          return !!(condition.re || condition.im);
        }
        if (isUnit(condition)) {
          return !!condition.value;
        }
      }
      if (condition === null || condition === void 0) {
        return false;
      }
      throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
    }
    class ConditionalNode extends Node {
      constructor(condition, trueExpr, falseExpr) {
        super();
        if (!isNode(condition)) {
          throw new TypeError("Parameter condition must be a Node");
        }
        if (!isNode(trueExpr)) {
          throw new TypeError("Parameter trueExpr must be a Node");
        }
        if (!isNode(falseExpr)) {
          throw new TypeError("Parameter falseExpr must be a Node");
        }
        this.condition = condition;
        this.trueExpr = trueExpr;
        this.falseExpr = falseExpr;
      }
      get type() {
        return name207;
      }
      get isConditionalNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalCondition = this.condition._compile(math2, argNames);
        var evalTrueExpr = this.trueExpr._compile(math2, argNames);
        var evalFalseExpr = this.falseExpr._compile(math2, argNames);
        return function evalConditionalNode(scope, args, context) {
          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
        };
      }
      forEach(callback) {
        callback(this.condition, "condition", this);
        callback(this.trueExpr, "trueExpr", this);
        callback(this.falseExpr, "falseExpr", this);
      }
      map(callback) {
        return new ConditionalNode(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
      }
      clone() {
        return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
      }
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var condition = this.condition.toString(options);
        var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = "(" + condition + ")";
        }
        var trueExpr = this.trueExpr.toString(options);
        var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = "(" + trueExpr + ")";
        }
        var falseExpr = this.falseExpr.toString(options);
        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = "(" + falseExpr + ")";
        }
        return condition + " ? " + trueExpr + " : " + falseExpr;
      }
      toJSON() {
        return {
          mathjs: name207,
          condition: this.condition,
          trueExpr: this.trueExpr,
          falseExpr: this.falseExpr
        };
      }
      static fromJSON(json) {
        return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
      }
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var condition = this.condition.toHTML(options);
        var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        var trueExpr = this.trueExpr.toHTML(options);
        var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        var falseExpr = this.falseExpr.toHTML(options);
        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
      }
      _toTex(options) {
        return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
      }
    }
    _defineProperty(ConditionalNode, "name", name207);
    return ConditionalNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/utils/latex.js
  var import_escape_latex = __toESM(require_dist(), 1);
  var latexSymbols = {
    Alpha: "A",
    alpha: "\\alpha",
    Beta: "B",
    beta: "\\beta",
    Gamma: "\\Gamma",
    gamma: "\\gamma",
    Delta: "\\Delta",
    delta: "\\delta",
    Epsilon: "E",
    epsilon: "\\epsilon",
    varepsilon: "\\varepsilon",
    Zeta: "Z",
    zeta: "\\zeta",
    Eta: "H",
    eta: "\\eta",
    Theta: "\\Theta",
    theta: "\\theta",
    vartheta: "\\vartheta",
    Iota: "I",
    iota: "\\iota",
    Kappa: "K",
    kappa: "\\kappa",
    varkappa: "\\varkappa",
    Lambda: "\\Lambda",
    lambda: "\\lambda",
    Mu: "M",
    mu: "\\mu",
    Nu: "N",
    nu: "\\nu",
    Xi: "\\Xi",
    xi: "\\xi",
    Omicron: "O",
    omicron: "o",
    Pi: "\\Pi",
    pi: "\\pi",
    varpi: "\\varpi",
    Rho: "P",
    rho: "\\rho",
    varrho: "\\varrho",
    Sigma: "\\Sigma",
    sigma: "\\sigma",
    varsigma: "\\varsigma",
    Tau: "T",
    tau: "\\tau",
    Upsilon: "\\Upsilon",
    upsilon: "\\upsilon",
    Phi: "\\Phi",
    phi: "\\phi",
    varphi: "\\varphi",
    Chi: "X",
    chi: "\\chi",
    Psi: "\\Psi",
    psi: "\\psi",
    Omega: "\\Omega",
    omega: "\\omega",
    true: "\\mathrm{True}",
    false: "\\mathrm{False}",
    i: "i",
    inf: "\\infty",
    Inf: "\\infty",
    infinity: "\\infty",
    Infinity: "\\infty",
    oo: "\\infty",
    lim: "\\lim",
    undefined: "\\mathbf{?}"
  };
  var latexOperators = {
    transpose: "^\\top",
    ctranspose: "^H",
    factorial: "!",
    pow: "^",
    dotPow: ".^\\wedge",
    unaryPlus: "+",
    unaryMinus: "-",
    bitNot: "\\~",
    not: "\\neg",
    multiply: "\\cdot",
    divide: "\\frac",
    dotMultiply: ".\\cdot",
    dotDivide: ".:",
    mod: "\\mod",
    add: "+",
    subtract: "-",
    to: "\\rightarrow",
    leftShift: "<<",
    rightArithShift: ">>",
    rightLogShift: ">>>",
    equal: "=",
    unequal: "\\neq",
    smaller: "<",
    larger: ">",
    smallerEq: "\\leq",
    largerEq: "\\geq",
    bitAnd: "\\&",
    bitXor: "\\underline{|}",
    bitOr: "|",
    and: "\\wedge",
    xor: "\\veebar",
    or: "\\vee"
  };
  var latexFunctions = {
    abs: {
      1: "\\left|${args[0]}\\right|"
    },
    add: {
      2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
    },
    cbrt: {
      1: "\\sqrt[3]{${args[0]}}"
    },
    ceil: {
      1: "\\left\\lceil${args[0]}\\right\\rceil"
    },
    cube: {
      1: "\\left(${args[0]}\\right)^3"
    },
    divide: {
      2: "\\frac{${args[0]}}{${args[1]}}"
    },
    dotDivide: {
      2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
    },
    dotMultiply: {
      2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
    },
    dotPow: {
      2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
    },
    exp: {
      1: "\\exp\\left(${args[0]}\\right)"
    },
    expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
    fix: {
      1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
    },
    floor: {
      1: "\\left\\lfloor${args[0]}\\right\\rfloor"
    },
    gcd: "\\gcd\\left(${args}\\right)",
    hypot: "\\hypot\\left(${args}\\right)",
    log: {
      1: "\\ln\\left(${args[0]}\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
    },
    log10: {
      1: "\\log_{10}\\left(${args[0]}\\right)"
    },
    log1p: {
      1: "\\ln\\left(${args[0]}+1\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
    },
    log2: "\\log_{2}\\left(${args[0]}\\right)",
    mod: {
      2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
    },
    multiply: {
      2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
    },
    norm: {
      1: "\\left\\|${args[0]}\\right\\|",
      2: void 0
    },
    nthRoot: {
      2: "\\sqrt[${args[1]}]{${args[0]}}"
    },
    nthRoots: {
      2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
    },
    pow: {
      2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
    },
    round: {
      1: "\\left\\lfloor${args[0]}\\right\\rceil",
      2: void 0
    },
    sign: {
      1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
    },
    sqrt: {
      1: "\\sqrt{${args[0]}}"
    },
    square: {
      1: "\\left(${args[0]}\\right)^2"
    },
    subtract: {
      2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
    },
    unaryMinus: {
      1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
    },
    unaryPlus: {
      1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
    },
    bitAnd: {
      2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
    },
    bitNot: {
      1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
    },
    bitOr: {
      2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
    },
    bitXor: {
      2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
    },
    leftShift: {
      2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
    },
    rightArithShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
    },
    rightLogShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
    },
    bellNumbers: {
      1: "\\mathrm{B}_{${args[0]}}"
    },
    catalan: {
      1: "\\mathrm{C}_{${args[0]}}"
    },
    stirlingS2: {
      2: "\\mathrm{S}\\left(${args}\\right)"
    },
    arg: {
      1: "\\arg\\left(${args[0]}\\right)"
    },
    conj: {
      1: "\\left(${args[0]}\\right)^*"
    },
    im: {
      1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
    },
    re: {
      1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
    },
    and: {
      2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
    },
    not: {
      1: latexOperators.not + "\\left(${args[0]}\\right)"
    },
    or: {
      2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
    },
    xor: {
      2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
    },
    cross: {
      2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
    },
    ctranspose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
    },
    det: {
      1: "\\det\\left(${args[0]}\\right)"
    },
    dot: {
      2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
    },
    expm: {
      1: "\\exp\\left(${args[0]}\\right)"
    },
    inv: {
      1: "\\left(${args[0]}\\right)^{-1}"
    },
    pinv: {
      1: "\\left(${args[0]}\\right)^{+}"
    },
    sqrtm: {
      1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
    },
    trace: {
      1: "\\mathrm{tr}\\left(${args[0]}\\right)"
    },
    transpose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
    },
    combinations: {
      2: "\\binom{${args[0]}}{${args[1]}}"
    },
    combinationsWithRep: {
      2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
    },
    factorial: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
    },
    gamma: {
      1: "\\Gamma\\left(${args[0]}\\right)"
    },
    lgamma: {
      1: "\\ln\\Gamma\\left(${args[0]}\\right)"
    },
    equal: {
      2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
    },
    larger: {
      2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
    },
    largerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
    },
    smaller: {
      2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
    },
    smallerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
    },
    unequal: {
      2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
    },
    erf: {
      1: "erf\\left(${args[0]}\\right)"
    },
    max: "\\max\\left(${args}\\right)",
    min: "\\min\\left(${args}\\right)",
    variance: "\\mathrm{Var}\\left(${args}\\right)",
    acos: {
      1: "\\cos^{-1}\\left(${args[0]}\\right)"
    },
    acosh: {
      1: "\\cosh^{-1}\\left(${args[0]}\\right)"
    },
    acot: {
      1: "\\cot^{-1}\\left(${args[0]}\\right)"
    },
    acoth: {
      1: "\\coth^{-1}\\left(${args[0]}\\right)"
    },
    acsc: {
      1: "\\csc^{-1}\\left(${args[0]}\\right)"
    },
    acsch: {
      1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
    },
    asec: {
      1: "\\sec^{-1}\\left(${args[0]}\\right)"
    },
    asech: {
      1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
    },
    asin: {
      1: "\\sin^{-1}\\left(${args[0]}\\right)"
    },
    asinh: {
      1: "\\sinh^{-1}\\left(${args[0]}\\right)"
    },
    atan: {
      1: "\\tan^{-1}\\left(${args[0]}\\right)"
    },
    atan2: {
      2: "\\mathrm{atan2}\\left(${args}\\right)"
    },
    atanh: {
      1: "\\tanh^{-1}\\left(${args[0]}\\right)"
    },
    cos: {
      1: "\\cos\\left(${args[0]}\\right)"
    },
    cosh: {
      1: "\\cosh\\left(${args[0]}\\right)"
    },
    cot: {
      1: "\\cot\\left(${args[0]}\\right)"
    },
    coth: {
      1: "\\coth\\left(${args[0]}\\right)"
    },
    csc: {
      1: "\\csc\\left(${args[0]}\\right)"
    },
    csch: {
      1: "\\mathrm{csch}\\left(${args[0]}\\right)"
    },
    sec: {
      1: "\\sec\\left(${args[0]}\\right)"
    },
    sech: {
      1: "\\mathrm{sech}\\left(${args[0]}\\right)"
    },
    sin: {
      1: "\\sin\\left(${args[0]}\\right)"
    },
    sinh: {
      1: "\\sinh\\left(${args[0]}\\right)"
    },
    tan: {
      1: "\\tan\\left(${args[0]}\\right)"
    },
    tanh: {
      1: "\\tanh\\left(${args[0]}\\right)"
    },
    to: {
      2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
    },
    numeric: function numeric(node, options) {
      return node.args[0].toTex();
    },
    number: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
    },
    string: {
      0: '\\mathtt{""}',
      1: "\\mathrm{string}\\left(${args[0]}\\right)"
    },
    bignumber: {
      0: "0",
      1: "\\left(${args[0]}\\right)"
    },
    complex: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
    },
    matrix: {
      0: "\\begin{bmatrix}\\end{bmatrix}",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(${args[0]}\\right)"
    },
    sparse: {
      0: "\\begin{bsparse}\\end{bsparse}",
      1: "\\left(${args[0]}\\right)"
    },
    unit: {
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
    }
  };
  var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
  var latexUnits = {
    deg: "^\\circ"
  };
  function escapeLatex(string) {
    return (0, import_escape_latex.default)(string, {
      preserveFormatting: true
    });
  }
  function toSymbol(name297, isUnit2) {
    isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
    if (isUnit2) {
      if (hasOwnProperty2(latexUnits, name297)) {
        return latexUnits[name297];
      }
      return "\\mathrm{" + escapeLatex(name297) + "}";
    }
    if (hasOwnProperty2(latexSymbols, name297)) {
      return latexSymbols[name297];
    }
    return escapeLatex(name297);
  }

  // node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
  var name208 = "ConstantNode";
  var dependencies209 = ["Node"];
  var createConstantNode = /* @__PURE__ */ factory(name208, dependencies209, (_ref) => {
    var {
      Node
    } = _ref;
    class ConstantNode extends Node {
      constructor(value) {
        super();
        this.value = value;
      }
      get type() {
        return name208;
      }
      get isConstantNode() {
        return true;
      }
      _compile(math2, argNames) {
        var value = this.value;
        return function evalConstantNode() {
          return value;
        };
      }
      forEach(callback) {
      }
      map(callback) {
        return this.clone();
      }
      clone() {
        return new ConstantNode(this.value);
      }
      _toString(options) {
        return format3(this.value, options);
      }
      toHTML(options) {
        var value = this._toString(options);
        switch (typeOf(this.value)) {
          case "number":
          case "BigNumber":
          case "Fraction":
            return '<span class="math-number">' + value + "</span>";
          case "string":
            return '<span class="math-string">' + value + "</span>";
          case "boolean":
            return '<span class="math-boolean">' + value + "</span>";
          case "null":
            return '<span class="math-null-symbol">' + value + "</span>";
          case "undefined":
            return '<span class="math-undefined">' + value + "</span>";
          default:
            return '<span class="math-symbol">' + value + "</span>";
        }
      }
      toJSON() {
        return {
          mathjs: name208,
          value: this.value
        };
      }
      static fromJSON(json) {
        return new ConstantNode(json.value);
      }
      _toTex(options) {
        var value = this._toString(options);
        switch (typeOf(this.value)) {
          case "string":
            return "\\mathtt{" + escapeLatex(value) + "}";
          case "number":
          case "BigNumber":
            {
              if (!isFinite(this.value)) {
                return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
              }
              var index = value.toLowerCase().indexOf("e");
              if (index !== -1) {
                return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
              }
            }
            return value;
          case "Fraction":
            return this.value.toLatex();
          default:
            return value;
        }
      }
    }
    _defineProperty(ConstantNode, "name", name208);
    return ConstantNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
  var name209 = "FunctionAssignmentNode";
  var dependencies210 = ["typed", "Node"];
  var createFunctionAssignmentNode = /* @__PURE__ */ factory(name209, dependencies210, (_ref) => {
    var {
      typed,
      Node
    } = _ref;
    function needParenthesis(node, parenthesis, implicit) {
      var precedence = getPrecedence(node, parenthesis, implicit);
      var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    class FunctionAssignmentNode extends Node {
      constructor(name297, params, expr) {
        super();
        if (typeof name297 !== "string") {
          throw new TypeError('String expected for parameter "name"');
        }
        if (!Array.isArray(params)) {
          throw new TypeError('Array containing strings or objects expected for parameter "params"');
        }
        if (!isNode(expr)) {
          throw new TypeError('Node expected for parameter "expr"');
        }
        if (keywords.has(name297)) {
          throw new Error('Illegal function name, "' + name297 + '" is a reserved keyword');
        }
        var paramNames = /* @__PURE__ */ new Set();
        for (var param of params) {
          var _name = typeof param === "string" ? param : param.name;
          if (paramNames.has(_name)) {
            throw new Error('Duplicate parameter name "'.concat(_name, '"'));
          } else {
            paramNames.add(_name);
          }
        }
        this.name = name297;
        this.params = params.map(function(param2) {
          return param2 && param2.name || param2;
        });
        this.types = params.map(function(param2) {
          return param2 && param2.type || "any";
        });
        this.expr = expr;
      }
      get type() {
        return name209;
      }
      get isFunctionAssignmentNode() {
        return true;
      }
      _compile(math2, argNames) {
        var childArgNames = Object.create(argNames);
        forEach(this.params, function(param) {
          childArgNames[param] = true;
        });
        var evalExpr = this.expr._compile(math2, childArgNames);
        var name297 = this.name;
        var params = this.params;
        var signature = join(this.types, ",");
        var syntax = name297 + "(" + join(this.params, ", ") + ")";
        return function evalFunctionAssignmentNode(scope, args, context) {
          var signatures = {};
          signatures[signature] = function() {
            var childArgs = Object.create(args);
            for (var i = 0; i < params.length; i++) {
              childArgs[params[i]] = arguments[i];
            }
            return evalExpr(scope, childArgs, context);
          };
          var fn = typed(name297, signatures);
          fn.syntax = syntax;
          scope.set(name297, fn);
          return fn;
        };
      }
      forEach(callback) {
        callback(this.expr, "expr", this);
      }
      map(callback) {
        var expr = this._ifNode(callback(this.expr, "expr", this));
        return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
      }
      clone() {
        return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
      }
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var expr = this.expr.toString(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = "(" + expr + ")";
        }
        return this.name + "(" + this.params.join(", ") + ") = " + expr;
      }
      toJSON() {
        var types = this.types;
        return {
          mathjs: name209,
          name: this.name,
          params: this.params.map(function(param, index) {
            return {
              name: param,
              type: types[index]
            };
          }),
          expr: this.expr
        };
      }
      static fromJSON(json) {
        return new FunctionAssignmentNode(json.name, json.params, json.expr);
      }
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var params = [];
        for (var i = 0; i < this.params.length; i++) {
          params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + "</span>");
        }
        var expr = this.expr.toHTML(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
      }
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var expr = this.expr.toTex(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = "\\left(".concat(expr, "\\right)");
        }
        return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
      }
    }
    _defineProperty(FunctionAssignmentNode, "name", name209);
    return FunctionAssignmentNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/IndexNode.js
  var name210 = "IndexNode";
  var dependencies211 = ["Node", "size"];
  var createIndexNode = /* @__PURE__ */ factory(name210, dependencies211, (_ref) => {
    var {
      Node,
      size
    } = _ref;
    class IndexNode extends Node {
      constructor(dimensions, dotNotation) {
        super();
        this.dimensions = dimensions;
        this.dotNotation = dotNotation || false;
        if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
        }
        if (this.dotNotation && !this.isObjectProperty()) {
          throw new Error("dotNotation only applicable for object properties");
        }
      }
      get type() {
        return name210;
      }
      get isIndexNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalDimensions = map(this.dimensions, function(dimension, i) {
          var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
          if (needsEnd) {
            var childArgNames = Object.create(argNames);
            childArgNames.end = true;
            var _evalDimension = dimension._compile(math2, childArgNames);
            return function evalDimension(scope, args, context) {
              if (!isMatrix(context) && !isArray(context) && !isString(context)) {
                throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context));
              }
              var s = size(context).valueOf();
              var childArgs = Object.create(args);
              childArgs.end = s[i];
              return _evalDimension(scope, childArgs, context);
            };
          } else {
            return dimension._compile(math2, argNames);
          }
        });
        var index = getSafeProperty(math2, "index");
        return function evalIndexNode(scope, args, context) {
          var dimensions = map(evalDimensions, function(evalDimension) {
            return evalDimension(scope, args, context);
          });
          return index(...dimensions);
        };
      }
      forEach(callback) {
        for (var i = 0; i < this.dimensions.length; i++) {
          callback(this.dimensions[i], "dimensions[" + i + "]", this);
        }
      }
      map(callback) {
        var dimensions = [];
        for (var i = 0; i < this.dimensions.length; i++) {
          dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
        }
        return new IndexNode(dimensions, this.dotNotation);
      }
      clone() {
        return new IndexNode(this.dimensions.slice(0), this.dotNotation);
      }
      isObjectProperty() {
        return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
      }
      getObjectProperty() {
        return this.isObjectProperty() ? this.dimensions[0].value : null;
      }
      _toString(options) {
        return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
      }
      toJSON() {
        return {
          mathjs: name210,
          dimensions: this.dimensions,
          dotNotation: this.dotNotation
        };
      }
      static fromJSON(json) {
        return new IndexNode(json.dimensions, json.dotNotation);
      }
      toHTML(options) {
        var dimensions = [];
        for (var i = 0; i < this.dimensions.length; i++) {
          dimensions[i] = this.dimensions[i].toHTML();
        }
        if (this.dotNotation) {
          return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
        } else {
          return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
        }
      }
      _toTex(options) {
        var dimensions = this.dimensions.map(function(range) {
          return range.toTex(options);
        });
        return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
      }
    }
    _defineProperty(IndexNode, "name", name210);
    return IndexNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
  var name211 = "ObjectNode";
  var dependencies212 = ["Node"];
  var createObjectNode = /* @__PURE__ */ factory(name211, dependencies212, (_ref) => {
    var {
      Node
    } = _ref;
    class ObjectNode extends Node {
      constructor(properties2) {
        super();
        this.properties = properties2 || {};
        if (properties2) {
          if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
            return isNode(properties2[key]);
          })) {
            throw new TypeError("Object containing Nodes expected");
          }
        }
      }
      get type() {
        return name211;
      }
      get isObjectNode() {
        return true;
      }
      _compile(math2, argNames) {
        var evalEntries = {};
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            var stringifiedKey = stringify(key);
            var parsedKey = JSON.parse(stringifiedKey);
            if (!isSafeProperty(this.properties, parsedKey)) {
              throw new Error('No access to property "' + parsedKey + '"');
            }
            evalEntries[parsedKey] = this.properties[key]._compile(math2, argNames);
          }
        }
        return function evalObjectNode(scope, args, context) {
          var obj = {};
          for (var _key in evalEntries) {
            if (hasOwnProperty2(evalEntries, _key)) {
              obj[_key] = evalEntries[_key](scope, args, context);
            }
          }
          return obj;
        };
      }
      forEach(callback) {
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            callback(this.properties[key], "properties[" + stringify(key) + "]", this);
          }
        }
      }
      map(callback) {
        var properties2 = {};
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
          }
        }
        return new ObjectNode(properties2);
      }
      clone() {
        var properties2 = {};
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            properties2[key] = this.properties[key];
          }
        }
        return new ObjectNode(properties2);
      }
      _toString(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            entries.push(stringify(key) + ": " + this.properties[key].toString(options));
          }
        }
        return "{" + entries.join(", ") + "}";
      }
      toJSON() {
        return {
          mathjs: name211,
          properties: this.properties
        };
      }
      static fromJSON(json) {
        return new ObjectNode(json.properties);
      }
      toHTML(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
          }
        }
        return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
      }
      _toTex(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
          }
        }
        var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
        return tex;
      }
    }
    _defineProperty(ObjectNode, "name", name211);
    return ObjectNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
  var name212 = "OperatorNode";
  var dependencies213 = ["Node"];
  var createOperatorNode = /* @__PURE__ */ factory(name212, dependencies213, (_ref) => {
    var {
      Node
    } = _ref;
    function startsWithConstant(expr, parenthesis) {
      var curNode = expr;
      if (parenthesis === "auto") {
        while (isParenthesisNode(curNode)) {
          curNode = curNode.content;
        }
      }
      if (isConstantNode(curNode))
        return true;
      if (isOperatorNode(curNode)) {
        return startsWithConstant(curNode.args[0], parenthesis);
      }
      return false;
    }
    function calculateNecessaryParentheses(root2, parenthesis, implicit, args, latex) {
      var precedence = getPrecedence(root2, parenthesis, implicit);
      var associativity = getAssociativity(root2, parenthesis);
      if (parenthesis === "all" || args.length > 2 && root2.getIdentifier() !== "OperatorNode:add" && root2.getIdentifier() !== "OperatorNode:multiply") {
        return args.map(function(arg) {
          switch (arg.getContent().type) {
            case "ArrayNode":
            case "ConstantNode":
            case "SymbolNode":
            case "ParenthesisNode":
              return false;
            default:
              return true;
          }
        });
      }
      var result;
      switch (args.length) {
        case 0:
          result = [];
          break;
        case 1:
          {
            var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root2);
            if (latex && operandPrecedence !== null) {
              var operandIdentifier;
              var rootIdentifier;
              if (parenthesis === "keep") {
                operandIdentifier = args[0].getIdentifier();
                rootIdentifier = root2.getIdentifier();
              } else {
                operandIdentifier = args[0].getContent().getIdentifier();
                rootIdentifier = root2.getContent().getIdentifier();
              }
              if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                result = [false];
                break;
              }
              if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                result = [false];
                break;
              }
            }
            if (operandPrecedence === null) {
              result = [false];
              break;
            }
            if (operandPrecedence <= precedence) {
              result = [true];
              break;
            }
            result = [false];
          }
          break;
        case 2:
          {
            var lhsParens;
            var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root2);
            var assocWithLhs = isAssociativeWith(root2, args[0], parenthesis);
            if (lhsPrecedence === null) {
              lhsParens = false;
            } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
              lhsParens = true;
            } else if (lhsPrecedence < precedence) {
              lhsParens = true;
            } else {
              lhsParens = false;
            }
            var rhsParens;
            var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root2);
            var assocWithRhs = isAssociativeWith(root2, args[1], parenthesis);
            if (rhsPrecedence === null) {
              rhsParens = false;
            } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
              rhsParens = true;
            } else if (rhsPrecedence < precedence) {
              rhsParens = true;
            } else {
              rhsParens = false;
            }
            if (latex) {
              var _rootIdentifier;
              var lhsIdentifier;
              var rhsIdentifier;
              if (parenthesis === "keep") {
                _rootIdentifier = root2.getIdentifier();
                lhsIdentifier = root2.args[0].getIdentifier();
                rhsIdentifier = root2.args[1].getIdentifier();
              } else {
                _rootIdentifier = root2.getContent().getIdentifier();
                lhsIdentifier = root2.args[0].getContent().getIdentifier();
                rhsIdentifier = root2.args[1].getContent().getIdentifier();
              }
              if (lhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                  lhsParens = false;
                }
                if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                  lhsParens = false;
                }
              }
              if (rhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                  rhsParens = false;
                }
                if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                  rhsParens = false;
                }
              }
            }
            result = [lhsParens, rhsParens];
          }
          break;
        default:
          if (root2.getIdentifier() === "OperatorNode:add" || root2.getIdentifier() === "OperatorNode:multiply") {
            result = args.map(function(arg) {
              var argPrecedence = getPrecedence(arg, parenthesis, implicit, root2);
              var assocWithArg = isAssociativeWith(root2, arg, parenthesis);
              var argAssociativity = getAssociativity(arg, parenthesis);
              if (argPrecedence === null) {
                return false;
              } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                return true;
              } else if (argPrecedence < precedence) {
                return true;
              }
              return false;
            });
          }
          break;
      }
      if (args.length >= 2 && root2.getIdentifier() === "OperatorNode:multiply" && root2.implicit && parenthesis !== "all" && implicit === "hide") {
        for (var i = 1; i < result.length; ++i) {
          if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i - 1]))) {
            result[i] = true;
          }
        }
      }
      return result;
    }
    class OperatorNode extends Node {
      constructor(op, fn, args, implicit, isPercentage) {
        super();
        if (typeof op !== "string") {
          throw new TypeError('string expected for parameter "op"');
        }
        if (typeof fn !== "string") {
          throw new TypeError('string expected for parameter "fn"');
        }
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "args"');
        }
        this.implicit = implicit === true;
        this.isPercentage = isPercentage === true;
        this.op = op;
        this.fn = fn;
        this.args = args || [];
      }
      get type() {
        return name212;
      }
      get isOperatorNode() {
        return true;
      }
      _compile(math2, argNames) {
        if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
          if (!math2[this.fn]) {
            throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
          } else {
            throw new Error('No access to function "' + this.fn + '"');
          }
        }
        var fn = getSafeProperty(math2, this.fn);
        var evalArgs = map(this.args, function(arg) {
          return arg._compile(math2, argNames);
        });
        if (evalArgs.length === 1) {
          var evalArg0 = evalArgs[0];
          return function evalOperatorNode(scope, args, context) {
            return fn(evalArg0(scope, args, context));
          };
        } else if (evalArgs.length === 2) {
          var _evalArg = evalArgs[0];
          var evalArg1 = evalArgs[1];
          return function evalOperatorNode(scope, args, context) {
            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
          };
        } else {
          return function evalOperatorNode(scope, args, context) {
            return fn.apply(null, map(evalArgs, function(evalArg) {
              return evalArg(scope, args, context);
            }));
          };
        }
      }
      forEach(callback) {
        for (var i = 0; i < this.args.length; i++) {
          callback(this.args[i], "args[" + i + "]", this);
        }
      }
      map(callback) {
        var args = [];
        for (var i = 0; i < this.args.length; i++) {
          args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
        }
        return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);
      }
      clone() {
        return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
      }
      isUnary() {
        return this.args.length === 1;
      }
      isBinary() {
        return this.args.length === 2;
      }
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toString(options);
          if (parens[0]) {
            operand = "(" + operand + ")";
          }
          var opIsNamed = /[a-zA-Z]+/.test(this.op);
          if (assoc === "right") {
            return this.op + (opIsNamed ? " " : "") + operand;
          } else if (assoc === "left") {
            return operand + (opIsNamed ? " " : "") + this.op;
          }
          return operand + this.op;
        } else if (args.length === 2) {
          var lhs = args[0].toString(options);
          var rhs = args[1].toString(options);
          if (parens[0]) {
            lhs = "(" + lhs + ")";
          }
          if (parens[1]) {
            rhs = "(" + rhs + ")";
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + " " + rhs;
          }
          return lhs + " " + this.op + " " + rhs;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          var stringifiedArgs = args.map(function(arg, index) {
            arg = arg.toString(options);
            if (parens[index]) {
              arg = "(" + arg + ")";
            }
            return arg;
          });
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join(" ");
          }
          return stringifiedArgs.join(" " + this.op + " ");
        } else {
          return this.fn + "(" + this.args.join(", ") + ")";
        }
      }
      toJSON() {
        return {
          mathjs: name212,
          op: this.op,
          fn: this.fn,
          args: this.args,
          implicit: this.implicit,
          isPercentage: this.isPercentage
        };
      }
      static fromJSON(json) {
        return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);
      }
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toHTML(options);
          if (parens[0]) {
            operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (assoc === "right") {
            return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
          } else {
            return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
          }
        } else if (args.length === 2) {
          var lhs = args[0].toHTML(options);
          var rhs = args[1].toHTML(options);
          if (parens[0]) {
            lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (parens[1]) {
            rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
          }
          return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
        } else {
          var stringifiedArgs = args.map(function(arg, index) {
            arg = arg.toHTML(options);
            if (parens[index]) {
              arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return arg;
          });
          if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
            if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
              return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
            }
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
          } else {
            return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
        }
      }
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
        var op = latexOperators[this.fn];
        op = typeof op === "undefined" ? this.op : op;
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toTex(options);
          if (parens[0]) {
            operand = "\\left(".concat(operand, "\\right)");
          }
          if (assoc === "right") {
            return op + operand;
          } else if (assoc === "left") {
            return operand + op;
          }
          return operand + op;
        } else if (args.length === 2) {
          var lhs = args[0];
          var lhsTex = lhs.toTex(options);
          if (parens[0]) {
            lhsTex = "\\left(".concat(lhsTex, "\\right)");
          }
          var rhs = args[1];
          var rhsTex = rhs.toTex(options);
          if (parens[1]) {
            rhsTex = "\\left(".concat(rhsTex, "\\right)");
          }
          var lhsIdentifier;
          if (parenthesis === "keep") {
            lhsIdentifier = lhs.getIdentifier();
          } else {
            lhsIdentifier = lhs.getContent().getIdentifier();
          }
          switch (this.getIdentifier()) {
            case "OperatorNode:divide":
              return op + "{" + lhsTex + "}{" + rhsTex + "}";
            case "OperatorNode:pow":
              lhsTex = "{" + lhsTex + "}";
              rhsTex = "{" + rhsTex + "}";
              switch (lhsIdentifier) {
                case "ConditionalNode":
                case "OperatorNode:divide":
                  lhsTex = "\\left(".concat(lhsTex, "\\right)");
              }
              break;
            case "OperatorNode:multiply":
              if (this.implicit && implicit === "hide") {
                return lhsTex + "~" + rhsTex;
              }
          }
          return lhsTex + op + rhsTex;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          var texifiedArgs = args.map(function(arg, index) {
            arg = arg.toTex(options);
            if (parens[index]) {
              arg = "\\left(".concat(arg, "\\right)");
            }
            return arg;
          });
          if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
            return texifiedArgs.join("~");
          }
          return texifiedArgs.join(op);
        } else {
          return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
            return arg.toTex(options);
          }).join(",") + "\\right)";
        }
      }
      getIdentifier() {
        return this.type + ":" + this.fn;
      }
    }
    _defineProperty(OperatorNode, "name", name212);
    return OperatorNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
  var name213 = "ParenthesisNode";
  var dependencies214 = ["Node"];
  var createParenthesisNode = /* @__PURE__ */ factory(name213, dependencies214, (_ref) => {
    var {
      Node
    } = _ref;
    class ParenthesisNode extends Node {
      constructor(content) {
        super();
        if (!isNode(content)) {
          throw new TypeError('Node expected for parameter "content"');
        }
        this.content = content;
      }
      get type() {
        return name213;
      }
      get isParenthesisNode() {
        return true;
      }
      _compile(math2, argNames) {
        return this.content._compile(math2, argNames);
      }
      getContent() {
        return this.content.getContent();
      }
      forEach(callback) {
        callback(this.content, "content", this);
      }
      map(callback) {
        var content = callback(this.content, "content", this);
        return new ParenthesisNode(content);
      }
      clone() {
        return new ParenthesisNode(this.content);
      }
      _toString(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "(" + this.content.toString(options) + ")";
        }
        return this.content.toString(options);
      }
      toJSON() {
        return {
          mathjs: name213,
          content: this.content
        };
      }
      static fromJSON(json) {
        return new ParenthesisNode(json.content);
      }
      toHTML(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return this.content.toHTML(options);
      }
      _toTex(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "\\left(".concat(this.content.toTex(options), "\\right)");
        }
        return this.content.toTex(options);
      }
    }
    _defineProperty(ParenthesisNode, "name", name213);
    return ParenthesisNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/RangeNode.js
  var name214 = "RangeNode";
  var dependencies215 = ["Node"];
  var createRangeNode = /* @__PURE__ */ factory(name214, dependencies215, (_ref) => {
    var {
      Node
    } = _ref;
    function calculateNecessaryParentheses(node, parenthesis, implicit) {
      var precedence = getPrecedence(node, parenthesis, implicit);
      var parens = {};
      var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
      parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
      if (node.step) {
        var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
        parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
      }
      var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
      parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
      return parens;
    }
    class RangeNode extends Node {
      constructor(start, end, step) {
        super();
        if (!isNode(start))
          throw new TypeError("Node expected");
        if (!isNode(end))
          throw new TypeError("Node expected");
        if (step && !isNode(step))
          throw new TypeError("Node expected");
        if (arguments.length > 3)
          throw new Error("Too many arguments");
        this.start = start;
        this.end = end;
        this.step = step || null;
      }
      get type() {
        return name214;
      }
      get isRangeNode() {
        return true;
      }
      needsEnd() {
        var endSymbols = this.filter(function(node) {
          return isSymbolNode(node) && node.name === "end";
        });
        return endSymbols.length > 0;
      }
      _compile(math2, argNames) {
        var range = math2.range;
        var evalStart = this.start._compile(math2, argNames);
        var evalEnd = this.end._compile(math2, argNames);
        if (this.step) {
          var evalStep = this.step._compile(math2, argNames);
          return function evalRangeNode(scope, args, context) {
            return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
          };
        } else {
          return function evalRangeNode(scope, args, context) {
            return range(evalStart(scope, args, context), evalEnd(scope, args, context));
          };
        }
      }
      forEach(callback) {
        callback(this.start, "start", this);
        callback(this.end, "end", this);
        if (this.step) {
          callback(this.step, "step", this);
        }
      }
      map(callback) {
        return new RangeNode(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
      }
      clone() {
        return new RangeNode(this.start, this.end, this.step && this.step);
      }
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
        var str;
        var start = this.start.toString(options);
        if (parens.start) {
          start = "(" + start + ")";
        }
        str = start;
        if (this.step) {
          var step = this.step.toString(options);
          if (parens.step) {
            step = "(" + step + ")";
          }
          str += ":" + step;
        }
        var end = this.end.toString(options);
        if (parens.end) {
          end = "(" + end + ")";
        }
        str += ":" + end;
        return str;
      }
      toJSON() {
        return {
          mathjs: name214,
          start: this.start,
          end: this.end,
          step: this.step
        };
      }
      static fromJSON(json) {
        return new RangeNode(json.start, json.end, json.step);
      }
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
        var str;
        var start = this.start.toHTML(options);
        if (parens.start) {
          start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str = start;
        if (this.step) {
          var step = this.step.toHTML(options);
          if (parens.step) {
            step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          str += '<span class="math-operator math-range-operator">:</span>' + step;
        }
        var end = this.end.toHTML(options);
        if (parens.end) {
          end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + end;
        return str;
      }
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
        var str = this.start.toTex(options);
        if (parens.start) {
          str = "\\left(".concat(str, "\\right)");
        }
        if (this.step) {
          var step = this.step.toTex(options);
          if (parens.step) {
            step = "\\left(".concat(step, "\\right)");
          }
          str += ":" + step;
        }
        var end = this.end.toTex(options);
        if (parens.end) {
          end = "\\left(".concat(end, "\\right)");
        }
        str += ":" + end;
        return str;
      }
    }
    _defineProperty(RangeNode, "name", name214);
    return RangeNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
  var name215 = "RelationalNode";
  var dependencies216 = ["Node"];
  var createRelationalNode = /* @__PURE__ */ factory(name215, dependencies216, (_ref) => {
    var {
      Node
    } = _ref;
    var operatorMap = {
      equal: "==",
      unequal: "!=",
      smaller: "<",
      larger: ">",
      smallerEq: "<=",
      largerEq: ">="
    };
    class RelationalNode extends Node {
      constructor(conditionals, params) {
        super();
        if (!Array.isArray(conditionals)) {
          throw new TypeError("Parameter conditionals must be an array");
        }
        if (!Array.isArray(params)) {
          throw new TypeError("Parameter params must be an array");
        }
        if (conditionals.length !== params.length - 1) {
          throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
        }
        this.conditionals = conditionals;
        this.params = params;
      }
      get type() {
        return name215;
      }
      get isRelationalNode() {
        return true;
      }
      _compile(math2, argNames) {
        var self2 = this;
        var compiled = this.params.map((p) => p._compile(math2, argNames));
        return function evalRelationalNode(scope, args, context) {
          var evalLhs;
          var evalRhs = compiled[0](scope, args, context);
          for (var i = 0; i < self2.conditionals.length; i++) {
            evalLhs = evalRhs;
            evalRhs = compiled[i + 1](scope, args, context);
            var condFn = getSafeProperty(math2, self2.conditionals[i]);
            if (!condFn(evalLhs, evalRhs)) {
              return false;
            }
          }
          return true;
        };
      }
      forEach(callback) {
        this.params.forEach((n, i) => callback(n, "params[" + i + "]", this), this);
      }
      map(callback) {
        return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, "params[" + i + "]", this)), this));
      }
      clone() {
        return new RelationalNode(this.conditionals, this.params);
      }
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var paramStrings = this.params.map(function(p, index) {
          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
        });
        var ret = paramStrings[0];
        for (var i = 0; i < this.conditionals.length; i++) {
          ret += " " + operatorMap[this.conditionals[i]];
          ret += " " + paramStrings[i + 1];
        }
        return ret;
      }
      toJSON() {
        return {
          mathjs: name215,
          conditionals: this.conditionals,
          params: this.params
        };
      }
      static fromJSON(json) {
        return new RelationalNode(json.conditionals, json.params);
      }
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var paramStrings = this.params.map(function(p, index) {
          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
        });
        var ret = paramStrings[0];
        for (var i = 0; i < this.conditionals.length; i++) {
          ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
        }
        return ret;
      }
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var paramStrings = this.params.map(function(p, index) {
          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
        });
        var ret = paramStrings[0];
        for (var i = 0; i < this.conditionals.length; i++) {
          ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];
        }
        return ret;
      }
    }
    _defineProperty(RelationalNode, "name", name215);
    return RelationalNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
  var name216 = "SymbolNode";
  var dependencies217 = ["math", "?Unit", "Node"];
  var createSymbolNode = /* @__PURE__ */ factory(name216, dependencies217, (_ref) => {
    var {
      math: math2,
      Unit,
      Node
    } = _ref;
    function isValuelessUnit(name297) {
      return Unit ? Unit.isValuelessUnit(name297) : false;
    }
    class SymbolNode extends Node {
      constructor(name297) {
        super();
        if (typeof name297 !== "string") {
          throw new TypeError('String expected for parameter "name"');
        }
        this.name = name297;
      }
      get type() {
        return "SymbolNode";
      }
      get isSymbolNode() {
        return true;
      }
      _compile(math3, argNames) {
        var name297 = this.name;
        if (argNames[name297] === true) {
          return function(scope, args, context) {
            return args[name297];
          };
        } else if (name297 in math3) {
          return function(scope, args, context) {
            return scope.has(name297) ? scope.get(name297) : getSafeProperty(math3, name297);
          };
        } else {
          var isUnit2 = isValuelessUnit(name297);
          return function(scope, args, context) {
            return scope.has(name297) ? scope.get(name297) : isUnit2 ? new Unit(null, name297) : SymbolNode.onUndefinedSymbol(name297);
          };
        }
      }
      forEach(callback) {
      }
      map(callback) {
        return this.clone();
      }
      static onUndefinedSymbol(name297) {
        throw new Error("Undefined symbol " + name297);
      }
      clone() {
        return new SymbolNode(this.name);
      }
      _toString(options) {
        return this.name;
      }
      toHTML(options) {
        var name297 = escape(this.name);
        if (name297 === "true" || name297 === "false") {
          return '<span class="math-symbol math-boolean">' + name297 + "</span>";
        } else if (name297 === "i") {
          return '<span class="math-symbol math-imaginary-symbol">' + name297 + "</span>";
        } else if (name297 === "Infinity") {
          return '<span class="math-symbol math-infinity-symbol">' + name297 + "</span>";
        } else if (name297 === "NaN") {
          return '<span class="math-symbol math-nan-symbol">' + name297 + "</span>";
        } else if (name297 === "null") {
          return '<span class="math-symbol math-null-symbol">' + name297 + "</span>";
        } else if (name297 === "undefined") {
          return '<span class="math-symbol math-undefined-symbol">' + name297 + "</span>";
        }
        return '<span class="math-symbol">' + name297 + "</span>";
      }
      toJSON() {
        return {
          mathjs: "SymbolNode",
          name: this.name
        };
      }
      static fromJSON(json) {
        return new SymbolNode(json.name);
      }
      _toTex(options) {
        var isUnit2 = false;
        if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
          isUnit2 = true;
        }
        var symbol = toSymbol(this.name, isUnit2);
        if (symbol[0] === "\\") {
          return symbol;
        }
        return " " + symbol;
      }
    }
    return SymbolNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/utils/scope.js
  function createSubScope(parentScope) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (typeof parentScope.createSubScope === "function") {
      return assign(parentScope.createSubScope(), ...args);
    }
    return assign(createEmptyMap(), parentScope, ...args);
  }

  // node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
  var name217 = "FunctionNode";
  var dependencies218 = ["math", "Node", "SymbolNode"];
  var createFunctionNode = /* @__PURE__ */ factory(name217, dependencies218, (_ref) => {
    var {
      math: math2,
      Node,
      SymbolNode
    } = _ref;
    var strin = (entity) => format3(entity, {
      truncate: 78
    });
    function expandTemplate(template, node, options) {
      var latex = "";
      var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
      var inputPos = 0;
      var match;
      while ((match = regex.exec(template)) !== null) {
        latex += template.substring(inputPos, match.index);
        inputPos = match.index;
        if (match[0] === "$$") {
          latex += "$";
          inputPos++;
        } else {
          inputPos += match[0].length;
          var property = node[match[1]];
          if (!property) {
            throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
          }
          if (match[2] === void 0) {
            switch (typeof property) {
              case "string":
                latex += property;
                break;
              case "object":
                if (isNode(property)) {
                  latex += property.toTex(options);
                } else if (Array.isArray(property)) {
                  latex += property.map(function(arg, index) {
                    if (isNode(arg)) {
                      return arg.toTex(options);
                    }
                    throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                  }).join(",");
                } else {
                  throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                }
                break;
              default:
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
            }
          } else {
            if (isNode(property[match[2]] && property[match[2]])) {
              latex += property[match[2]].toTex(options);
            } else {
              throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
            }
          }
        }
      }
      latex += template.slice(inputPos);
      return latex;
    }
    class FunctionNode extends Node {
      constructor(fn, args) {
        super();
        if (typeof fn === "string") {
          fn = new SymbolNode(fn);
        }
        if (!isNode(fn))
          throw new TypeError('Node expected as parameter "fn"');
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "args"');
        }
        this.fn = fn;
        this.args = args || [];
      }
      get name() {
        return this.fn.name || "";
      }
      get type() {
        return name217;
      }
      get isFunctionNode() {
        return true;
      }
      _compile(math3, argNames) {
        var evalArgs = this.args.map((arg) => arg._compile(math3, argNames));
        if (isSymbolNode(this.fn)) {
          var _name = this.fn.name;
          if (!argNames[_name]) {
            var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
            var isRaw = typeof fn === "function" && fn.rawArgs === true;
            var resolveFn = (scope) => {
              var value;
              if (scope.has(_name)) {
                value = scope.get(_name);
              } else if (_name in math3) {
                value = getSafeProperty(math3, _name);
              } else {
                return FunctionNode.onUndefinedFunction(_name);
              }
              if (typeof value === "function") {
                return value;
              }
              throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
            };
            if (isRaw) {
              var rawArgs = this.args;
              return function evalFunctionNode(scope, args, context) {
                var fn2 = resolveFn(scope);
                return fn2(rawArgs, math3, createSubScope(scope, args), scope);
              };
            } else {
              switch (evalArgs.length) {
                case 0:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    return fn2();
                  };
                case 1:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var evalArg0 = evalArgs[0];
                    return fn2(evalArg0(scope, args, context));
                  };
                case 2:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var evalArg0 = evalArgs[0];
                    var evalArg1 = evalArgs[1];
                    return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                  };
                default:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
                    return fn2(...values2);
                  };
              }
            }
          } else {
            var _rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = args[_name];
              if (typeof fn2 !== "function") {
                throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
              }
              if (fn2.rawArgs) {
                return fn2(_rawArgs, math3, createSubScope(scope, args), scope);
              } else {
                var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
                return fn2.apply(fn2, values2);
              }
            };
          }
        } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
          var evalObject = this.fn.object._compile(math3, argNames);
          var prop = this.fn.index.getObjectProperty();
          var _rawArgs2 = this.args;
          return function evalFunctionNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            validateSafeMethod(object, prop);
            var isRaw2 = object[prop] && object[prop].rawArgs;
            if (isRaw2) {
              return object[prop](_rawArgs2, math3, createSubScope(scope, args), scope);
            } else {
              var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return object[prop].apply(object, values2);
            }
          };
        } else {
          var fnExpr = this.fn.toString();
          var evalFn = this.fn._compile(math3, argNames);
          var _rawArgs3 = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = evalFn(scope, args, context);
            if (typeof fn2 !== "function") {
              throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs3, math3, createSubScope(scope, args), scope);
            } else {
              var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values2);
            }
          };
        }
      }
      forEach(callback) {
        callback(this.fn, "fn", this);
        for (var i = 0; i < this.args.length; i++) {
          callback(this.args[i], "args[" + i + "]", this);
        }
      }
      map(callback) {
        var fn = this._ifNode(callback(this.fn, "fn", this));
        var args = [];
        for (var i = 0; i < this.args.length; i++) {
          args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
        }
        return new FunctionNode(fn, args);
      }
      clone() {
        return new FunctionNode(this.fn, this.args.slice(0));
      }
      toString(options) {
        var customString;
        var name297 = this.fn.toString(options);
        if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, name297)) {
          customString = options.handler[name297](this, options);
        }
        if (typeof customString !== "undefined") {
          return customString;
        }
        return super.toString(options);
      }
      _toString(options) {
        var args = this.args.map(function(arg) {
          return arg.toString(options);
        });
        var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
        return fn + "(" + args.join(", ") + ")";
      }
      toJSON() {
        return {
          mathjs: name217,
          fn: this.fn,
          args: this.args
        };
      }
      toHTML(options) {
        var args = this.args.map(function(arg) {
          return arg.toHTML(options);
        });
        return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      toTex(options) {
        var customTex;
        if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, this.name)) {
          customTex = options.handler[this.name](this, options);
        }
        if (typeof customTex !== "undefined") {
          return customTex;
        }
        return super.toTex(options);
      }
      _toTex(options) {
        var args = this.args.map(function(arg) {
          return arg.toTex(options);
        });
        var latexConverter;
        if (latexFunctions[this.name]) {
          latexConverter = latexFunctions[this.name];
        }
        if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
          latexConverter = math2[this.name].toTex;
        }
        var customToTex;
        switch (typeof latexConverter) {
          case "function":
            customToTex = latexConverter(this, options);
            break;
          case "string":
            customToTex = expandTemplate(latexConverter, this, options);
            break;
          case "object":
            switch (typeof latexConverter[args.length]) {
              case "function":
                customToTex = latexConverter[args.length](this, options);
                break;
              case "string":
                customToTex = expandTemplate(latexConverter[args.length], this, options);
                break;
            }
        }
        if (typeof customToTex !== "undefined") {
          return customToTex;
        }
        return expandTemplate(defaultTemplate, this, options);
      }
      getIdentifier() {
        return this.type + ":" + this.name;
      }
    }
    _defineProperty(FunctionNode, "name", name217);
    _defineProperty(FunctionNode, "onUndefinedFunction", function(name297) {
      throw new Error("Undefined function " + name297);
    });
    _defineProperty(FunctionNode, "fromJSON", function(json) {
      return new FunctionNode(json.fn, json.args);
    });
    return FunctionNode;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/parse.js
  var name218 = "parse";
  var dependencies219 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
  var createParse = /* @__PURE__ */ factory(name218, dependencies219, (_ref) => {
    var {
      typed,
      numeric: numeric2,
      config: config2,
      AccessorNode,
      ArrayNode,
      AssignmentNode,
      BlockNode,
      ConditionalNode,
      ConstantNode,
      FunctionAssignmentNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      RangeNode,
      RelationalNode,
      SymbolNode
    } = _ref;
    var parse = typed(name218, {
      string: function string(expression) {
        return parseStart(expression, {});
      },
      "Array | Matrix": function ArrayMatrix(expressions) {
        return parseMultiple(expressions, {});
      },
      "string, Object": function stringObject(expression, options) {
        var extraNodes = options.nodes !== void 0 ? options.nodes : {};
        return parseStart(expression, extraNodes);
      },
      "Array | Matrix, Object": parseMultiple
    });
    function parseMultiple(expressions) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return deepMap(expressions, function(elem) {
        if (typeof elem !== "string")
          throw new TypeError("String expected");
        return parseStart(elem, extraNodes);
      });
    }
    var TOKENTYPE = {
      NULL: 0,
      DELIMITER: 1,
      NUMBER: 2,
      SYMBOL: 3,
      UNKNOWN: 4
    };
    var DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      "{": true,
      "}": true,
      '"': true,
      "'": true,
      ";": true,
      "+": true,
      "-": true,
      "*": true,
      ".*": true,
      "/": true,
      "./": true,
      "%": true,
      "^": true,
      ".^": true,
      "~": true,
      "!": true,
      "&": true,
      "|": true,
      "^|": true,
      "=": true,
      ":": true,
      "?": true,
      "==": true,
      "!=": true,
      "<": true,
      ">": true,
      "<=": true,
      ">=": true,
      "<<": true,
      ">>": true,
      ">>>": true
    };
    var NAMED_DELIMITERS = {
      mod: true,
      to: true,
      in: true,
      and: true,
      xor: true,
      or: true,
      not: true
    };
    var CONSTANTS = {
      true: true,
      false: false,
      null: null,
      undefined: void 0
    };
    var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
    function initialState() {
      return {
        extraNodes: {},
        expression: "",
        comment: "",
        index: 0,
        token: "",
        tokenType: TOKENTYPE.NULL,
        nestingLevel: 0,
        conditionalLevel: null
      };
    }
    function currentString(state, length) {
      return state.expression.substr(state.index, length);
    }
    function currentCharacter(state) {
      return currentString(state, 1);
    }
    function next(state) {
      state.index++;
    }
    function prevCharacter(state) {
      return state.expression.charAt(state.index - 1);
    }
    function nextCharacter(state) {
      return state.expression.charAt(state.index + 1);
    }
    function getToken(state) {
      state.tokenType = TOKENTYPE.NULL;
      state.token = "";
      state.comment = "";
      while (true) {
        if (currentCharacter(state) === "#") {
          while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
            state.comment += currentCharacter(state);
            next(state);
          }
        }
        if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
          next(state);
        } else {
          break;
        }
      }
      if (currentCharacter(state) === "") {
        state.tokenType = TOKENTYPE.DELIMITER;
        return;
      }
      if (currentCharacter(state) === "\n" && !state.nestingLevel) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = currentCharacter(state);
        next(state);
        return;
      }
      var c1 = currentCharacter(state);
      var c2 = currentString(state, 2);
      var c3 = currentString(state, 3);
      if (c3.length === 3 && DELIMITERS[c3]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c3;
        next(state);
        next(state);
        next(state);
        return;
      }
      if (c2.length === 2 && DELIMITERS[c2]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c2;
        next(state);
        next(state);
        return;
      }
      if (DELIMITERS[c1]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c1;
        next(state);
        return;
      }
      if (parse.isDigitDot(c1)) {
        state.tokenType = TOKENTYPE.NUMBER;
        var _c = currentString(state, 2);
        if (_c === "0b" || _c === "0o" || _c === "0x") {
          state.token += currentCharacter(state);
          next(state);
          state.token += currentCharacter(state);
          next(state);
          while (parse.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (currentCharacter(state) === ".") {
            state.token += ".";
            next(state);
            while (parse.isHexDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          } else if (currentCharacter(state) === "i") {
            state.token += "i";
            next(state);
            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          }
          return;
        }
        if (currentCharacter(state) === ".") {
          state.token += currentCharacter(state);
          next(state);
          if (!parse.isDigit(currentCharacter(state))) {
            state.tokenType = TOKENTYPE.DELIMITER;
            return;
          }
        } else {
          while (parse.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        while (parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
          if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
            state.token += currentCharacter(state);
            next(state);
            if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
              state.token += currentCharacter(state);
              next(state);
            }
            if (!parse.isDigit(currentCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
            while (parse.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
          } else if (nextCharacter(state) === ".") {
            next(state);
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        }
        return;
      }
      if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
        while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (hasOwnProperty2(NAMED_DELIMITERS, state.token)) {
          state.tokenType = TOKENTYPE.DELIMITER;
        } else {
          state.tokenType = TOKENTYPE.SYMBOL;
        }
        return;
      }
      state.tokenType = TOKENTYPE.UNKNOWN;
      while (currentCharacter(state) !== "") {
        state.token += currentCharacter(state);
        next(state);
      }
      throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
    }
    function getTokenSkipNewline(state) {
      do {
        getToken(state);
      } while (state.token === "\n");
    }
    function openParams(state) {
      state.nestingLevel++;
    }
    function closeParams(state) {
      state.nestingLevel--;
    }
    parse.isAlpha = function isAlpha(c, cPrev, cNext) {
      return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
    };
    parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
      return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
    };
    parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
      return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
    };
    parse.isWhitespace = function isWhitespace(c, nestingLevel) {
      return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
    };
    parse.isDecimalMark = function isDecimalMark(c, cNext) {
      return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
    };
    parse.isDigitDot = function isDigitDot(c) {
      return c >= "0" && c <= "9" || c === ".";
    };
    parse.isDigit = function isDigit(c) {
      return c >= "0" && c <= "9";
    };
    parse.isHexDigit = function isHexDigit(c) {
      return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
    };
    function parseStart(expression, extraNodes) {
      var state = initialState();
      _extends(state, {
        expression,
        extraNodes
      });
      getToken(state);
      var node = parseBlock(state);
      if (state.token !== "") {
        if (state.tokenType === TOKENTYPE.DELIMITER) {
          throw createError(state, "Unexpected operator " + state.token);
        } else {
          throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
        }
      }
      return node;
    }
    function parseBlock(state) {
      var node;
      var blocks = [];
      var visible;
      if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      while (state.token === "\n" || state.token === ";") {
        if (blocks.length === 0 && node) {
          visible = state.token !== ";";
          blocks.push({
            node,
            visible
          });
        }
        getToken(state);
        if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
          node = parseAssignment(state);
          if (state.comment) {
            node.comment = state.comment;
          }
          visible = state.token !== ";";
          blocks.push({
            node,
            visible
          });
        }
      }
      if (blocks.length > 0) {
        return new BlockNode(blocks);
      } else {
        if (!node) {
          node = new ConstantNode(void 0);
          if (state.comment) {
            node.comment = state.comment;
          }
        }
        return node;
      }
    }
    function parseAssignment(state) {
      var name297, args, value, valid;
      var node = parseConditional(state);
      if (state.token === "=") {
        if (isSymbolNode(node)) {
          name297 = node.name;
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(new SymbolNode(name297), value);
        } else if (isAccessorNode(node)) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode(node.object, node.index, value);
        } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
          valid = true;
          args = [];
          name297 = node.name;
          node.args.forEach(function(arg, index) {
            if (isSymbolNode(arg)) {
              args[index] = arg.name;
            } else {
              valid = false;
            }
          });
          if (valid) {
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new FunctionAssignmentNode(name297, args, value);
          }
        }
        throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
      }
      return node;
    }
    function parseConditional(state) {
      var node = parseLogicalOr(state);
      while (state.token === "?") {
        var prev = state.conditionalLevel;
        state.conditionalLevel = state.nestingLevel;
        getTokenSkipNewline(state);
        var condition = node;
        var trueExpr = parseAssignment(state);
        if (state.token !== ":")
          throw createSyntaxError(state, "False part of conditional expression expected");
        state.conditionalLevel = null;
        getTokenSkipNewline(state);
        var falseExpr = parseAssignment(state);
        node = new ConditionalNode(condition, trueExpr, falseExpr);
        state.conditionalLevel = prev;
      }
      return node;
    }
    function parseLogicalOr(state) {
      var node = parseLogicalXor(state);
      while (state.token === "or") {
        getTokenSkipNewline(state);
        node = new OperatorNode("or", "or", [node, parseLogicalXor(state)]);
      }
      return node;
    }
    function parseLogicalXor(state) {
      var node = parseLogicalAnd(state);
      while (state.token === "xor") {
        getTokenSkipNewline(state);
        node = new OperatorNode("xor", "xor", [node, parseLogicalAnd(state)]);
      }
      return node;
    }
    function parseLogicalAnd(state) {
      var node = parseBitwiseOr(state);
      while (state.token === "and") {
        getTokenSkipNewline(state);
        node = new OperatorNode("and", "and", [node, parseBitwiseOr(state)]);
      }
      return node;
    }
    function parseBitwiseOr(state) {
      var node = parseBitwiseXor(state);
      while (state.token === "|") {
        getTokenSkipNewline(state);
        node = new OperatorNode("|", "bitOr", [node, parseBitwiseXor(state)]);
      }
      return node;
    }
    function parseBitwiseXor(state) {
      var node = parseBitwiseAnd(state);
      while (state.token === "^|") {
        getTokenSkipNewline(state);
        node = new OperatorNode("^|", "bitXor", [node, parseBitwiseAnd(state)]);
      }
      return node;
    }
    function parseBitwiseAnd(state) {
      var node = parseRelational(state);
      while (state.token === "&") {
        getTokenSkipNewline(state);
        node = new OperatorNode("&", "bitAnd", [node, parseRelational(state)]);
      }
      return node;
    }
    function parseRelational(state) {
      var params = [parseShift(state)];
      var conditionals = [];
      var operators = {
        "==": "equal",
        "!=": "unequal",
        "<": "smaller",
        ">": "larger",
        "<=": "smallerEq",
        ">=": "largerEq"
      };
      while (hasOwnProperty2(operators, state.token)) {
        var cond = {
          name: state.token,
          fn: operators[state.token]
        };
        conditionals.push(cond);
        getTokenSkipNewline(state);
        params.push(parseShift(state));
      }
      if (params.length === 1) {
        return params[0];
      } else if (params.length === 2) {
        return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
      } else {
        return new RelationalNode(conditionals.map((c) => c.fn), params);
      }
    }
    function parseShift(state) {
      var node, name297, fn, params;
      node = parseConversion(state);
      var operators = {
        "<<": "leftShift",
        ">>": "rightArithShift",
        ">>>": "rightLogShift"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name297 = state.token;
        fn = operators[name297];
        getTokenSkipNewline(state);
        params = [node, parseConversion(state)];
        node = new OperatorNode(name297, fn, params);
      }
      return node;
    }
    function parseConversion(state) {
      var node, name297, fn, params;
      node = parseRange(state);
      var operators = {
        to: "to",
        in: "to"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name297 = state.token;
        fn = operators[name297];
        getTokenSkipNewline(state);
        if (name297 === "in" && state.token === "") {
          node = new OperatorNode("*", "multiply", [node, new SymbolNode("in")], true);
        } else {
          params = [node, parseRange(state)];
          node = new OperatorNode(name297, fn, params);
        }
      }
      return node;
    }
    function parseRange(state) {
      var node;
      var params = [];
      if (state.token === ":") {
        node = new ConstantNode(1);
      } else {
        node = parseAddSubtract(state);
      }
      if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
        params.push(node);
        while (state.token === ":" && params.length < 3) {
          getTokenSkipNewline(state);
          if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
            params.push(new SymbolNode("end"));
          } else {
            params.push(parseAddSubtract(state));
          }
        }
        if (params.length === 3) {
          node = new RangeNode(params[0], params[2], params[1]);
        } else {
          node = new RangeNode(params[0], params[1]);
        }
      }
      return node;
    }
    function parseAddSubtract(state) {
      var node, name297, fn, params;
      node = parseMultiplyDivide(state);
      var operators = {
        "+": "add",
        "-": "subtract"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name297 = state.token;
        fn = operators[name297];
        getTokenSkipNewline(state);
        var rightNode = parseMultiplyDivide(state);
        if (rightNode.isPercentage) {
          params = [node, new OperatorNode("*", "multiply", [node, rightNode])];
        } else {
          params = [node, rightNode];
        }
        node = new OperatorNode(name297, fn, params);
      }
      return node;
    }
    function parseMultiplyDivide(state) {
      var node, last, name297, fn;
      node = parseImplicitMultiplication(state);
      last = node;
      var operators = {
        "*": "multiply",
        ".*": "dotMultiply",
        "/": "divide",
        "./": "dotDivide"
      };
      while (true) {
        if (hasOwnProperty2(operators, state.token)) {
          name297 = state.token;
          fn = operators[name297];
          getTokenSkipNewline(state);
          last = parseImplicitMultiplication(state);
          node = new OperatorNode(name297, fn, [node, last]);
        } else {
          break;
        }
      }
      return node;
    }
    function parseImplicitMultiplication(state) {
      var node, last;
      node = parseRule2(state);
      last = node;
      while (true) {
        if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
          last = parseRule2(state);
          node = new OperatorNode("*", "multiply", [node, last], true);
        } else {
          break;
        }
      }
      return node;
    }
    function parseRule2(state) {
      var node = parsePercentage(state);
      var last = node;
      var tokenStates = [];
      while (true) {
        if (state.token === "/" && rule2Node(last)) {
          tokenStates.push(_extends({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.NUMBER) {
            tokenStates.push(_extends({}, state));
            getTokenSkipNewline(state);
            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
              _extends(state, tokenStates.pop());
              tokenStates.pop();
              last = parsePercentage(state);
              node = new OperatorNode("/", "divide", [node, last]);
            } else {
              tokenStates.pop();
              _extends(state, tokenStates.pop());
              break;
            }
          } else {
            _extends(state, tokenStates.pop());
            break;
          }
        } else {
          break;
        }
      }
      return node;
    }
    function parsePercentage(state) {
      var node, name297, fn, params;
      node = parseUnary(state);
      var operators = {
        "%": "mod",
        mod: "mod"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name297 = state.token;
        fn = operators[name297];
        getTokenSkipNewline(state);
        if (name297 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
          node = new OperatorNode("/", "divide", [node, new ConstantNode(100)], false, true);
        } else {
          params = [node, parseUnary(state)];
          node = new OperatorNode(name297, fn, params);
        }
      }
      return node;
    }
    function parseUnary(state) {
      var name297, params, fn;
      var operators = {
        "-": "unaryMinus",
        "+": "unaryPlus",
        "~": "bitNot",
        not: "not"
      };
      if (hasOwnProperty2(operators, state.token)) {
        fn = operators[state.token];
        name297 = state.token;
        getTokenSkipNewline(state);
        params = [parseUnary(state)];
        return new OperatorNode(name297, fn, params);
      }
      return parsePow(state);
    }
    function parsePow(state) {
      var node, name297, fn, params;
      node = parseLeftHandOperators(state);
      if (state.token === "^" || state.token === ".^") {
        name297 = state.token;
        fn = name297 === "^" ? "pow" : "dotPow";
        getTokenSkipNewline(state);
        params = [node, parseUnary(state)];
        node = new OperatorNode(name297, fn, params);
      }
      return node;
    }
    function parseLeftHandOperators(state) {
      var node, name297, fn, params;
      node = parseCustomNodes(state);
      var operators = {
        "!": "factorial",
        "'": "ctranspose"
      };
      while (hasOwnProperty2(operators, state.token)) {
        name297 = state.token;
        fn = operators[name297];
        getToken(state);
        params = [node];
        node = new OperatorNode(name297, fn, params);
        node = parseAccessors(state, node);
      }
      return node;
    }
    function parseCustomNodes(state) {
      var params = [];
      if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty2(state.extraNodes, state.token)) {
        var CustomNode = state.extraNodes[state.token];
        getToken(state);
        if (state.token === "(") {
          params = [];
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
        }
        return new CustomNode(params);
      }
      return parseSymbol(state);
    }
    function parseSymbol(state) {
      var node, name297;
      if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
        name297 = state.token;
        getToken(state);
        if (hasOwnProperty2(CONSTANTS, name297)) {
          node = new ConstantNode(CONSTANTS[name297]);
        } else if (NUMERIC_CONSTANTS.indexOf(name297) !== -1) {
          node = new ConstantNode(numeric2(name297, "number"));
        } else {
          node = new SymbolNode(name297);
        }
        node = parseAccessors(state, node);
        return node;
      }
      return parseDoubleQuotesString(state);
    }
    function parseAccessors(state, node, types) {
      var params;
      while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
        params = [];
        if (state.token === "(") {
          if (isSymbolNode(node) || isAccessorNode(node)) {
            openParams(state);
            getToken(state);
            if (state.token !== ")") {
              params.push(parseAssignment(state));
              while (state.token === ",") {
                getToken(state);
                params.push(parseAssignment(state));
              }
            }
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
            node = new FunctionNode(node, params);
          } else {
            return node;
          }
        } else if (state.token === "[") {
          openParams(state);
          getToken(state);
          if (state.token !== "]") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "Parenthesis ] expected");
          }
          closeParams(state);
          getToken(state);
          node = new AccessorNode(node, new IndexNode(params));
        } else {
          getToken(state);
          if (state.tokenType !== TOKENTYPE.SYMBOL) {
            throw createSyntaxError(state, "Property name expected after dot");
          }
          params.push(new ConstantNode(state.token));
          getToken(state);
          var dotNotation = true;
          node = new AccessorNode(node, new IndexNode(params, dotNotation));
        }
      }
      return node;
    }
    function parseDoubleQuotesString(state) {
      var node, str;
      if (state.token === '"') {
        str = parseDoubleQuotesStringToken(state);
        node = new ConstantNode(str);
        node = parseAccessors(state, node);
        return node;
      }
      return parseSingleQuotesString(state);
    }
    function parseDoubleQuotesStringToken(state) {
      var str = "";
      while (currentCharacter(state) !== "" && currentCharacter(state) !== '"') {
        if (currentCharacter(state) === "\\") {
          str += currentCharacter(state);
          next(state);
        }
        str += currentCharacter(state);
        next(state);
      }
      getToken(state);
      if (state.token !== '"') {
        throw createSyntaxError(state, 'End of string " expected');
      }
      getToken(state);
      return JSON.parse('"' + str + '"');
    }
    function parseSingleQuotesString(state) {
      var node, str;
      if (state.token === "'") {
        str = parseSingleQuotesStringToken(state);
        node = new ConstantNode(str);
        node = parseAccessors(state, node);
        return node;
      }
      return parseMatrix(state);
    }
    function parseSingleQuotesStringToken(state) {
      var str = "";
      while (currentCharacter(state) !== "" && currentCharacter(state) !== "'") {
        if (currentCharacter(state) === "\\") {
          str += currentCharacter(state);
          next(state);
        }
        str += currentCharacter(state);
        next(state);
      }
      getToken(state);
      if (state.token !== "'") {
        throw createSyntaxError(state, "End of string ' expected");
      }
      getToken(state);
      return JSON.parse('"' + str + '"');
    }
    function parseMatrix(state) {
      var array, params, rows, cols;
      if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          var row = parseRow(state);
          if (state.token === ";") {
            rows = 1;
            params = [row];
            while (state.token === ";") {
              getToken(state);
              params[rows] = parseRow(state);
              rows++;
            }
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            cols = params[0].items.length;
            for (var r = 1; r < rows; r++) {
              if (params[r].items.length !== cols) {
                throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
              }
            }
            array = new ArrayNode(params);
          } else {
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            array = row;
          }
        } else {
          closeParams(state);
          getToken(state);
          array = new ArrayNode([]);
        }
        return parseAccessors(state, array);
      }
      return parseObject(state);
    }
    function parseRow(state) {
      var params = [parseAssignment(state)];
      var len = 1;
      while (state.token === ",") {
        getToken(state);
        params[len] = parseAssignment(state);
        len++;
      }
      return new ArrayNode(params);
    }
    function parseObject(state) {
      if (state.token === "{") {
        openParams(state);
        var key;
        var properties2 = {};
        do {
          getToken(state);
          if (state.token !== "}") {
            if (state.token === '"') {
              key = parseDoubleQuotesStringToken(state);
            } else if (state.token === "'") {
              key = parseSingleQuotesStringToken(state);
            } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
              key = state.token;
              getToken(state);
            } else {
              throw createSyntaxError(state, "Symbol or string expected as object key");
            }
            if (state.token !== ":") {
              throw createSyntaxError(state, "Colon : expected after object key");
            }
            getToken(state);
            properties2[key] = parseAssignment(state);
          }
        } while (state.token === ",");
        if (state.token !== "}") {
          throw createSyntaxError(state, "Comma , or bracket } expected after object value");
        }
        closeParams(state);
        getToken(state);
        var node = new ObjectNode(properties2);
        node = parseAccessors(state, node);
        return node;
      }
      return parseNumber(state);
    }
    function parseNumber(state) {
      var numberStr;
      if (state.tokenType === TOKENTYPE.NUMBER) {
        numberStr = state.token;
        getToken(state);
        return new ConstantNode(numeric2(numberStr, config2.number));
      }
      return parseParentheses(state);
    }
    function parseParentheses(state) {
      var node;
      if (state.token === "(") {
        openParams(state);
        getToken(state);
        node = parseAssignment(state);
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
        node = new ParenthesisNode(node);
        node = parseAccessors(state, node);
        return node;
      }
      return parseEnd(state);
    }
    function parseEnd(state) {
      if (state.token === "") {
        throw createSyntaxError(state, "Unexpected end of expression");
      } else {
        throw createSyntaxError(state, "Value expected");
      }
    }
    function col(state) {
      return state.index - state.token.length + 1;
    }
    function createSyntaxError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    function createError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    typed.addConversion({
      from: "string",
      to: "Node",
      convert: parse
    });
    return parse;
  });

  // node_modules/mathjs/lib/esm/expression/function/compile.js
  var name219 = "compile";
  var dependencies220 = ["typed", "parse"];
  var createCompile = /* @__PURE__ */ factory(name219, dependencies220, (_ref) => {
    var {
      typed,
      parse
    } = _ref;
    return typed(name219, {
      string: function string(expr) {
        return parse(expr).compile();
      },
      "Array | Matrix": function ArrayMatrix(expr) {
        return deepMap(expr, function(entry) {
          return parse(entry).compile();
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/function/evaluate.js
  var name220 = "evaluate";
  var dependencies221 = ["typed", "parse"];
  var createEvaluate = /* @__PURE__ */ factory(name220, dependencies221, (_ref) => {
    var {
      typed,
      parse
    } = _ref;
    return typed(name220, {
      string: function string(expr) {
        var scope = createEmptyMap();
        return parse(expr).compile().evaluate(scope);
      },
      "string, Map | Object": function stringMapObject(expr, scope) {
        return parse(expr).compile().evaluate(scope);
      },
      "Array | Matrix": function ArrayMatrix(expr) {
        var scope = createEmptyMap();
        return deepMap(expr, function(entry) {
          return parse(entry).compile().evaluate(scope);
        });
      },
      "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
        return deepMap(expr, function(entry) {
          return parse(entry).compile().evaluate(scope);
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/Parser.js
  var name221 = "Parser";
  var dependencies222 = ["evaluate"];
  var createParserClass = /* @__PURE__ */ factory(name221, dependencies222, (_ref) => {
    var {
      evaluate
    } = _ref;
    function Parser() {
      if (!(this instanceof Parser)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      Object.defineProperty(this, "scope", {
        value: createEmptyMap(),
        writable: false
      });
    }
    Parser.prototype.type = "Parser";
    Parser.prototype.isParser = true;
    Parser.prototype.evaluate = function(expr) {
      return evaluate(expr, this.scope);
    };
    Parser.prototype.get = function(name297) {
      if (this.scope.has(name297)) {
        return this.scope.get(name297);
      }
    };
    Parser.prototype.getAll = function() {
      return toObject(this.scope);
    };
    Parser.prototype.getAllAsMap = function() {
      return this.scope;
    };
    Parser.prototype.set = function(name297, value) {
      this.scope.set(name297, value);
      return value;
    };
    Parser.prototype.remove = function(name297) {
      this.scope.delete(name297);
    };
    Parser.prototype.clear = function() {
      this.scope.clear();
    };
    return Parser;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/expression/function/parser.js
  var name222 = "parser";
  var dependencies223 = ["typed", "Parser"];
  var createParser = /* @__PURE__ */ factory(name222, dependencies223, (_ref) => {
    var {
      typed,
      Parser
    } = _ref;
    return typed(name222, {
      "": function _() {
        return new Parser();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
  var name223 = "lup";
  var dependencies224 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
  var createLup = /* @__PURE__ */ factory(name223, dependencies224, (_ref) => {
    var {
      typed,
      matrix,
      abs: abs2,
      addScalar,
      divideScalar,
      multiplyScalar,
      subtract,
      larger,
      equalScalar,
      unaryMinus,
      DenseMatrix,
      SparseMatrix,
      Spa
    } = _ref;
    return typed(name223, {
      DenseMatrix: function DenseMatrix2(m) {
        return _denseLUP(m);
      },
      SparseMatrix: function SparseMatrix2(m) {
        return _sparseLUP(m);
      },
      Array: function Array2(a) {
        var m = matrix(a);
        var r = _denseLUP(m);
        return {
          L: r.L.valueOf(),
          U: r.U.valueOf(),
          p: r.p
        };
      }
    });
    function _denseLUP(m) {
      var rows = m._size[0];
      var columns = m._size[1];
      var n = Math.min(rows, columns);
      var data = clone(m._data);
      var ldata = [];
      var lsize = [rows, n];
      var udata = [];
      var usize = [n, columns];
      var i, j, k;
      var p = [];
      for (i = 0; i < rows; i++) {
        p[i] = i;
      }
      for (j = 0; j < columns; j++) {
        if (j > 0) {
          for (i = 0; i < rows; i++) {
            var min2 = Math.min(i, j);
            var s = 0;
            for (k = 0; k < min2; k++) {
              s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));
            }
            data[i][j] = subtract(data[i][j], s);
          }
        }
        var pi2 = j;
        var pabsv = 0;
        var vjj = 0;
        for (i = j; i < rows; i++) {
          var v = data[i][j];
          var absv = abs2(v);
          if (larger(absv, pabsv)) {
            pi2 = i;
            pabsv = absv;
            vjj = v;
          }
        }
        if (j !== pi2) {
          p[j] = [p[pi2], p[pi2] = p[j]][0];
          DenseMatrix._swapRows(j, pi2, data);
        }
        if (j < rows) {
          for (i = j + 1; i < rows; i++) {
            var vij = data[i][j];
            if (!equalScalar(vij, 0)) {
              data[i][j] = divideScalar(data[i][j], vjj);
            }
          }
        }
      }
      for (j = 0; j < columns; j++) {
        for (i = 0; i < rows; i++) {
          if (j === 0) {
            if (i < columns) {
              udata[i] = [];
            }
            ldata[i] = [];
          }
          if (i < j) {
            if (i < columns) {
              udata[i][j] = data[i][j];
            }
            if (j < rows) {
              ldata[i][j] = 0;
            }
            continue;
          }
          if (i === j) {
            if (i < columns) {
              udata[i][j] = data[i][j];
            }
            if (j < rows) {
              ldata[i][j] = 1;
            }
            continue;
          }
          if (i < columns) {
            udata[i][j] = 0;
          }
          if (j < rows) {
            ldata[i][j] = data[i][j];
          }
        }
      }
      var l = new DenseMatrix({
        data: ldata,
        size: lsize
      });
      var u = new DenseMatrix({
        data: udata,
        size: usize
      });
      var pv = [];
      for (i = 0, n = p.length; i < n; i++) {
        pv[p[i]] = i;
      }
      return {
        L: l,
        U: u,
        p: pv,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
    function _sparseLUP(m) {
      var rows = m._size[0];
      var columns = m._size[1];
      var n = Math.min(rows, columns);
      var values2 = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var lsize = [rows, n];
      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var usize = [n, columns];
      var i, j, k;
      var pvCo = [];
      var pvOc = [];
      for (i = 0; i < rows; i++) {
        pvCo[i] = i;
        pvOc[i] = i;
      }
      var swapIndeces = function swapIndeces2(x, y) {
        var kx = pvOc[x];
        var ky = pvOc[y];
        pvCo[kx] = y;
        pvCo[ky] = x;
        pvOc[x] = ky;
        pvOc[y] = kx;
      };
      var _loop = function _loop2() {
        var spa = new Spa();
        if (j < rows) {
          lptr.push(lvalues.length);
          lvalues.push(1);
          lindex.push(j);
        }
        uptr.push(uvalues.length);
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (k = k0; k < k1; k++) {
          i = index[k];
          spa.set(pvCo[i], values2[k]);
        }
        if (j > 0) {
          spa.forEach(0, j - 1, function(k2, vkj) {
            SparseMatrix._forEachRow(k2, lvalues, lindex, lptr, function(i2, vik) {
              if (i2 > k2) {
                spa.accumulate(i2, unaryMinus(multiplyScalar(vik, vkj)));
              }
            });
          });
        }
        var pi2 = j;
        var vjj = spa.get(j);
        var pabsv = abs2(vjj);
        spa.forEach(j + 1, rows - 1, function(x, v) {
          var absv = abs2(v);
          if (larger(absv, pabsv)) {
            pi2 = x;
            pabsv = absv;
            vjj = v;
          }
        });
        if (j !== pi2) {
          SparseMatrix._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
          SparseMatrix._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
          spa.swap(j, pi2);
          swapIndeces(j, pi2);
        }
        spa.forEach(0, rows - 1, function(x, v) {
          if (x <= j) {
            uvalues.push(v);
            uindex.push(x);
          } else {
            v = divideScalar(v, vjj);
            if (!equalScalar(v, 0)) {
              lvalues.push(v);
              lindex.push(x);
            }
          }
        });
      };
      for (j = 0; j < columns; j++) {
        _loop();
      }
      uptr.push(uvalues.length);
      lptr.push(lvalues.length);
      return {
        L: new SparseMatrix({
          values: lvalues,
          index: lindex,
          ptr: lptr,
          size: lsize
        }),
        U: new SparseMatrix({
          values: uvalues,
          index: uindex,
          ptr: uptr,
          size: usize
        }),
        p: pvCo,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
  var name224 = "qr";
  var dependencies225 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
  var createQr = /* @__PURE__ */ factory(name224, dependencies225, (_ref) => {
    var {
      typed,
      matrix,
      zeros: zeros2,
      identity,
      isZero,
      equal,
      sign: sign3,
      sqrt: sqrt2,
      conj,
      unaryMinus,
      addScalar,
      divideScalar,
      multiplyScalar,
      subtract,
      complex
    } = _ref;
    return _extends(typed(name224, {
      DenseMatrix: function DenseMatrix(m) {
        return _denseQR(m);
      },
      SparseMatrix: function SparseMatrix(m) {
        return _sparseQR(m);
      },
      Array: function Array2(a) {
        var m = matrix(a);
        var r = _denseQR(m);
        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    }), {
      _denseQRimpl
    });
    function _denseQRimpl(m) {
      var rows = m._size[0];
      var cols = m._size[1];
      var Q2 = identity([rows], "dense");
      var Qdata = Q2._data;
      var R = m.clone();
      var Rdata = R._data;
      var i, j, k;
      var w = zeros2([rows], "");
      for (k = 0; k < Math.min(cols, rows); ++k) {
        var pivot = Rdata[k][k];
        var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign3(pivot));
        var conjSgn = conj(sgn);
        var alphaSquared = 0;
        for (i = k; i < rows; i++) {
          alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
        }
        var alpha = multiplyScalar(sgn, sqrt2(alphaSquared));
        if (!isZero(alpha)) {
          var u1 = subtract(pivot, alpha);
          w[k] = 1;
          for (i = k + 1; i < rows; i++) {
            w[i] = divideScalar(Rdata[i][k], u1);
          }
          var tau2 = unaryMinus(conj(divideScalar(u1, alpha)));
          var s = void 0;
          for (j = k; j < cols; j++) {
            s = 0;
            for (i = k; i < rows; i++) {
              s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
            }
            s = multiplyScalar(s, tau2);
            for (i = k; i < rows; i++) {
              Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
            }
          }
          for (i = 0; i < rows; i++) {
            s = 0;
            for (j = k; j < rows; j++) {
              s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
            }
            s = multiplyScalar(s, tau2);
            for (j = k; j < rows; ++j) {
              Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
            }
          }
        }
      }
      return {
        Q: Q2,
        R,
        toString: function toString() {
          return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
        }
      };
    }
    function _denseQR(m) {
      var ret = _denseQRimpl(m);
      var Rdata = ret.R._data;
      if (m._data.length > 0) {
        var zero = Rdata[0][0].type === "Complex" ? complex(0) : 0;
        for (var i = 0; i < Rdata.length; ++i) {
          for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
            Rdata[i][j] = zero;
          }
        }
      }
      return ret;
    }
    function _sparseQR(m) {
      throw new Error("qr not implemented for sparse matrices yet");
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
  function csPermute(a, pinv, q, values2) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var m = asize[0];
    var n = asize[1];
    var cvalues = values2 && a._values ? [] : null;
    var cindex = [];
    var cptr = [];
    var nz = 0;
    for (var k = 0; k < n; k++) {
      cptr[k] = nz;
      var j = q ? q[k] : k;
      for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
        var r = pinv ? pinv[aindex[t]] : aindex[t];
        cindex[nz] = r;
        if (cvalues) {
          cvalues[nz] = avalues[t];
        }
        nz++;
      }
    }
    cptr[n] = nz;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [m, n],
      datatype: adt
    });
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
  function csTdfs(j, k, w, head, next, post, stack) {
    var top = 0;
    w[stack] = j;
    while (top >= 0) {
      var p = w[stack + top];
      var i = w[head + p];
      if (i === -1) {
        top--;
        post[k++] = p;
      } else {
        w[head + p] = w[next + i];
        ++top;
        w[stack + top] = i;
      }
    }
    return k;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
  function csPost(parent, n) {
    if (!parent) {
      return null;
    }
    var k = 0;
    var j;
    var post = [];
    var w = [];
    var head = 0;
    var next = n;
    var stack = 2 * n;
    for (j = 0; j < n; j++) {
      w[head + j] = -1;
    }
    for (j = n - 1; j >= 0; j--) {
      if (parent[j] === -1) {
        continue;
      }
      w[next + j] = w[head + parent[j]];
      w[head + parent[j]] = j;
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        continue;
      }
      k = csTdfs(j, k, w, head, next, post, stack);
    }
    return post;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
  function csEtree(a, ata) {
    if (!a) {
      return null;
    }
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var parent = [];
    var w = [];
    var ancestor = 0;
    var prev = n;
    var i, inext;
    if (ata) {
      for (i = 0; i < m; i++) {
        w[prev + i] = -1;
      }
    }
    for (var k = 0; k < n; k++) {
      parent[k] = -1;
      w[ancestor + k] = -1;
      for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        var r = aindex[p];
        i = ata ? w[prev + r] : r;
        for (; i !== -1 && i < k; i = inext) {
          inext = w[ancestor + i];
          w[ancestor + i] = k;
          if (inext === -1) {
            parent[i] = k;
          }
        }
        if (ata) {
          w[prev + r] = k;
        }
      }
    }
    return parent;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
  function csFkeep(a, callback, other) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var nz = 0;
    for (var j = 0; j < n; j++) {
      var p = aptr[j];
      aptr[j] = nz;
      for (; p < aptr[j + 1]; p++) {
        if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
          aindex[nz] = aindex[p];
          if (avalues) {
            avalues[nz] = avalues[p];
          }
          nz++;
        }
      }
    }
    aptr[n] = nz;
    aindex.splice(nz, aindex.length - nz);
    if (avalues) {
      avalues.splice(nz, avalues.length - nz);
    }
    return nz;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
  function csFlip(i) {
    return -i - 2;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
  var name225 = "csAmd";
  var dependencies226 = ["add", "multiply", "transpose"];
  var createCsAmd = /* @__PURE__ */ factory(name225, dependencies226, (_ref) => {
    var {
      add: add2,
      multiply,
      transpose
    } = _ref;
    return function csAmd(order, a) {
      if (!a || order <= 0 || order > 3) {
        return null;
      }
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      var lemax = 0;
      var dense = Math.max(16, 10 * Math.sqrt(n));
      dense = Math.min(n - 2, dense);
      var cm = _createTargetMatrix(order, a, m, n, dense);
      csFkeep(cm, _diag, null);
      var cindex = cm._index;
      var cptr = cm._ptr;
      var cnz = cptr[n];
      var P3 = [];
      var W = [];
      var len = 0;
      var nv = n + 1;
      var next = 2 * (n + 1);
      var head = 3 * (n + 1);
      var elen = 4 * (n + 1);
      var degree = 5 * (n + 1);
      var w = 6 * (n + 1);
      var hhead = 7 * (n + 1);
      var last = P3;
      var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
      var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
      var mindeg = 0;
      var i, j, k, k1, k2, e2, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
      while (nel < n) {
        for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) {
          ;
        }
        if (W[next + k] !== -1) {
          last[W[next + k]] = -1;
        }
        W[head + mindeg] = W[next + k];
        var elenk = W[elen + k];
        var nvk = W[nv + k];
        nel += nvk;
        var dk = 0;
        W[nv + k] = -nvk;
        var p = cptr[k];
        var pk1 = elenk === 0 ? p : cnz;
        var pk2 = pk1;
        for (k1 = 1; k1 <= elenk + 1; k1++) {
          if (k1 > elenk) {
            e2 = k;
            pj = p;
            ln2 = W[len + k] - elenk;
          } else {
            e2 = cindex[p++];
            pj = cptr[e2];
            ln2 = W[len + e2];
          }
          for (k2 = 1; k2 <= ln2; k2++) {
            i = cindex[pj++];
            if ((nvi = W[nv + i]) <= 0) {
              continue;
            }
            dk += nvi;
            W[nv + i] = -nvi;
            cindex[pk2++] = i;
            if (W[next + i] !== -1) {
              last[W[next + i]] = last[i];
            }
            if (last[i] !== -1) {
              W[next + last[i]] = W[next + i];
            } else {
              W[head + W[degree + i]] = W[next + i];
            }
          }
          if (e2 !== k) {
            cptr[e2] = csFlip(k);
            W[w + e2] = 0;
          }
        }
        if (elenk !== 0) {
          cnz = pk2;
        }
        W[degree + k] = dk;
        cptr[k] = pk1;
        W[len + k] = pk2 - pk1;
        W[elen + k] = -2;
        mark = _wclear(mark, lemax, W, w, n);
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if ((eln = W[elen + i]) <= 0) {
            continue;
          }
          nvi = -W[nv + i];
          var wnvi = mark - nvi;
          for (p = cptr[i], p1 = cptr[i] + eln - 1; p <= p1; p++) {
            e2 = cindex[p];
            if (W[w + e2] >= mark) {
              W[w + e2] -= nvi;
            } else if (W[w + e2] !== 0) {
              W[w + e2] = W[degree + e2] + wnvi;
            }
          }
        }
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          p1 = cptr[i];
          p2 = p1 + W[elen + i] - 1;
          pn = p1;
          for (h = 0, d = 0, p = p1; p <= p2; p++) {
            e2 = cindex[p];
            if (W[w + e2] !== 0) {
              var dext = W[w + e2] - mark;
              if (dext > 0) {
                d += dext;
                cindex[pn++] = e2;
                h += e2;
              } else {
                cptr[e2] = csFlip(k);
                W[w + e2] = 0;
              }
            }
          }
          W[elen + i] = pn - p1 + 1;
          var p3 = pn;
          var p4 = p1 + W[len + i];
          for (p = p2 + 1; p < p4; p++) {
            j = cindex[p];
            var nvj = W[nv + j];
            if (nvj <= 0) {
              continue;
            }
            d += nvj;
            cindex[pn++] = j;
            h += j;
          }
          if (d === 0) {
            cptr[i] = csFlip(k);
            nvi = -W[nv + i];
            dk -= nvi;
            nvk += nvi;
            nel += nvi;
            W[nv + i] = 0;
            W[elen + i] = -1;
          } else {
            W[degree + i] = Math.min(W[degree + i], d);
            cindex[pn] = cindex[p3];
            cindex[p3] = cindex[p1];
            cindex[p1] = k;
            W[len + i] = pn - p1 + 1;
            h = (h < 0 ? -h : h) % n;
            W[next + i] = W[hhead + h];
            W[hhead + h] = i;
            last[i] = h;
          }
        }
        W[degree + k] = dk;
        lemax = Math.max(lemax, dk);
        mark = _wclear(mark + lemax, lemax, W, w, n);
        for (pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if (W[nv + i] >= 0) {
            continue;
          }
          h = last[i];
          i = W[hhead + h];
          W[hhead + h] = -1;
          for (; i !== -1 && W[next + i] !== -1; i = W[next + i], mark++) {
            ln2 = W[len + i];
            eln = W[elen + i];
            for (p = cptr[i] + 1; p <= cptr[i] + ln2 - 1; p++) {
              W[w + cindex[p]] = mark;
            }
            var jlast = i;
            for (j = W[next + i]; j !== -1; ) {
              var ok = W[len + j] === ln2 && W[elen + j] === eln;
              for (p = cptr[j] + 1; ok && p <= cptr[j] + ln2 - 1; p++) {
                if (W[w + cindex[p]] !== mark) {
                  ok = 0;
                }
              }
              if (ok) {
                cptr[j] = csFlip(i);
                W[nv + i] += W[nv + j];
                W[nv + j] = 0;
                W[elen + j] = -1;
                j = W[next + j];
                W[next + jlast] = j;
              } else {
                jlast = j;
                j = W[next + j];
              }
            }
          }
        }
        for (p = pk1, pk = pk1; pk < pk2; pk++) {
          i = cindex[pk];
          if ((nvi = -W[nv + i]) <= 0) {
            continue;
          }
          W[nv + i] = nvi;
          d = W[degree + i] + dk - nvi;
          d = Math.min(d, n - nel - nvi);
          if (W[head + d] !== -1) {
            last[W[head + d]] = i;
          }
          W[next + i] = W[head + d];
          last[i] = -1;
          W[head + d] = i;
          mindeg = Math.min(mindeg, d);
          W[degree + i] = d;
          cindex[p++] = i;
        }
        W[nv + k] = nvk;
        if ((W[len + k] = p - pk1) === 0) {
          cptr[k] = -1;
          W[w + k] = 0;
        }
        if (elenk !== 0) {
          cnz = p;
        }
      }
      for (i = 0; i < n; i++) {
        cptr[i] = csFlip(cptr[i]);
      }
      for (j = 0; j <= n; j++) {
        W[head + j] = -1;
      }
      for (j = n; j >= 0; j--) {
        if (W[nv + j] > 0) {
          continue;
        }
        W[next + j] = W[head + cptr[j]];
        W[head + cptr[j]] = j;
      }
      for (e2 = n; e2 >= 0; e2--) {
        if (W[nv + e2] <= 0) {
          continue;
        }
        if (cptr[e2] !== -1) {
          W[next + e2] = W[head + cptr[e2]];
          W[head + cptr[e2]] = e2;
        }
      }
      for (k = 0, i = 0; i <= n; i++) {
        if (cptr[i] === -1) {
          k = csTdfs(i, k, W, head, next, P3, w);
        }
      }
      P3.splice(P3.length - 1, 1);
      return P3;
    };
    function _createTargetMatrix(order, a, m, n, dense) {
      var at = transpose(a);
      if (order === 1 && n === m) {
        return add2(a, at);
      }
      if (order === 2) {
        var tindex = at._index;
        var tptr = at._ptr;
        var p2 = 0;
        for (var j = 0; j < m; j++) {
          var p = tptr[j];
          tptr[j] = p2;
          if (tptr[j + 1] - p > dense) {
            continue;
          }
          for (var p1 = tptr[j + 1]; p < p1; p++) {
            tindex[p2++] = tindex[p];
          }
        }
        tptr[m] = p2;
        a = transpose(at);
        return multiply(at, a);
      }
      return multiply(at, a);
    }
    function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
      for (var k = 0; k < n; k++) {
        W[len + k] = cptr[k + 1] - cptr[k];
      }
      W[len + n] = 0;
      for (var i = 0; i <= n; i++) {
        W[head + i] = -1;
        last[i] = -1;
        W[next + i] = -1;
        W[hhead + i] = -1;
        W[nv + i] = 1;
        W[w + i] = 1;
        W[elen + i] = 0;
        W[degree + i] = W[len + i];
      }
      var mark = _wclear(0, 0, W, w, n);
      W[elen + n] = -2;
      cptr[n] = -1;
      W[w + n] = 0;
      return mark;
    }
    function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
      var nel = 0;
      for (var i = 0; i < n; i++) {
        var d = W[degree + i];
        if (d === 0) {
          W[elen + i] = -2;
          nel++;
          cptr[i] = -1;
          W[w + i] = 0;
        } else if (d > dense) {
          W[nv + i] = 0;
          W[elen + i] = -1;
          nel++;
          cptr[i] = csFlip(n);
          W[nv + n]++;
        } else {
          var h = W[head + d];
          if (h !== -1) {
            last[h] = i;
          }
          W[next + i] = W[head + d];
          W[head + d] = i;
        }
      }
      return nel;
    }
    function _wclear(mark, lemax, W, w, n) {
      if (mark < 2 || mark + lemax < 0) {
        for (var k = 0; k < n; k++) {
          if (W[w + k] !== 0) {
            W[w + k] = 1;
          }
        }
        mark = 2;
      }
      return mark;
    }
    function _diag(i, j) {
      return i !== j;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
  function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {
    var s, sparent;
    var jleaf = 0;
    var q;
    if (i <= j || w[first + j] <= w[maxfirst + i]) {
      return -1;
    }
    w[maxfirst + i] = w[first + j];
    var jprev = w[prevleaf + i];
    w[prevleaf + i] = j;
    if (jprev === -1) {
      jleaf = 1;
      q = i;
    } else {
      jleaf = 2;
      for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {
        ;
      }
      for (s = jprev; s !== q; s = sparent) {
        sparent = w[ancestor + s];
        w[ancestor + s] = q;
      }
    }
    return {
      jleaf,
      q
    };
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
  var name226 = "csCounts";
  var dependencies227 = ["transpose"];
  var createCsCounts = /* @__PURE__ */ factory(name226, dependencies227, (_ref) => {
    var {
      transpose
    } = _ref;
    return function(a, parent, post, ata) {
      if (!a || !parent || !post) {
        return null;
      }
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      var i, j, k, J, p, p0, p1;
      var s = 4 * n + (ata ? n + m + 1 : 0);
      var w = [];
      var ancestor = 0;
      var maxfirst = n;
      var prevleaf = 2 * n;
      var first = 3 * n;
      var head = 4 * n;
      var next = 5 * n + 1;
      for (k = 0; k < s; k++) {
        w[k] = -1;
      }
      var colcount = [];
      var at = transpose(a);
      var tindex = at._index;
      var tptr = at._ptr;
      for (k = 0; k < n; k++) {
        j = post[k];
        colcount[j] = w[first + j] === -1 ? 1 : 0;
        for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
          w[first + j] = k;
        }
      }
      if (ata) {
        for (k = 0; k < n; k++) {
          w[post[k]] = k;
        }
        for (i = 0; i < m; i++) {
          for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {
            k = Math.min(k, w[tindex[p]]);
          }
          w[next + i] = w[head + k];
          w[head + k] = i;
        }
      }
      for (i = 0; i < n; i++) {
        w[ancestor + i] = i;
      }
      for (k = 0; k < n; k++) {
        j = post[k];
        if (parent[j] !== -1) {
          colcount[parent[j]]--;
        }
        for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
          for (p = tptr[J]; p < tptr[J + 1]; p++) {
            i = tindex[p];
            var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);
            if (r.jleaf >= 1) {
              colcount[j]++;
            }
            if (r.jleaf === 2) {
              colcount[r.q]--;
            }
          }
        }
        if (parent[j] !== -1) {
          w[ancestor + j] = parent[j];
        }
      }
      for (j = 0; j < n; j++) {
        if (parent[j] !== -1) {
          colcount[parent[j]] += colcount[j];
        }
      }
      return colcount;
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
  var name227 = "csSqr";
  var dependencies228 = ["add", "multiply", "transpose"];
  var createCsSqr = /* @__PURE__ */ factory(name227, dependencies228, (_ref) => {
    var {
      add: add2,
      multiply,
      transpose
    } = _ref;
    var csAmd = createCsAmd({
      add: add2,
      multiply,
      transpose
    });
    var csCounts = createCsCounts({
      transpose
    });
    return function csSqr(order, a, qr) {
      var aptr = a._ptr;
      var asize = a._size;
      var n = asize[1];
      var k;
      var s = {};
      s.q = csAmd(order, a);
      if (order && !s.q) {
        return null;
      }
      if (qr) {
        var c = order ? csPermute(a, null, s.q, 0) : a;
        s.parent = csEtree(c, 1);
        var post = csPost(s.parent, n);
        s.cp = csCounts(c, s.parent, post, 1);
        if (c && s.parent && s.cp && _vcount(c, s)) {
          for (s.unz = 0, k = 0; k < n; k++) {
            s.unz += s.cp[k];
          }
        }
      } else {
        s.unz = 4 * aptr[n] + n;
        s.lnz = s.unz;
      }
      return s;
    };
    function _vcount(a, s) {
      var aptr = a._ptr;
      var aindex = a._index;
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      s.pinv = [];
      s.leftmost = [];
      var parent = s.parent;
      var pinv = s.pinv;
      var leftmost = s.leftmost;
      var w = [];
      var next = 0;
      var head = m;
      var tail = m + n;
      var nque = m + 2 * n;
      var i, k, p, p0, p1;
      for (k = 0; k < n; k++) {
        w[head + k] = -1;
        w[tail + k] = -1;
        w[nque + k] = 0;
      }
      for (i = 0; i < m; i++) {
        leftmost[i] = -1;
      }
      for (k = n - 1; k >= 0; k--) {
        for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
          leftmost[aindex[p]] = k;
        }
      }
      for (i = m - 1; i >= 0; i--) {
        pinv[i] = -1;
        k = leftmost[i];
        if (k === -1) {
          continue;
        }
        if (w[nque + k]++ === 0) {
          w[tail + k] = i;
        }
        w[next + i] = w[head + k];
        w[head + k] = i;
      }
      s.lnz = 0;
      s.m2 = m;
      for (k = 0; k < n; k++) {
        i = w[head + k];
        s.lnz++;
        if (i < 0) {
          i = s.m2++;
        }
        pinv[i] = k;
        if (--nque[k] <= 0) {
          continue;
        }
        s.lnz += w[nque + k];
        var pa = parent[k];
        if (pa !== -1) {
          if (w[nque + pa] === 0) {
            w[tail + pa] = w[tail + k];
          }
          w[next + w[tail + k]] = w[head + pa];
          w[head + pa] = w[next + i];
          w[nque + pa] += w[nque + k];
        }
      }
      for (i = 0; i < m; i++) {
        if (pinv[i] < 0) {
          pinv[i] = k++;
        }
      }
      return true;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
  function csMarked(w, j) {
    return w[j] < 0;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
  function csMark(w, j) {
    w[j] = csFlip(w[j]);
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
  function csUnflip(i) {
    return i < 0 ? csFlip(i) : i;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
  function csDfs(j, g, top, xi, pinv) {
    var index = g._index;
    var ptr = g._ptr;
    var size = g._size;
    var n = size[1];
    var i, p, p2;
    var head = 0;
    xi[0] = j;
    while (head >= 0) {
      j = xi[head];
      var jnew = pinv ? pinv[j] : j;
      if (!csMarked(ptr, j)) {
        csMark(ptr, j);
        xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
      }
      var done = 1;
      for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
        i = index[p];
        if (csMarked(ptr, i)) {
          continue;
        }
        xi[n + head] = p;
        xi[++head] = i;
        done = 0;
        break;
      }
      if (done) {
        head--;
        xi[--top] = j;
      }
    }
    return top;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
  function csReach(g, b, k, xi, pinv) {
    var gptr = g._ptr;
    var gsize = g._size;
    var bindex = b._index;
    var bptr = b._ptr;
    var n = gsize[1];
    var p, p0, p1;
    var top = n;
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      var i = bindex[p];
      if (!csMarked(gptr, i)) {
        top = csDfs(i, g, top, xi, pinv);
      }
    }
    for (p = top; p < n; p++) {
      csMark(gptr, xi[p]);
    }
    return top;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
  var name228 = "csSpsolve";
  var dependencies229 = ["divideScalar", "multiply", "subtract"];
  var createCsSpsolve = /* @__PURE__ */ factory(name228, dependencies229, (_ref) => {
    var {
      divideScalar,
      multiply,
      subtract
    } = _ref;
    return function csSpsolve(g, b, k, xi, x, pinv, lo) {
      var gvalues = g._values;
      var gindex = g._index;
      var gptr = g._ptr;
      var gsize = g._size;
      var n = gsize[1];
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var p, p0, p1, q;
      var top = csReach(g, b, k, xi, pinv);
      for (p = top; p < n; p++) {
        x[xi[p]] = 0;
      }
      for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
        x[bindex[p]] = bvalues[p];
      }
      for (var px = top; px < n; px++) {
        var j = xi[px];
        var J = pinv ? pinv[j] : j;
        if (J < 0) {
          continue;
        }
        p0 = gptr[J];
        p1 = gptr[J + 1];
        x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);
        p = lo ? p0 + 1 : p0;
        q = lo ? p1 : p1 - 1;
        for (; p < q; p++) {
          var i = gindex[p];
          x[i] = subtract(x[i], multiply(gvalues[p], x[j]));
        }
      }
      return top;
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
  var name229 = "csLu";
  var dependencies230 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
  var createCsLu = /* @__PURE__ */ factory(name229, dependencies230, (_ref) => {
    var {
      abs: abs2,
      divideScalar,
      multiply,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    } = _ref;
    var csSpsolve = createCsSpsolve({
      divideScalar,
      multiply,
      subtract
    });
    return function csLu(m, s, tol) {
      if (!m) {
        return null;
      }
      var size = m._size;
      var n = size[1];
      var q;
      var lnz = 100;
      var unz = 100;
      if (s) {
        q = s.q;
        lnz = s.lnz || lnz;
        unz = s.unz || unz;
      }
      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var L = new SparseMatrix({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: [n, n]
      });
      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var U = new SparseMatrix({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: [n, n]
      });
      var pinv = [];
      var i, p;
      var x = [];
      var xi = [];
      for (i = 0; i < n; i++) {
        x[i] = 0;
        pinv[i] = -1;
        lptr[i + 1] = 0;
      }
      lnz = 0;
      unz = 0;
      for (var k = 0; k < n; k++) {
        lptr[k] = lnz;
        uptr[k] = unz;
        var col = q ? q[k] : k;
        var top = csSpsolve(L, m, col, xi, x, pinv, 1);
        var ipiv = -1;
        var a = -1;
        for (p = top; p < n; p++) {
          i = xi[p];
          if (pinv[i] < 0) {
            var xabs = abs2(x[i]);
            if (larger(xabs, a)) {
              a = xabs;
              ipiv = i;
            }
          } else {
            uindex[unz] = pinv[i];
            uvalues[unz++] = x[i];
          }
        }
        if (ipiv === -1 || a <= 0) {
          return null;
        }
        if (pinv[col] < 0 && largerEq(abs2(x[col]), multiply(a, tol))) {
          ipiv = col;
        }
        var pivot = x[ipiv];
        uindex[unz] = k;
        uvalues[unz++] = pivot;
        pinv[ipiv] = k;
        lindex[lnz] = ipiv;
        lvalues[lnz++] = 1;
        for (p = top; p < n; p++) {
          i = xi[p];
          if (pinv[i] < 0) {
            lindex[lnz] = i;
            lvalues[lnz++] = divideScalar(x[i], pivot);
          }
          x[i] = 0;
        }
      }
      lptr[n] = lnz;
      uptr[n] = unz;
      for (p = 0; p < lnz; p++) {
        lindex[p] = pinv[lindex[p]];
      }
      lvalues.splice(lnz, lvalues.length - lnz);
      lindex.splice(lnz, lindex.length - lnz);
      uvalues.splice(unz, uvalues.length - unz);
      uindex.splice(unz, uindex.length - unz);
      return {
        L,
        U,
        pinv
      };
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
  var name230 = "slu";
  var dependencies231 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
  var createSlu = /* @__PURE__ */ factory(name230, dependencies231, (_ref) => {
    var {
      typed,
      abs: abs2,
      add: add2,
      multiply,
      transpose,
      divideScalar,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    } = _ref;
    var csSqr = createCsSqr({
      add: add2,
      multiply,
      transpose
    });
    var csLu = createCsLu({
      abs: abs2,
      divideScalar,
      multiply,
      subtract,
      larger,
      largerEq,
      SparseMatrix
    });
    return typed(name230, {
      "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
        if (!isInteger(order) || order < 0 || order > 3) {
          throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
        }
        if (threshold < 0 || threshold > 1) {
          throw new Error("Partial pivoting threshold must be a number from 0 to 1");
        }
        var s = csSqr(order, a, false);
        var f = csLu(a, s, threshold);
        return {
          L: f.L,
          U: f.U,
          p: f.pinv,
          q: s.q,
          toString: function toString() {
            return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
          }
        };
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
  function csIpvec(p, b) {
    var k;
    var n = b.length;
    var x = [];
    if (p) {
      for (k = 0; k < n; k++) {
        x[p[k]] = b[k];
      }
    } else {
      for (k = 0; k < n; k++) {
        x[k] = b[k];
      }
    }
    return x;
  }

  // node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
  var name231 = "lusolve";
  var dependencies232 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
  var createLusolve = /* @__PURE__ */ factory(name231, dependencies232, (_ref) => {
    var {
      typed,
      matrix,
      lup,
      slu,
      usolve,
      lsolve,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    return typed(name231, {
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        a = matrix(a);
        var d = lup(a);
        var x = _lusolve(d.L, d.U, d.p, null, b);
        return x.valueOf();
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
        var d = lup(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
        var d = lup(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
        var d = slu(a, order, threshold);
        return _lusolve(d.L, d.U, d.p, d.q, b);
      },
      "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
        return _lusolve(d.L, d.U, d.p, d.q, b);
      }
    });
    function _toMatrix(a) {
      if (isMatrix(a)) {
        return a;
      }
      if (isArray(a)) {
        return matrix(a);
      }
      throw new TypeError("Invalid Matrix LU decomposition");
    }
    function _lusolve(l, u, p, q, b) {
      l = _toMatrix(l);
      u = _toMatrix(u);
      if (p) {
        b = solveValidation(l, b, true);
        b._data = csIpvec(p, b._data);
      }
      var y = lsolve(l, b);
      var x = usolve(u, y);
      if (q) {
        x._data = csIpvec(q, x._data);
      }
      return x;
    }
  });

  // node_modules/mathjs/lib/esm/expression/Help.js
  var name232 = "Help";
  var dependencies233 = ["parse"];
  var createHelpClass = /* @__PURE__ */ factory(name232, dependencies233, (_ref) => {
    var {
      parse
    } = _ref;
    function Help(doc) {
      if (!(this instanceof Help)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!doc)
        throw new Error('Argument "doc" missing');
      this.doc = doc;
    }
    Help.prototype.type = "Help";
    Help.prototype.isHelp = true;
    Help.prototype.toString = function() {
      var doc = this.doc || {};
      var desc = "\n";
      if (doc.name) {
        desc += "Name: " + doc.name + "\n\n";
      }
      if (doc.category) {
        desc += "Category: " + doc.category + "\n\n";
      }
      if (doc.description) {
        desc += "Description:\n    " + doc.description + "\n\n";
      }
      if (doc.syntax) {
        desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
      }
      if (doc.examples) {
        desc += "Examples:\n";
        var scope = {};
        for (var i = 0; i < doc.examples.length; i++) {
          var expr = doc.examples[i];
          desc += "    " + expr + "\n";
          var res = void 0;
          try {
            res = parse(expr).compile().evaluate(scope);
          } catch (e2) {
            res = e2;
          }
          if (res !== void 0 && !isHelp(res)) {
            desc += "        " + format3(res, {
              precision: 14
            }) + "\n";
          }
        }
        desc += "\n";
      }
      if (doc.mayThrow && doc.mayThrow.length) {
        desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
      }
      if (doc.seealso && doc.seealso.length) {
        desc += "See also: " + doc.seealso.join(", ") + "\n";
      }
      return desc;
    };
    Help.prototype.toJSON = function() {
      var obj = clone(this.doc);
      obj.mathjs = "Help";
      return obj;
    };
    Help.fromJSON = function(json) {
      var doc = {};
      Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
        doc[prop] = json[prop];
      });
      return new Help(doc);
    };
    Help.prototype.valueOf = Help.prototype.toString;
    return Help;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/chain/Chain.js
  var name233 = "Chain";
  var dependencies234 = ["?on", "math", "typed"];
  var createChainClass = /* @__PURE__ */ factory(name233, dependencies234, (_ref) => {
    var {
      on,
      math: math2,
      typed
    } = _ref;
    function Chain(value) {
      if (!(this instanceof Chain)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (isChain(value)) {
        this.value = value.value;
      } else {
        this.value = value;
      }
    }
    Chain.prototype.type = "Chain";
    Chain.prototype.isChain = true;
    Chain.prototype.done = function() {
      return this.value;
    };
    Chain.prototype.valueOf = function() {
      return this.value;
    };
    Chain.prototype.toString = function() {
      return format3(this.value);
    };
    Chain.prototype.toJSON = function() {
      return {
        mathjs: "Chain",
        value: this.value
      };
    };
    Chain.fromJSON = function(json) {
      return new Chain(json.value);
    };
    function createProxy(name297, fn) {
      if (typeof fn === "function") {
        Chain.prototype[name297] = chainify(fn);
      }
    }
    function createLazyProxy(name297, resolver) {
      lazy(Chain.prototype, name297, function outerResolver() {
        var fn = resolver();
        if (typeof fn === "function") {
          return chainify(fn);
        }
        return void 0;
      });
    }
    function chainify(fn) {
      return function() {
        if (arguments.length === 0) {
          return new Chain(fn(this.value));
        }
        var args = [this.value];
        for (var i = 0; i < arguments.length; i++) {
          args[i + 1] = arguments[i];
        }
        if (typed.isTypedFunction(fn)) {
          var sigObject = typed.resolve(fn, args);
          if (sigObject.params.length === 1) {
            throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
          }
          return new Chain(sigObject.implementation.apply(fn, args));
        }
        return new Chain(fn.apply(fn, args));
      };
    }
    Chain.createProxy = function(arg0, arg1) {
      if (typeof arg0 === "string") {
        createProxy(arg0, arg1);
      } else {
        var _loop = function _loop2(_name2) {
          if (hasOwnProperty2(arg0, _name2) && excludedNames[_name2] === void 0) {
            createLazyProxy(_name2, () => arg0[_name2]);
          }
        };
        for (var _name in arg0) {
          _loop(_name);
        }
      }
    };
    var excludedNames = {
      expression: true,
      docs: true,
      type: true,
      classes: true,
      json: true,
      error: true,
      isChain: true
    };
    Chain.createProxy(math2);
    if (on) {
      on("import", function(name297, resolver, path) {
        if (!path) {
          createLazyProxy(name297, resolver);
        }
      });
    }
    return Chain;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
  var eDocs = {
    name: "e",
    category: "Constants",
    syntax: ["e"],
    description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
    examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
    seealso: ["exp"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
  var falseDocs = {
    name: "false",
    category: "Constants",
    syntax: ["false"],
    description: "Boolean value false",
    examples: ["false"],
    seealso: ["true"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
  var iDocs = {
    name: "i",
    category: "Constants",
    syntax: ["i"],
    description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
    examples: ["i", "i * i", "sqrt(-1)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
  var InfinityDocs = {
    name: "Infinity",
    category: "Constants",
    syntax: ["Infinity"],
    description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
    examples: ["Infinity", "1 / 0"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
  var LN10Docs = {
    name: "LN10",
    category: "Constants",
    syntax: ["LN10"],
    description: "Returns the natural logarithm of 10, approximately equal to 2.302",
    examples: ["LN10", "log(10)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
  var LN2Docs = {
    name: "LN2",
    category: "Constants",
    syntax: ["LN2"],
    description: "Returns the natural logarithm of 2, approximately equal to 0.693",
    examples: ["LN2", "log(2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
  var LOG10EDocs = {
    name: "LOG10E",
    category: "Constants",
    syntax: ["LOG10E"],
    description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
    examples: ["LOG10E", "log(e, 10)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
  var LOG2EDocs = {
    name: "LOG2E",
    category: "Constants",
    syntax: ["LOG2E"],
    description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
    examples: ["LOG2E", "log(e, 2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
  var NaNDocs = {
    name: "NaN",
    category: "Constants",
    syntax: ["NaN"],
    description: "Not a number",
    examples: ["NaN", "0 / 0"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
  var nullDocs = {
    name: "null",
    category: "Constants",
    syntax: ["null"],
    description: "Value null",
    examples: ["null"],
    seealso: ["true", "false"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
  var phiDocs = {
    name: "phi",
    category: "Constants",
    syntax: ["phi"],
    description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
    examples: ["phi"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
  var piDocs = {
    name: "pi",
    category: "Constants",
    syntax: ["pi"],
    description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
    examples: ["pi", "sin(pi/2)"],
    seealso: ["tau"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
  var SQRT12Docs = {
    name: "SQRT1_2",
    category: "Constants",
    syntax: ["SQRT1_2"],
    description: "Returns the square root of 1/2, approximately equal to 0.707",
    examples: ["SQRT1_2", "sqrt(1/2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
  var SQRT2Docs = {
    name: "SQRT2",
    category: "Constants",
    syntax: ["SQRT2"],
    description: "Returns the square root of 2, approximately equal to 1.414",
    examples: ["SQRT2", "sqrt(2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
  var tauDocs = {
    name: "tau",
    category: "Constants",
    syntax: ["tau"],
    description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
    examples: ["tau", "2 * pi"],
    seealso: ["pi"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
  var trueDocs = {
    name: "true",
    category: "Constants",
    syntax: ["true"],
    description: "Boolean value true",
    examples: ["true"],
    seealso: ["false"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
  var versionDocs = {
    name: "version",
    category: "Constants",
    syntax: ["version"],
    description: "A string with the version number of math.js",
    examples: ["version"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
  var bignumberDocs = {
    name: "bignumber",
    category: "Construction",
    syntax: ["bignumber(x)"],
    description: "Create a big number from a number or string.",
    examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
    seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
  var booleanDocs = {
    name: "boolean",
    category: "Construction",
    syntax: ["x", "boolean(x)"],
    description: "Convert a string or number into a boolean.",
    examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
    seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
  var complexDocs = {
    name: "complex",
    category: "Construction",
    syntax: ["complex()", "complex(re, im)", "complex(string)"],
    description: "Create a complex number.",
    examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
    seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
  var createUnitDocs = {
    name: "createUnit",
    category: "Construction",
    syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
    description: "Create a user-defined unit and register it with the Unit type.",
    examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
    seealso: ["unit", "splitUnit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
  var fractionDocs = {
    name: "fraction",
    category: "Construction",
    syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
    description: "Create a fraction from a number or from integer numerator and denominator.",
    examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
  var indexDocs = {
    name: "index",
    category: "Construction",
    syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
    description: "Create an index to get or replace a subset of a matrix",
    examples: ["[1, 2, 3]", "A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = ones(2, 2)"],
    seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
  var matrixDocs = {
    name: "matrix",
    category: "Construction",
    syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
    description: "Create a matrix.",
    examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
    seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
  var numberDocs = {
    name: "number",
    category: "Construction",
    syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
    description: "Create a number or convert a string or boolean into a number.",
    examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
    seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
  var sparseDocs = {
    name: "sparse",
    category: "Construction",
    syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
    description: "Create a sparse matrix.",
    examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
    seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
  var splitUnitDocs = {
    name: "splitUnit",
    category: "Construction",
    syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
    description: "Split a unit in an array of units whose sum is equal to the original unit.",
    examples: ['splitUnit(1 m, ["feet", "inch"])'],
    seealso: ["unit", "createUnit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
  var stringDocs = {
    name: "string",
    category: "Construction",
    syntax: ['"text"', "string(x)"],
    description: "Create a string or convert a value to a string",
    examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
  var unitDocs = {
    name: "unit",
    category: "Construction",
    syntax: ["value unit", "unit(value, unit)", "unit(string)"],
    description: "Create a unit.",
    examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
  var configDocs = {
    name: "config",
    category: "Core",
    syntax: ["config()", "config(options)"],
    description: "Get configuration or change configuration.",
    examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
  var importDocs = {
    name: "import",
    category: "Core",
    syntax: ["import(functions)", "import(functions, options)"],
    description: "Import functions or constants from an object.",
    examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
  var typedDocs = {
    name: "typed",
    category: "Core",
    syntax: ["typed(signatures)", "typed(name, signatures)"],
    description: "Create a typed function.",
    examples: ['double = typed({ "number": f(x)=x+x })', "double(2)", 'double("hello")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
  var derivativeDocs = {
    name: "derivative",
    category: "Algebra",
    syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
    description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
    examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
    seealso: ["simplify", "parse", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
  var leafCountDocs = {
    name: "leafCount",
    category: "Algebra",
    syntax: ["leafCount(expr)"],
    description: "Computes the number of leaves in the parse tree of the given expression",
    examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
    seealso: ["simplify"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
  var lsolveDocs = {
    name: "lsolve",
    category: "Algebra",
    syntax: ["x=lsolve(L, b)"],
    description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
  var lsolveAllDocs = {
    name: "lsolveAll",
    category: "Algebra",
    syntax: ["x=lsolveAll(L, b)"],
    description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
  var lupDocs = {
    name: "lup",
    category: "Algebra",
    syntax: ["lup(m)"],
    description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
    examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
  var lusolveDocs = {
    name: "lusolve",
    category: "Algebra",
    syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
    description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
    seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
  var qrDocs = {
    name: "qr",
    category: "Algebra",
    syntax: ["qr(A)"],
    description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
    examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
    seealso: ["lup", "slu", "matrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
  var rationalizeDocs = {
    name: "rationalize",
    category: "Algebra",
    syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
    description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
    examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
    seealso: ["simplify"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
  var resolveDocs = {
    name: "resolve",
    category: "Algebra",
    syntax: ["resolve(node, scope)"],
    description: "Recursively substitute variables in an expression tree.",
    examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
    seealso: ["simplify", "evaluate"],
    mayThrow: ["ReferenceError"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
  var simplifyDocs = {
    name: "simplify",
    category: "Algebra",
    syntax: ["simplify(expr)", "simplify(expr, rules)"],
    description: "Simplify an expression tree.",
    examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
    seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
  var simplifyConstantDocs = {
    name: "simplifyConstant",
    category: "Algebra",
    syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
    description: "Replace constant subexpressions of node with their values.",
    examples: ['simplifyConatant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
    seealso: ["simplify", "simplifyCore", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
  var simplifyCoreDocs = {
    name: "simplifyCore",
    category: "Algebra",
    syntax: ["simplifyCore(node)"],
    description: "Perform simple one-pass simplifications on an expression tree.",
    examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
    seealso: ["simplify", "simplifyConstant", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
  var sluDocs = {
    name: "slu",
    category: "Algebra",
    syntax: ["slu(A, order, threshold)"],
    description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
    examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
  var symbolicEqualDocs = {
    name: "symbolicEqual",
    category: "Algebra",
    syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
    description: "Returns true if the difference of the expressions simplifies to 0",
    examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
    seealso: ["simplify", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
  var usolveDocs = {
    name: "usolve",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
    seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
  var usolveAllDocs = {
    name: "usolveAll",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
    seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
  var absDocs = {
    name: "abs",
    category: "Arithmetic",
    syntax: ["abs(x)"],
    description: "Compute the absolute value.",
    examples: ["abs(3.5)", "abs(-4.2)"],
    seealso: ["sign"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
  var addDocs = {
    name: "add",
    category: "Operators",
    syntax: ["x + y", "add(x, y)"],
    description: "Add two values.",
    examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
    seealso: ["subtract"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
  var cbrtDocs = {
    name: "cbrt",
    category: "Arithmetic",
    syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
    description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
    examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
    seealso: ["square", "sqrt", "cube", "multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
  var ceilDocs = {
    name: "ceil",
    category: "Arithmetic",
    syntax: ["ceil(x)"],
    description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
    examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
    seealso: ["floor", "fix", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
  var cubeDocs = {
    name: "cube",
    category: "Arithmetic",
    syntax: ["cube(x)"],
    description: "Compute the cube of a value. The cube of x is x * x * x.",
    examples: ["cube(2)", "2^3", "2 * 2 * 2"],
    seealso: ["multiply", "square", "pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
  var divideDocs = {
    name: "divide",
    category: "Operators",
    syntax: ["x / y", "divide(x, y)"],
    description: "Divide two values.",
    examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
    seealso: ["multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
  var dotDivideDocs = {
    name: "dotDivide",
    category: "Operators",
    syntax: ["x ./ y", "dotDivide(x, y)"],
    description: "Divide two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
    seealso: ["multiply", "dotMultiply", "divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
  var dotMultiplyDocs = {
    name: "dotMultiply",
    category: "Operators",
    syntax: ["x .* y", "dotMultiply(x, y)"],
    description: "Multiply two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
    seealso: ["multiply", "divide", "dotDivide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
  var dotPowDocs = {
    name: "dotPow",
    category: "Operators",
    syntax: ["x .^ y", "dotPow(x, y)"],
    description: "Calculates the power of x to y element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
    seealso: ["pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
  var expDocs = {
    name: "exp",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Calculate the exponent of a value.",
    examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
    seealso: ["expm", "expm1", "pow", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
  var expmDocs = {
    name: "expm",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
    examples: ["expm([[0,2],[0,0]])"],
    seealso: ["exp"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
  var expm1Docs = {
    name: "expm1",
    category: "Arithmetic",
    syntax: ["expm1(x)"],
    description: "Calculate the value of subtracting 1 from the exponential value.",
    examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
    seealso: ["exp", "pow", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
  var fixDocs = {
    name: "fix",
    category: "Arithmetic",
    syntax: ["fix(x)"],
    description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
    examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
    seealso: ["ceil", "floor", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
  var floorDocs = {
    name: "floor",
    category: "Arithmetic",
    syntax: ["floor(x)"],
    description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
    examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
    seealso: ["ceil", "fix", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
  var gcdDocs = {
    name: "gcd",
    category: "Arithmetic",
    syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
    description: "Compute the greatest common divisor.",
    examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
    seealso: ["lcm", "xgcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
  var hypotDocs = {
    name: "hypot",
    category: "Arithmetic",
    syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
    description: "Calculate the hypotenusa of a list with values. ",
    examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
    seealso: ["abs", "norm"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
  var invmodDocs = {
    name: "invmod",
    category: "Arithmetic",
    syntax: ["invmod(a, b)"],
    description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
    examples: ["invmod(8, 12)=NaN", "invmod(7, 13)=2", "math.invmod(15151, 15122)=10429"],
    seealso: ["gcd", "xgcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
  var lcmDocs = {
    name: "lcm",
    category: "Arithmetic",
    syntax: ["lcm(x, y)"],
    description: "Compute the least common multiple.",
    examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
    seealso: ["gcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
  var logDocs = {
    name: "log",
    category: "Arithmetic",
    syntax: ["log(x)", "log(x, base)"],
    description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
    examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
    seealso: ["exp", "log1p", "log2", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
  var log10Docs = {
    name: "log10",
    category: "Arithmetic",
    syntax: ["log10(x)"],
    description: "Compute the 10-base logarithm of a value.",
    examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
    seealso: ["exp", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
  var log1pDocs = {
    name: "log1p",
    category: "Arithmetic",
    syntax: ["log1p(x)", "log1p(x, base)"],
    description: "Calculate the logarithm of a `value+1`",
    examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
    seealso: ["exp", "log", "log2", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
  var log2Docs = {
    name: "log2",
    category: "Arithmetic",
    syntax: ["log2(x)"],
    description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
    examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
    seealso: ["exp", "log1p", "log", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
  var modDocs = {
    name: "mod",
    category: "Operators",
    syntax: ["x % y", "x mod y", "mod(x, y)"],
    description: "Calculates the modulus, the remainder of an integer division.",
    examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
    seealso: ["divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
  var multiplyDocs = {
    name: "multiply",
    category: "Operators",
    syntax: ["x * y", "multiply(x, y)"],
    description: "multiply two values.",
    examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
    seealso: ["divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
  var normDocs = {
    name: "norm",
    category: "Arithmetic",
    syntax: ["norm(x)", "norm(x, p)"],
    description: "Calculate the norm of a number, vector or matrix.",
    examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
  var nthRootDocs = {
    name: "nthRoot",
    category: "Arithmetic",
    syntax: ["nthRoot(a)", "nthRoot(a, root)"],
    description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
    examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
    seealso: ["nthRoots", "pow", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
  var nthRootsDocs = {
    name: "nthRoots",
    category: "Arithmetic",
    syntax: ["nthRoots(A)", "nthRoots(A, root)"],
    description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
    examples: ["nthRoots(1)", "nthRoots(1, 3)"],
    seealso: ["sqrt", "pow", "nthRoot"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
  var powDocs = {
    name: "pow",
    category: "Operators",
    syntax: ["x ^ y", "pow(x, y)"],
    description: "Calculates the power of x to y, x^y.",
    examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "math.pow([[1, 2], [4, 3]], 2)", "math.pow([[1, 2], [4, 3]], -1)"],
    seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
  var roundDocs = {
    name: "round",
    category: "Arithmetic",
    syntax: ["round(x)", "round(x, n)"],
    description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
    examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
    seealso: ["ceil", "floor", "fix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
  var signDocs = {
    name: "sign",
    category: "Arithmetic",
    syntax: ["sign(x)"],
    description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
    examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
    seealso: ["abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
  var sqrtDocs = {
    name: "sqrt",
    category: "Arithmetic",
    syntax: ["sqrt(x)"],
    description: "Compute the square root value. If x = y * y, then y is the square root of x.",
    examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
    seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
  var sqrtmDocs = {
    name: "sqrtm",
    category: "Arithmetic",
    syntax: ["sqrtm(x)"],
    description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
    examples: ["sqrtm([[1, 2], [3, 4]])"],
    seealso: ["sqrt", "abs", "square", "multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
  var squareDocs = {
    name: "square",
    category: "Arithmetic",
    syntax: ["square(x)"],
    description: "Compute the square of a value. The square of x is x * x.",
    examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
    seealso: ["multiply", "pow", "sqrt", "cube"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
  var subtractDocs = {
    name: "subtract",
    category: "Operators",
    syntax: ["x - y", "subtract(x, y)"],
    description: "subtract two values.",
    examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
    seealso: ["add"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
  var unaryMinusDocs = {
    name: "unaryMinus",
    category: "Operators",
    syntax: ["-x", "unaryMinus(x)"],
    description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
    examples: ["-4.5", "-(-5.6)", '-"22"'],
    seealso: ["add", "subtract", "unaryPlus"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
  var unaryPlusDocs = {
    name: "unaryPlus",
    category: "Operators",
    syntax: ["+x", "unaryPlus(x)"],
    description: "Converts booleans and strings to numbers.",
    examples: ["+true", '+"2"'],
    seealso: ["add", "subtract", "unaryMinus"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
  var xgcdDocs = {
    name: "xgcd",
    category: "Arithmetic",
    syntax: ["xgcd(a, b)"],
    description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
    examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
    seealso: ["gcd", "lcm"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
  var bitAndDocs = {
    name: "bitAnd",
    category: "Bitwise",
    syntax: ["x & y", "bitAnd(x, y)"],
    description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
    examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
    seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
  var bitNotDocs = {
    name: "bitNot",
    category: "Bitwise",
    syntax: ["~x", "bitNot(x)"],
    description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
    examples: ["~1", "~2", "bitNot([2, -3, 4])"],
    seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
  var bitOrDocs = {
    name: "bitOr",
    category: "Bitwise",
    syntax: ["x | y", "bitOr(x, y)"],
    description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
    examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
    seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
  var bitXorDocs = {
    name: "bitXor",
    category: "Bitwise",
    syntax: ["bitXor(x, y)"],
    description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
    examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
    seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
  var leftShiftDocs = {
    name: "leftShift",
    category: "Bitwise",
    syntax: ["x << y", "leftShift(x, y)"],
    description: "Bitwise left logical shift of a value x by y number of bits.",
    examples: ["4 << 1", "8 >> 1"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
  var rightArithShiftDocs = {
    name: "rightArithShift",
    category: "Bitwise",
    syntax: ["x >> y", "rightArithShift(x, y)"],
    description: "Bitwise right arithmetic shift of a value x by y number of bits.",
    examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
  var rightLogShiftDocs = {
    name: "rightLogShift",
    category: "Bitwise",
    syntax: ["x >>> y", "rightLogShift(x, y)"],
    description: "Bitwise right logical shift of a value x by y number of bits.",
    examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
  var bellNumbersDocs = {
    name: "bellNumbers",
    category: "Combinatorics",
    syntax: ["bellNumbers(n)"],
    description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["bellNumbers(3)", "bellNumbers(8)"],
    seealso: ["stirlingS2"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
  var catalanDocs = {
    name: "catalan",
    category: "Combinatorics",
    syntax: ["catalan(n)"],
    description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["catalan(3)", "catalan(8)"],
    seealso: ["bellNumbers"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
  var compositionDocs = {
    name: "composition",
    category: "Combinatorics",
    syntax: ["composition(n, k)"],
    description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
    examples: ["composition(5, 3)"],
    seealso: ["combinations"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
  var stirlingS2Docs = {
    name: "stirlingS2",
    category: "Combinatorics",
    syntax: ["stirlingS2(n, k)"],
    description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
    examples: ["stirlingS2(5, 3)"],
    seealso: ["bellNumbers"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
  var argDocs = {
    name: "arg",
    category: "Complex",
    syntax: ["arg(x)"],
    description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
    examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
    seealso: ["re", "im", "conj", "abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
  var conjDocs = {
    name: "conj",
    category: "Complex",
    syntax: ["conj(x)"],
    description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
    examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
    seealso: ["re", "im", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
  var imDocs = {
    name: "im",
    category: "Complex",
    syntax: ["im(x)"],
    description: "Get the imaginary part of a complex number.",
    examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
    seealso: ["re", "conj", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
  var reDocs = {
    name: "re",
    category: "Complex",
    syntax: ["re(x)"],
    description: "Get the real part of a complex number.",
    examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
    seealso: ["im", "conj", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
  var evaluateDocs = {
    name: "evaluate",
    category: "Expression",
    syntax: ["evaluate(expression)", "evaluate([expr1, expr2, expr3, ...])"],
    description: "Evaluate an expression or an array with expressions.",
    examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
  var helpDocs = {
    name: "help",
    category: "Expression",
    syntax: ["help(object)", "help(string)"],
    description: "Display documentation on a function or data type.",
    examples: ["help(sqrt)", 'help("complex")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
  var distanceDocs = {
    name: "distance",
    category: "Geometry",
    syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
    description: "Calculates the Euclidean distance between two points.",
    examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
  var intersectDocs = {
    name: "intersect",
    category: "Geometry",
    syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
    description: "Computes the intersection point of lines and/or planes.",
    examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
  var andDocs = {
    name: "and",
    category: "Logical",
    syntax: ["x and y", "and(x, y)"],
    description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
    examples: ["true and false", "true and true", "2 and 4"],
    seealso: ["not", "or", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
  var notDocs = {
    name: "not",
    category: "Logical",
    syntax: ["not x", "not(x)"],
    description: "Logical not. Flips the boolean value of given argument.",
    examples: ["not true", "not false", "not 2", "not 0"],
    seealso: ["and", "or", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
  var orDocs = {
    name: "or",
    category: "Logical",
    syntax: ["x or y", "or(x, y)"],
    description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
    examples: ["true or false", "false or false", "0 or 4"],
    seealso: ["not", "and", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
  var xorDocs = {
    name: "xor",
    category: "Logical",
    syntax: ["x xor y", "xor(x, y)"],
    description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
    examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
    seealso: ["not", "and", "or"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
  var columnDocs = {
    name: "column",
    category: "Matrix",
    syntax: ["column(x, index)"],
    description: "Return a column from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
    seealso: ["row", "matrixFromColumns"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
  var concatDocs = {
    name: "concat",
    category: "Matrix",
    syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
    description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
    examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
    seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
  var countDocs = {
    name: "count",
    category: "Matrix",
    syntax: ["count(x)"],
    description: "Count the number of elements of a matrix, array or string.",
    examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
    seealso: ["size"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
  var crossDocs = {
    name: "cross",
    category: "Matrix",
    syntax: ["cross(A, B)"],
    description: "Calculate the cross product for two vectors in three dimensional space.",
    examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
    seealso: ["multiply", "dot"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
  var ctransposeDocs = {
    name: "ctranspose",
    category: "Matrix",
    syntax: ["x'", "ctranspose(x)"],
    description: "Complex Conjugate and Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
  var detDocs = {
    name: "det",
    category: "Matrix",
    syntax: ["det(x)"],
    description: "Calculate the determinant of a matrix",
    examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
    seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
  var diagDocs = {
    name: "diag",
    category: "Matrix",
    syntax: ["diag(x)", "diag(x, k)"],
    description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
    examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
    seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
  var diffDocs = {
    name: "diff",
    category: "Matrix",
    syntax: ["diff(arr)", "diff(arr, dim)"],
    description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
    examples: ["diff([1, 2, 4, 7, 0])", "diff([1, 2, 4, 7, 0], 0)", "diff(matrix([1, 2, 4, 7, 0]))", "diff([[1, 2], [3, 4]])", "diff([[1, 2], [3, 4]], 0)", "diff([[1, 2], [3, 4]], 1)", "diff([[1, 2], [3, 4]], bignumber(1))", "diff(matrix([[1, 2], [3, 4]]), 1)", "diff([[1, 2], matrix([3, 4])], 1)"],
    seealso: ["subtract", "partitionSelect"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
  var dotDocs = {
    name: "dot",
    category: "Matrix",
    syntax: ["dot(A, B)", "A * B"],
    description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
    examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
    seealso: ["multiply", "cross"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
  var eigsDocs = {
    name: "eigs",
    category: "Matrix",
    syntax: ["eigs(x)"],
    description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
    examples: ["eigs([[5, 2.3], [2.3, 1]])"],
    seealso: ["inv"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
  var filterDocs = {
    name: "filter",
    category: "Matrix",
    syntax: ["filter(x, test)"],
    description: "Filter items in a matrix.",
    examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
    seealso: ["sort", "map", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
  var flattenDocs = {
    name: "flatten",
    category: "Matrix",
    syntax: ["flatten(x)"],
    description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
    seealso: ["concat", "resize", "size", "squeeze"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
  var forEachDocs = {
    name: "forEach",
    category: "Matrix",
    syntax: ["forEach(x, callback)"],
    description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
    examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
    seealso: ["map", "sort", "filter"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
  var getMatrixDataTypeDocs = {
    name: "getMatrixDataType",
    category: "Matrix",
    syntax: ["getMatrixDataType(x)"],
    description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
    examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
    seealso: ["matrix", "sparse", "typeOf"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
  var identityDocs = {
    name: "identity",
    category: "Matrix",
    syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
    description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
    examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
    seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
  var invDocs = {
    name: "inv",
    category: "Matrix",
    syntax: ["inv(x)"],
    description: "Calculate the inverse of a matrix",
    examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
    seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
  var pinvDocs = {
    name: "pinv",
    category: "Matrix",
    syntax: ["pinv(x)"],
    description: "Calculate the Moore\u2013Penrose inverse of a matrix",
    examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
    seealso: ["inv"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
  var kronDocs = {
    name: "kron",
    category: "Matrix",
    syntax: ["kron(x, y)"],
    description: "Calculates the kronecker product of 2 matrices or vectors.",
    examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
    seealso: ["multiply", "dot", "cross"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
  var mapDocs = {
    name: "map",
    category: "Matrix",
    syntax: ["map(x, callback)"],
    description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
    examples: ["map([1, 2, 3], square)"],
    seealso: ["filter", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
  var matrixFromColumnsDocs = {
    name: "matrixFromColumns",
    category: "Matrix",
    syntax: ["math.matrixFromColumns(...arr)", "math.matrixFromColumns(row1, row2)", "math.matrixFromColumns(row1, row2, row3)"],
    description: "Create a dense matrix from vectors as individual columns.",
    examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
  var matrixFromFunctionDocs = {
    name: "matrixFromFunction",
    category: "Matrix",
    syntax: ["math.matrixFromFunction(size, fn)", "math.matrixFromFunction(size, fn, format)", "math.matrixFromFunction(size, fn, format, datatype)", "math.matrixFromFunction(size, format, fn)", "math.matrixFromFunction(size, format, datatype, fn)"],
    description: "Create a matrix by evaluating a generating function at each index.",
    examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
    seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
  var matrixFromRowsDocs = {
    name: "matrixFromRows",
    category: "Matrix",
    syntax: ["math.matrixFromRows(...arr)", "math.matrixFromRows(row1, row2)", "math.matrixFromRows(row1, row2, row3)"],
    description: "Create a dense matrix from vectors as individual rows.",
    examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
  var onesDocs = {
    name: "ones",
    category: "Matrix",
    syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
    description: "Create a matrix containing ones.",
    examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
  var partitionSelectDocs = {
    name: "partitionSelect",
    category: "Matrix",
    syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
    description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
    examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1)'],
    seealso: ["sort"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
  var rangeDocs = {
    name: "range",
    category: "Type",
    syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
    description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
    examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
  var reshapeDocs = {
    name: "reshape",
    category: "Matrix",
    syntax: ["reshape(x, sizes)"],
    description: "Reshape a multi dimensional array to fit the specified dimensions.",
    examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])"],
    seealso: ["size", "squeeze", "resize"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
  var resizeDocs = {
    name: "resize",
    category: "Matrix",
    syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
    description: "Resize a matrix.",
    examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
    seealso: ["size", "subset", "squeeze", "reshape"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
  var rotateDocs = {
    name: "rotate",
    category: "Matrix",
    syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
    description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: ["rotate([1, 0], math.pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
    seealso: ["matrix", "rotationMatrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
  var rotationMatrixDocs = {
    name: "rotationMatrix",
    category: "Matrix",
    syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
    description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
    seealso: ["cos", "sin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
  var rowDocs = {
    name: "row",
    category: "Matrix",
    syntax: ["row(x, index)"],
    description: "Return a row from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
    seealso: ["column", "matrixFromRows"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
  var sizeDocs = {
    name: "size",
    category: "Matrix",
    syntax: ["size(x)"],
    description: "Calculate the size of a matrix.",
    examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
    seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
  var sortDocs = {
    name: "sort",
    category: "Matrix",
    syntax: ["sort(x)", "sort(x, compare)"],
    description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
    examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"])', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
    seealso: ["map", "filter", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
  var squeezeDocs = {
    name: "squeeze",
    category: "Matrix",
    syntax: ["squeeze(x)"],
    description: "Remove inner and outer singleton dimensions from a matrix.",
    examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
  var subsetDocs = {
    name: "subset",
    category: "Matrix",
    syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
    description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
    examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
  var traceDocs = {
    name: "trace",
    category: "Matrix",
    syntax: ["trace(A)"],
    description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
    examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
  var transposeDocs = {
    name: "transpose",
    category: "Matrix",
    syntax: ["x'", "transpose(x)"],
    description: "Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
  var zerosDocs = {
    name: "zeros",
    category: "Matrix",
    syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
    description: "Create a matrix containing zeros.",
    examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
  var fftDocs = {
    name: "fft",
    category: "Matrix",
    syntax: ["fft(x)"],
    description: "Calculate N-dimensional fourier transform",
    examples: ["fft([[1, 0], [1, 0]])"],
    seealso: ["ifft"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
  var ifftDocs = {
    name: "ifft",
    category: "Matrix",
    syntax: ["ifft(x)"],
    description: "Calculate N-dimensional inverse fourier transform",
    examples: ["ifft([[2, 2], [0, 0]])"],
    seealso: ["fft"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
  var combinationsDocs = {
    name: "combinations",
    category: "Probability",
    syntax: ["combinations(n, k)"],
    description: "Compute the number of combinations of n items taken k at a time",
    examples: ["combinations(7, 5)"],
    seealso: ["combinationsWithRep", "permutations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
  var combinationsWithRepDocs = {
    name: "combinationsWithRep",
    category: "Probability",
    syntax: ["combinationsWithRep(n, k)"],
    description: "Compute the number of combinations of n items taken k at a time with replacements.",
    examples: ["combinationsWithRep(7, 5)"],
    seealso: ["combinations", "permutations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
  var factorialDocs = {
    name: "factorial",
    category: "Probability",
    syntax: ["n!", "factorial(n)"],
    description: "Compute the factorial of a value",
    examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
    seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
  var gammaDocs = {
    name: "gamma",
    category: "Probability",
    syntax: ["gamma(n)"],
    description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
    examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
    seealso: ["factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
  var lgammaDocs = {
    name: "lgamma",
    category: "Probability",
    syntax: ["lgamma(n)"],
    description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
    examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(math.i)", "lgamma(complex(1.1, 2))"],
    seealso: ["gamma"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
  var kldivergenceDocs = {
    name: "kldivergence",
    category: "Probability",
    syntax: ["kldivergence(x, y)"],
    description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
    examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
  var multinomialDocs = {
    name: "multinomial",
    category: "Probability",
    syntax: ["multinomial(A)"],
    description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
    examples: ["multinomial([1, 2, 1])"],
    seealso: ["combinations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
  var permutationsDocs = {
    name: "permutations",
    category: "Probability",
    syntax: ["permutations(n)", "permutations(n, k)"],
    description: "Compute the number of permutations of n items taken k at a time",
    examples: ["permutations(5)", "permutations(5, 3)"],
    seealso: ["combinations", "combinationsWithRep", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
  var pickRandomDocs = {
    name: "pickRandom",
    category: "Probability",
    syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
    description: "Pick a random entry from a given array.",
    examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
    seealso: ["random", "randomInt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
  var randomDocs = {
    name: "random",
    category: "Probability",
    syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
    description: "Return a random number.",
    examples: ["random()", "random(10, 20)", "random([2, 3])"],
    seealso: ["pickRandom", "randomInt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
  var randomIntDocs = {
    name: "randomInt",
    category: "Probability",
    syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
    description: "Return a random integer number",
    examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
    seealso: ["pickRandom", "random"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
  var compareDocs = {
    name: "compare",
    category: "Relational",
    syntax: ["compare(x, y)"],
    description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
  var compareNaturalDocs = {
    name: "compareNatural",
    category: "Relational",
    syntax: ["compareNatural(x, y)"],
    description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
  var compareTextDocs = {
    name: "compareText",
    category: "Relational",
    syntax: ["compareText(x, y)"],
    description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
    seealso: ["compare", "compareNatural"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
  var deepEqualDocs = {
    name: "deepEqual",
    category: "Relational",
    syntax: ["deepEqual(x, y)"],
    description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
    examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
    seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
  var equalDocs = {
    name: "equal",
    category: "Relational",
    syntax: ["x == y", "equal(x, y)"],
    description: "Check equality of two values. Returns true if the values are equal, and false if not.",
    examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
    seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
  var equalTextDocs = {
    name: "equalText",
    category: "Relational",
    syntax: ["equalText(x, y)"],
    description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
    examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
    seealso: ["compare", "compareNatural", "compareText", "equal"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
  var largerDocs = {
    name: "larger",
    category: "Relational",
    syntax: ["x > y", "larger(x, y)"],
    description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
    examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
  var largerEqDocs = {
    name: "largerEq",
    category: "Relational",
    syntax: ["x >= y", "largerEq(x, y)"],
    description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
    examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
    seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
  var smallerDocs = {
    name: "smaller",
    category: "Relational",
    syntax: ["x < y", "smaller(x, y)"],
    description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
    seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
  var smallerEqDocs = {
    name: "smallerEq",
    category: "Relational",
    syntax: ["x <= y", "smallerEq(x, y)"],
    description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
    seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
  var unequalDocs = {
    name: "unequal",
    category: "Relational",
    syntax: ["x != y", "unequal(x, y)"],
    description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
    examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
    seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
  var setCartesianDocs = {
    name: "setCartesian",
    category: "Set",
    syntax: ["setCartesian(set1, set2)"],
    description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
    examples: ["setCartesian([1, 2], [3, 4])"],
    seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
  var setDifferenceDocs = {
    name: "setDifference",
    category: "Set",
    syntax: ["setDifference(set1, set2)"],
    description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setIntersect", "setSymDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
  var setDistinctDocs = {
    name: "setDistinct",
    category: "Set",
    syntax: ["setDistinct(set)"],
    description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
    seealso: ["setMultiplicity"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
  var setIntersectDocs = {
    name: "setIntersect",
    category: "Set",
    syntax: ["setIntersect(set1, set2)"],
    description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
  var setIsSubsetDocs = {
    name: "setIsSubset",
    category: "Set",
    syntax: ["setIsSubset(set1, set2)"],
    description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
  var setMultiplicityDocs = {
    name: "setMultiplicity",
    category: "Set",
    syntax: ["setMultiplicity(element, set)"],
    description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
    seealso: ["setDistinct", "setSize"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
  var setPowersetDocs = {
    name: "setPowerset",
    category: "Set",
    syntax: ["setPowerset(set)"],
    description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setPowerset([1, 2, 3])"],
    seealso: ["setCartesian"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
  var setSizeDocs = {
    name: "setSize",
    category: "Set",
    syntax: ["setSize(set)", "setSize(set, unique)"],
    description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
  var setSymDifferenceDocs = {
    name: "setSymDifference",
    category: "Set",
    syntax: ["setSymDifference(set1, set2)"],
    description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
  var setUnionDocs = {
    name: "setUnion",
    category: "Set",
    syntax: ["setUnion(set1, set2)"],
    description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
  var erfDocs = {
    name: "erf",
    category: "Special",
    syntax: ["erf(x)"],
    description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
    examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
  var madDocs = {
    name: "mad",
    category: "Statistics",
    syntax: ["mad(a, b, c, ...)", "mad(A)"],
    description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
    examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
    seealso: ["mean", "median", "std", "abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
  var maxDocs = {
    name: "max",
    category: "Statistics",
    syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dim)"],
    description: "Compute the maximum value of a list of values.",
    examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
    seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
  var meanDocs = {
    name: "mean",
    category: "Statistics",
    syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dim)"],
    description: "Compute the arithmetic mean of a list of values.",
    examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
    seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
  var medianDocs = {
    name: "median",
    category: "Statistics",
    syntax: ["median(a, b, c, ...)", "median(A)"],
    description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
    examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
    seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
  var minDocs = {
    name: "min",
    category: "Statistics",
    syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dim)"],
    description: "Compute the minimum value of a list of values.",
    examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
    seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
  var modeDocs = {
    name: "mode",
    category: "Statistics",
    syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
    description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
    examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
    seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
  var prodDocs = {
    name: "prod",
    category: "Statistics",
    syntax: ["prod(a, b, c, ...)", "prod(A)"],
    description: "Compute the product of all values.",
    examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
    seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
  var quantileSeqDocs = {
    name: "quantileSeq",
    category: "Statistics",
    syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
    description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
    examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
    seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
  var stdDocs = {
    name: "std",
    category: "Statistics",
    syntax: ["std(a, b, c, ...)", "std(A)", "std(A, normalization)"],
    description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
    seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
  var cumSumDocs = {
    name: "cumsum",
    category: "Statistics",
    syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
    description: "Compute the cumulative sum of all values.",
    examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
  var sumDocs = {
    name: "sum",
    category: "Statistics",
    syntax: ["sum(a, b, c, ...)", "sum(A)"],
    description: "Compute the sum of all values.",
    examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
  var varianceDocs = {
    name: "variance",
    category: "Statistics",
    syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, normalization)"],
    description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
  var acosDocs = {
    name: "acos",
    category: "Trigonometry",
    syntax: ["acos(x)"],
    description: "Compute the inverse cosine of a value in radians.",
    examples: ["acos(0.5)", "acos(cos(2.3))"],
    seealso: ["cos", "atan", "asin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
  var acoshDocs = {
    name: "acosh",
    category: "Trigonometry",
    syntax: ["acosh(x)"],
    description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
    examples: ["acosh(1.5)"],
    seealso: ["cosh", "asinh", "atanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
  var acotDocs = {
    name: "acot",
    category: "Trigonometry",
    syntax: ["acot(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
    seealso: ["cot", "atan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
  var acothDocs = {
    name: "acoth",
    category: "Trigonometry",
    syntax: ["acoth(x)"],
    description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
    examples: ["acoth(2)", "acoth(0.5)"],
    seealso: ["acsch", "asech"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
  var acscDocs = {
    name: "acsc",
    category: "Trigonometry",
    syntax: ["acsc(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
    seealso: ["csc", "asin", "asec"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
  var acschDocs = {
    name: "acsch",
    category: "Trigonometry",
    syntax: ["acsch(x)"],
    description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
    examples: ["acsch(0.5)"],
    seealso: ["asech", "acoth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
  var asecDocs = {
    name: "asec",
    category: "Trigonometry",
    syntax: ["asec(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
    seealso: ["acos", "acot", "acsc"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
  var asechDocs = {
    name: "asech",
    category: "Trigonometry",
    syntax: ["asech(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asech(0.5)"],
    seealso: ["acsch", "acoth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
  var asinDocs = {
    name: "asin",
    category: "Trigonometry",
    syntax: ["asin(x)"],
    description: "Compute the inverse sine of a value in radians.",
    examples: ["asin(0.5)", "asin(sin(0.5))"],
    seealso: ["sin", "acos", "atan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
  var asinhDocs = {
    name: "asinh",
    category: "Trigonometry",
    syntax: ["asinh(x)"],
    description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
    examples: ["asinh(0.5)"],
    seealso: ["acosh", "atanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
  var atanDocs = {
    name: "atan",
    category: "Trigonometry",
    syntax: ["atan(x)"],
    description: "Compute the inverse tangent of a value in radians.",
    examples: ["atan(0.5)", "atan(tan(0.5))"],
    seealso: ["tan", "acos", "asin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
  var atan2Docs = {
    name: "atan2",
    category: "Trigonometry",
    syntax: ["atan2(y, x)"],
    description: "Computes the principal value of the arc tangent of y/x in radians.",
    examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
    seealso: ["sin", "cos", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
  var atanhDocs = {
    name: "atanh",
    category: "Trigonometry",
    syntax: ["atanh(x)"],
    description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
    examples: ["atanh(0.5)"],
    seealso: ["acosh", "asinh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
  var cosDocs = {
    name: "cos",
    category: "Trigonometry",
    syntax: ["cos(x)"],
    description: "Compute the cosine of x in radians.",
    examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
    seealso: ["acos", "sin", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
  var coshDocs = {
    name: "cosh",
    category: "Trigonometry",
    syntax: ["cosh(x)"],
    description: "Compute the hyperbolic cosine of x in radians.",
    examples: ["cosh(0.5)"],
    seealso: ["sinh", "tanh", "coth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
  var cotDocs = {
    name: "cot",
    category: "Trigonometry",
    syntax: ["cot(x)"],
    description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
    examples: ["cot(2)", "1 / tan(2)"],
    seealso: ["sec", "csc", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
  var cothDocs = {
    name: "coth",
    category: "Trigonometry",
    syntax: ["coth(x)"],
    description: "Compute the hyperbolic cotangent of x in radians.",
    examples: ["coth(2)", "1 / tanh(2)"],
    seealso: ["sech", "csch", "tanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
  var cscDocs = {
    name: "csc",
    category: "Trigonometry",
    syntax: ["csc(x)"],
    description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
    examples: ["csc(2)", "1 / sin(2)"],
    seealso: ["sec", "cot", "sin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
  var cschDocs = {
    name: "csch",
    category: "Trigonometry",
    syntax: ["csch(x)"],
    description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
    examples: ["csch(2)", "1 / sinh(2)"],
    seealso: ["sech", "coth", "sinh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
  var secDocs = {
    name: "sec",
    category: "Trigonometry",
    syntax: ["sec(x)"],
    description: "Compute the secant of x in radians. Defined as 1/cos(x)",
    examples: ["sec(2)", "1 / cos(2)"],
    seealso: ["cot", "csc", "cos"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
  var sechDocs = {
    name: "sech",
    category: "Trigonometry",
    syntax: ["sech(x)"],
    description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
    examples: ["sech(2)", "1 / cosh(2)"],
    seealso: ["coth", "csch", "cosh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
  var sinDocs = {
    name: "sin",
    category: "Trigonometry",
    syntax: ["sin(x)"],
    description: "Compute the sine of x in radians.",
    examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
    seealso: ["asin", "cos", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
  var sinhDocs = {
    name: "sinh",
    category: "Trigonometry",
    syntax: ["sinh(x)"],
    description: "Compute the hyperbolic sine of x in radians.",
    examples: ["sinh(0.5)"],
    seealso: ["cosh", "tanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
  var tanDocs = {
    name: "tan",
    category: "Trigonometry",
    syntax: ["tan(x)"],
    description: "Compute the tangent of x in radians.",
    examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
    seealso: ["atan", "sin", "cos"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
  var tanhDocs = {
    name: "tanh",
    category: "Trigonometry",
    syntax: ["tanh(x)"],
    description: "Compute the hyperbolic tangent of x in radians.",
    examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
    seealso: ["sinh", "cosh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
  var toDocs = {
    name: "to",
    category: "Units",
    syntax: ["x to unit", "to(x, unit)"],
    description: "Change the unit of a value.",
    examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
  var binDocs = {
    name: "bin",
    category: "Utils",
    syntax: ["bin(value)"],
    description: "Format a number as binary",
    examples: ["bin(2)"],
    seealso: ["oct", "hex"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
  var cloneDocs = {
    name: "clone",
    category: "Utils",
    syntax: ["clone(x)"],
    description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
    examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
  var formatDocs = {
    name: "format",
    category: "Utils",
    syntax: ["format(value)", "format(value, precision)"],
    description: "Format a value of any type as string.",
    examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
    seealso: ["print"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
  var hasNumericValueDocs = {
    name: "hasNumericValue",
    category: "Utils",
    syntax: ["hasNumericValue(x)"],
    description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
    examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
    seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
  var hexDocs = {
    name: "hex",
    category: "Utils",
    syntax: ["hex(value)"],
    description: "Format a number as hexadecimal",
    examples: ["hex(240)"],
    seealso: ["bin", "oct"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
  var isIntegerDocs = {
    name: "isInteger",
    category: "Utils",
    syntax: ["isInteger(x)"],
    description: "Test whether a value is an integer number.",
    examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
  var isNaNDocs = {
    name: "isNaN",
    category: "Utils",
    syntax: ["isNaN(x)"],
    description: "Test whether a value is NaN (not a number)",
    examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
  var isNegativeDocs = {
    name: "isNegative",
    category: "Utils",
    syntax: ["isNegative(x)"],
    description: "Test whether a value is negative: smaller than zero.",
    examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
    seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
  var isNumericDocs = {
    name: "isNumeric",
    category: "Utils",
    syntax: ["isNumeric(x)"],
    description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
    examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
    seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
  var isPositiveDocs = {
    name: "isPositive",
    category: "Utils",
    syntax: ["isPositive(x)"],
    description: "Test whether a value is positive: larger than zero.",
    examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
  var isPrimeDocs = {
    name: "isPrime",
    category: "Utils",
    syntax: ["isPrime(x)"],
    description: "Test whether a value is prime: has no divisors other than itself and one.",
    examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
  var isZeroDocs = {
    name: "isZero",
    category: "Utils",
    syntax: ["isZero(x)"],
    description: "Test whether a value is zero.",
    examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
  var numericDocs = {
    name: "numeric",
    category: "Utils",
    syntax: ["numeric(x)"],
    description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
    examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction)', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number)'],
    seealso: ["number", "fraction", "bignumber", "string", "format"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
  var octDocs = {
    name: "oct",
    category: "Utils",
    syntax: ["oct(value)"],
    description: "Format a number as octal",
    examples: ["oct(56)"],
    seealso: ["bin", "hex"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
  var printDocs = {
    name: "print",
    category: "Utils",
    syntax: ["print(template, values)", "print(template, values, precision)"],
    description: "Interpolate values into a string template.",
    examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $0, $1, $2", [6, 9, 4])'],
    seealso: ["format"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
  var typeOfDocs = {
    name: "typeOf",
    category: "Utils",
    syntax: ["typeOf(x)"],
    description: "Get the type of a variable.",
    examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
    seealso: ["getMatrixDataType"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
  var embeddedDocs = {
    bignumber: bignumberDocs,
    boolean: booleanDocs,
    complex: complexDocs,
    createUnit: createUnitDocs,
    fraction: fractionDocs,
    index: indexDocs,
    matrix: matrixDocs,
    number: numberDocs,
    sparse: sparseDocs,
    splitUnit: splitUnitDocs,
    string: stringDocs,
    unit: unitDocs,
    e: eDocs,
    E: eDocs,
    false: falseDocs,
    i: iDocs,
    Infinity: InfinityDocs,
    LN2: LN2Docs,
    LN10: LN10Docs,
    LOG2E: LOG2EDocs,
    LOG10E: LOG10EDocs,
    NaN: NaNDocs,
    null: nullDocs,
    pi: piDocs,
    PI: piDocs,
    phi: phiDocs,
    SQRT1_2: SQRT12Docs,
    SQRT2: SQRT2Docs,
    tau: tauDocs,
    true: trueDocs,
    version: versionDocs,
    speedOfLight: {
      description: "Speed of light in vacuum",
      examples: ["speedOfLight"]
    },
    gravitationConstant: {
      description: "Newtonian constant of gravitation",
      examples: ["gravitationConstant"]
    },
    planckConstant: {
      description: "Planck constant",
      examples: ["planckConstant"]
    },
    reducedPlanckConstant: {
      description: "Reduced Planck constant",
      examples: ["reducedPlanckConstant"]
    },
    magneticConstant: {
      description: "Magnetic constant (vacuum permeability)",
      examples: ["magneticConstant"]
    },
    electricConstant: {
      description: "Electric constant (vacuum permeability)",
      examples: ["electricConstant"]
    },
    vacuumImpedance: {
      description: "Characteristic impedance of vacuum",
      examples: ["vacuumImpedance"]
    },
    coulomb: {
      description: "Coulomb's constant",
      examples: ["coulomb"]
    },
    elementaryCharge: {
      description: "Elementary charge",
      examples: ["elementaryCharge"]
    },
    bohrMagneton: {
      description: "Borh magneton",
      examples: ["bohrMagneton"]
    },
    conductanceQuantum: {
      description: "Conductance quantum",
      examples: ["conductanceQuantum"]
    },
    inverseConductanceQuantum: {
      description: "Inverse conductance quantum",
      examples: ["inverseConductanceQuantum"]
    },
    magneticFluxQuantum: {
      description: "Magnetic flux quantum",
      examples: ["magneticFluxQuantum"]
    },
    nuclearMagneton: {
      description: "Nuclear magneton",
      examples: ["nuclearMagneton"]
    },
    klitzing: {
      description: "Von Klitzing constant",
      examples: ["klitzing"]
    },
    bohrRadius: {
      description: "Borh radius",
      examples: ["bohrRadius"]
    },
    classicalElectronRadius: {
      description: "Classical electron radius",
      examples: ["classicalElectronRadius"]
    },
    electronMass: {
      description: "Electron mass",
      examples: ["electronMass"]
    },
    fermiCoupling: {
      description: "Fermi coupling constant",
      examples: ["fermiCoupling"]
    },
    fineStructure: {
      description: "Fine-structure constant",
      examples: ["fineStructure"]
    },
    hartreeEnergy: {
      description: "Hartree energy",
      examples: ["hartreeEnergy"]
    },
    protonMass: {
      description: "Proton mass",
      examples: ["protonMass"]
    },
    deuteronMass: {
      description: "Deuteron Mass",
      examples: ["deuteronMass"]
    },
    neutronMass: {
      description: "Neutron mass",
      examples: ["neutronMass"]
    },
    quantumOfCirculation: {
      description: "Quantum of circulation",
      examples: ["quantumOfCirculation"]
    },
    rydberg: {
      description: "Rydberg constant",
      examples: ["rydberg"]
    },
    thomsonCrossSection: {
      description: "Thomson cross section",
      examples: ["thomsonCrossSection"]
    },
    weakMixingAngle: {
      description: "Weak mixing angle",
      examples: ["weakMixingAngle"]
    },
    efimovFactor: {
      description: "Efimov factor",
      examples: ["efimovFactor"]
    },
    atomicMass: {
      description: "Atomic mass constant",
      examples: ["atomicMass"]
    },
    avogadro: {
      description: "Avogadro's number",
      examples: ["avogadro"]
    },
    boltzmann: {
      description: "Boltzmann constant",
      examples: ["boltzmann"]
    },
    faraday: {
      description: "Faraday constant",
      examples: ["faraday"]
    },
    firstRadiation: {
      description: "First radiation constant",
      examples: ["firstRadiation"]
    },
    loschmidt: {
      description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
      examples: ["loschmidt"]
    },
    gasConstant: {
      description: "Gas constant",
      examples: ["gasConstant"]
    },
    molarPlanckConstant: {
      description: "Molar Planck constant",
      examples: ["molarPlanckConstant"]
    },
    molarVolume: {
      description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
      examples: ["molarVolume"]
    },
    sackurTetrode: {
      description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
      examples: ["sackurTetrode"]
    },
    secondRadiation: {
      description: "Second radiation constant",
      examples: ["secondRadiation"]
    },
    stefanBoltzmann: {
      description: "Stefan-Boltzmann constant",
      examples: ["stefanBoltzmann"]
    },
    wienDisplacement: {
      description: "Wien displacement law constant",
      examples: ["wienDisplacement"]
    },
    molarMass: {
      description: "Molar mass constant",
      examples: ["molarMass"]
    },
    molarMassC12: {
      description: "Molar mass constant of carbon-12",
      examples: ["molarMassC12"]
    },
    gravity: {
      description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
      examples: ["gravity"]
    },
    planckLength: {
      description: "Planck length",
      examples: ["planckLength"]
    },
    planckMass: {
      description: "Planck mass",
      examples: ["planckMass"]
    },
    planckTime: {
      description: "Planck time",
      examples: ["planckTime"]
    },
    planckCharge: {
      description: "Planck charge",
      examples: ["planckCharge"]
    },
    planckTemperature: {
      description: "Planck temperature",
      examples: ["planckTemperature"]
    },
    derivative: derivativeDocs,
    lsolve: lsolveDocs,
    lsolveAll: lsolveAllDocs,
    lup: lupDocs,
    lusolve: lusolveDocs,
    leafCount: leafCountDocs,
    resolve: resolveDocs,
    simplify: simplifyDocs,
    simplifyConstant: simplifyConstantDocs,
    simplifyCore: simplifyCoreDocs,
    symbolicEqual: symbolicEqualDocs,
    rationalize: rationalizeDocs,
    slu: sluDocs,
    usolve: usolveDocs,
    usolveAll: usolveAllDocs,
    qr: qrDocs,
    abs: absDocs,
    add: addDocs,
    cbrt: cbrtDocs,
    ceil: ceilDocs,
    cube: cubeDocs,
    divide: divideDocs,
    dotDivide: dotDivideDocs,
    dotMultiply: dotMultiplyDocs,
    dotPow: dotPowDocs,
    exp: expDocs,
    expm: expmDocs,
    expm1: expm1Docs,
    fix: fixDocs,
    floor: floorDocs,
    gcd: gcdDocs,
    hypot: hypotDocs,
    lcm: lcmDocs,
    log: logDocs,
    log2: log2Docs,
    log1p: log1pDocs,
    log10: log10Docs,
    mod: modDocs,
    multiply: multiplyDocs,
    norm: normDocs,
    nthRoot: nthRootDocs,
    nthRoots: nthRootsDocs,
    pow: powDocs,
    round: roundDocs,
    sign: signDocs,
    sqrt: sqrtDocs,
    sqrtm: sqrtmDocs,
    square: squareDocs,
    subtract: subtractDocs,
    unaryMinus: unaryMinusDocs,
    unaryPlus: unaryPlusDocs,
    xgcd: xgcdDocs,
    invmod: invmodDocs,
    bitAnd: bitAndDocs,
    bitNot: bitNotDocs,
    bitOr: bitOrDocs,
    bitXor: bitXorDocs,
    leftShift: leftShiftDocs,
    rightArithShift: rightArithShiftDocs,
    rightLogShift: rightLogShiftDocs,
    bellNumbers: bellNumbersDocs,
    catalan: catalanDocs,
    composition: compositionDocs,
    stirlingS2: stirlingS2Docs,
    config: configDocs,
    import: importDocs,
    typed: typedDocs,
    arg: argDocs,
    conj: conjDocs,
    re: reDocs,
    im: imDocs,
    evaluate: evaluateDocs,
    help: helpDocs,
    distance: distanceDocs,
    intersect: intersectDocs,
    and: andDocs,
    not: notDocs,
    or: orDocs,
    xor: xorDocs,
    concat: concatDocs,
    count: countDocs,
    cross: crossDocs,
    column: columnDocs,
    ctranspose: ctransposeDocs,
    det: detDocs,
    diag: diagDocs,
    diff: diffDocs,
    dot: dotDocs,
    getMatrixDataType: getMatrixDataTypeDocs,
    identity: identityDocs,
    filter: filterDocs,
    flatten: flattenDocs,
    forEach: forEachDocs,
    inv: invDocs,
    pinv: pinvDocs,
    eigs: eigsDocs,
    kron: kronDocs,
    matrixFromFunction: matrixFromFunctionDocs,
    matrixFromRows: matrixFromRowsDocs,
    matrixFromColumns: matrixFromColumnsDocs,
    map: mapDocs,
    ones: onesDocs,
    partitionSelect: partitionSelectDocs,
    range: rangeDocs,
    resize: resizeDocs,
    reshape: reshapeDocs,
    rotate: rotateDocs,
    rotationMatrix: rotationMatrixDocs,
    row: rowDocs,
    size: sizeDocs,
    sort: sortDocs,
    squeeze: squeezeDocs,
    subset: subsetDocs,
    trace: traceDocs,
    transpose: transposeDocs,
    zeros: zerosDocs,
    fft: fftDocs,
    ifft: ifftDocs,
    combinations: combinationsDocs,
    combinationsWithRep: combinationsWithRepDocs,
    factorial: factorialDocs,
    gamma: gammaDocs,
    kldivergence: kldivergenceDocs,
    lgamma: lgammaDocs,
    multinomial: multinomialDocs,
    permutations: permutationsDocs,
    pickRandom: pickRandomDocs,
    random: randomDocs,
    randomInt: randomIntDocs,
    compare: compareDocs,
    compareNatural: compareNaturalDocs,
    compareText: compareTextDocs,
    deepEqual: deepEqualDocs,
    equal: equalDocs,
    equalText: equalTextDocs,
    larger: largerDocs,
    largerEq: largerEqDocs,
    smaller: smallerDocs,
    smallerEq: smallerEqDocs,
    unequal: unequalDocs,
    setCartesian: setCartesianDocs,
    setDifference: setDifferenceDocs,
    setDistinct: setDistinctDocs,
    setIntersect: setIntersectDocs,
    setIsSubset: setIsSubsetDocs,
    setMultiplicity: setMultiplicityDocs,
    setPowerset: setPowersetDocs,
    setSize: setSizeDocs,
    setSymDifference: setSymDifferenceDocs,
    setUnion: setUnionDocs,
    erf: erfDocs,
    cumsum: cumSumDocs,
    mad: madDocs,
    max: maxDocs,
    mean: meanDocs,
    median: medianDocs,
    min: minDocs,
    mode: modeDocs,
    prod: prodDocs,
    quantileSeq: quantileSeqDocs,
    std: stdDocs,
    sum: sumDocs,
    variance: varianceDocs,
    acos: acosDocs,
    acosh: acoshDocs,
    acot: acotDocs,
    acoth: acothDocs,
    acsc: acscDocs,
    acsch: acschDocs,
    asec: asecDocs,
    asech: asechDocs,
    asin: asinDocs,
    asinh: asinhDocs,
    atan: atanDocs,
    atanh: atanhDocs,
    atan2: atan2Docs,
    cos: cosDocs,
    cosh: coshDocs,
    cot: cotDocs,
    coth: cothDocs,
    csc: cscDocs,
    csch: cschDocs,
    sec: secDocs,
    sech: sechDocs,
    sin: sinDocs,
    sinh: sinhDocs,
    tan: tanDocs,
    tanh: tanhDocs,
    to: toDocs,
    clone: cloneDocs,
    format: formatDocs,
    bin: binDocs,
    oct: octDocs,
    hex: hexDocs,
    isNaN: isNaNDocs,
    isInteger: isIntegerDocs,
    isNegative: isNegativeDocs,
    isNumeric: isNumericDocs,
    hasNumericValue: hasNumericValueDocs,
    isPositive: isPositiveDocs,
    isPrime: isPrimeDocs,
    isZero: isZeroDocs,
    print: printDocs,
    typeOf: typeOfDocs,
    numeric: numericDocs
  };

  // node_modules/mathjs/lib/esm/expression/function/help.js
  var name234 = "help";
  var dependencies235 = ["typed", "mathWithTransform", "Help"];
  var createHelp = /* @__PURE__ */ factory(name234, dependencies235, (_ref) => {
    var {
      typed,
      mathWithTransform,
      Help
    } = _ref;
    return typed(name234, {
      any: function any(search) {
        var prop;
        var searchName = search;
        if (typeof search !== "string") {
          for (prop in mathWithTransform) {
            if (hasOwnProperty2(mathWithTransform, prop) && search === mathWithTransform[prop]) {
              searchName = prop;
              break;
            }
          }
        }
        var doc = getSafeProperty(embeddedDocs, searchName);
        if (!doc) {
          var searchText = typeof searchName === "function" ? searchName.name : searchName;
          throw new Error('No documentation found on "' + searchText + '"');
        }
        return new Help(doc);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/chain/function/chain.js
  var name235 = "chain";
  var dependencies236 = ["typed", "Chain"];
  var createChain = /* @__PURE__ */ factory(name235, dependencies236, (_ref) => {
    var {
      typed,
      Chain
    } = _ref;
    return typed(name235, {
      "": function _() {
        return new Chain();
      },
      any: function any(value) {
        return new Chain(value);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/det.js
  var name236 = "det";
  var dependencies237 = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
  var createDet = /* @__PURE__ */ factory(name236, dependencies237, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      multiply,
      divideScalar,
      isZero,
      unaryMinus
    } = _ref;
    return typed(name236, {
      any: function any(x) {
        return clone(x);
      },
      "Array | Matrix": function det(x) {
        var size;
        if (isMatrix(x)) {
          size = x.size();
        } else if (Array.isArray(x)) {
          x = matrix(x);
          size = x.size();
        } else {
          size = [];
        }
        switch (size.length) {
          case 0:
            return clone(x);
          case 1:
            if (size[0] === 1) {
              return clone(x.valueOf()[0]);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          case 2: {
            var rows = size[0];
            var cols = size[1];
            if (rows === cols) {
              return _det(x.clone().valueOf(), rows, cols);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
        }
      }
    });
    function _det(matrix2, rows, cols) {
      if (rows === 1) {
        return clone(matrix2[0][0]);
      } else if (rows === 2) {
        return subtract(multiply(matrix2[0][0], matrix2[1][1]), multiply(matrix2[1][0], matrix2[0][1]));
      } else {
        var negated = false;
        var rowIndices = new Array(rows).fill(0).map((_, i2) => i2);
        for (var k = 0; k < rows; k++) {
          var k_ = rowIndices[k];
          if (isZero(matrix2[k_][k])) {
            var _k = void 0;
            for (_k = k + 1; _k < rows; _k++) {
              if (!isZero(matrix2[rowIndices[_k]][k])) {
                k_ = rowIndices[_k];
                rowIndices[_k] = rowIndices[k];
                rowIndices[k] = k_;
                negated = !negated;
                break;
              }
            }
            if (_k === rows)
              return matrix2[k_][k];
          }
          var piv = matrix2[k_][k];
          var piv_ = k === 0 ? 1 : matrix2[rowIndices[k - 1]][k - 1];
          for (var i = k + 1; i < rows; i++) {
            var i_ = rowIndices[i];
            for (var j = k + 1; j < rows; j++) {
              matrix2[i_][j] = divideScalar(subtract(multiply(matrix2[i_][j], piv), multiply(matrix2[i_][k], matrix2[k_][j])), piv_);
            }
          }
        }
        var det = matrix2[rowIndices[rows - 1]][rows - 1];
        return negated ? unaryMinus(det) : det;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/inv.js
  var name237 = "inv";
  var dependencies238 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
  var createInv = /* @__PURE__ */ factory(name237, dependencies238, (_ref) => {
    var {
      typed,
      matrix,
      divideScalar,
      addScalar,
      multiply,
      unaryMinus,
      det,
      identity,
      abs: abs2
    } = _ref;
    return typed(name237, {
      "Array | Matrix": function ArrayMatrix(x) {
        var size = isMatrix(x) ? x.size() : arraySize(x);
        switch (size.length) {
          case 1:
            if (size[0] === 1) {
              if (isMatrix(x)) {
                return matrix([divideScalar(1, x.valueOf()[0])]);
              } else {
                return [divideScalar(1, x[0])];
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          case 2: {
            var rows = size[0];
            var cols = size[1];
            if (rows === cols) {
              if (isMatrix(x)) {
                return matrix(_inv(x.valueOf(), rows, cols), x.storage());
              } else {
                return _inv(x, rows, cols);
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
        }
      },
      any: function any(x) {
        return divideScalar(1, x);
      }
    });
    function _inv(mat, rows, cols) {
      var r, s, f, value, temp;
      if (rows === 1) {
        value = mat[0][0];
        if (value === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar(1, value)]];
      } else if (rows === 2) {
        var d = det(mat);
        if (d === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
      } else {
        var A = mat.concat();
        for (r = 0; r < rows; r++) {
          A[r] = A[r].concat();
        }
        var B = identity(rows).valueOf();
        for (var c = 0; c < cols; c++) {
          var ABig = abs2(A[c][c]);
          var rBig = c;
          r = c + 1;
          while (r < rows) {
            if (abs2(A[r][c]) > ABig) {
              ABig = abs2(A[r][c]);
              rBig = r;
            }
            r++;
          }
          if (ABig === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          r = rBig;
          if (r !== c) {
            temp = A[c];
            A[c] = A[r];
            A[r] = temp;
            temp = B[c];
            B[c] = B[r];
            B[r] = temp;
          }
          var Ac = A[c];
          var Bc = B[c];
          for (r = 0; r < rows; r++) {
            var Ar = A[r];
            var Br = B[r];
            if (r !== c) {
              if (Ar[c] !== 0) {
                f = divideScalar(unaryMinus(Ar[c]), Ac[c]);
                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                }
              }
            } else {
              f = Ac[c];
              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar(Ar[s], f);
              }
              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar(Br[s], f);
              }
            }
          }
        }
        return B;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/pinv.js
  var name238 = "pinv";
  var dependencies239 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
  var createPinv = /* @__PURE__ */ factory(name238, dependencies239, (_ref) => {
    var {
      typed,
      matrix,
      inv,
      deepEqual,
      equal,
      dotDivide,
      dot,
      ctranspose,
      divideScalar,
      multiply,
      add: add2,
      Complex: Complex2
    } = _ref;
    return typed(name238, {
      "Array | Matrix": function ArrayMatrix(x) {
        var size = isMatrix(x) ? x.size() : arraySize(x);
        switch (size.length) {
          case 1:
            if (_isZeros(x))
              return ctranspose(x);
            if (size[0] === 1) {
              return inv(x);
            } else {
              return dotDivide(ctranspose(x), dot(x, x));
            }
          case 2: {
            if (_isZeros(x))
              return ctranspose(x);
            var rows = size[0];
            var cols = size[1];
            if (rows === cols) {
              try {
                return inv(x);
              } catch (err) {
                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
                } else {
                  throw err;
                }
              }
            }
            if (isMatrix(x)) {
              return matrix(_pinv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _pinv(x, rows, cols);
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size) + ")");
        }
      },
      any: function any(x) {
        if (equal(x, 0))
          return clone(x);
        return divideScalar(1, x);
      }
    });
    function _pinv(mat, rows, cols) {
      var {
        C,
        F
      } = _rankFact(mat, rows, cols);
      var Cpinv = multiply(inv(multiply(ctranspose(C), C)), ctranspose(C));
      var Fpinv = multiply(ctranspose(F), inv(multiply(F, ctranspose(F))));
      return multiply(Fpinv, Cpinv);
    }
    function _rref(mat, rows, cols) {
      var M = clone(mat);
      var lead = 0;
      for (var r = 0; r < rows; r++) {
        if (cols <= lead) {
          return M;
        }
        var i = r;
        while (_isZero(M[i][lead])) {
          i++;
          if (rows === i) {
            i = r;
            lead++;
            if (cols === lead) {
              return M;
            }
          }
        }
        [M[i], M[r]] = [M[r], M[i]];
        var val = M[r][lead];
        for (var j = 0; j < cols; j++) {
          M[r][j] = dotDivide(M[r][j], val);
        }
        for (var _i = 0; _i < rows; _i++) {
          if (_i === r)
            continue;
          val = M[_i][lead];
          for (var _j = 0; _j < cols; _j++) {
            M[_i][_j] = add2(M[_i][_j], multiply(-1, multiply(val, M[r][_j])));
          }
        }
        lead++;
      }
      return M;
    }
    function _rankFact(mat, rows, cols) {
      var rref = _rref(mat, rows, cols);
      var C = mat.map((_, i) => _.filter((_2, j) => j < rows && !_isZero(dot(rref[j], rref[j]))));
      var F = rref.filter((_, i) => !_isZero(dot(rref[i], rref[i])));
      return {
        C,
        F
      };
    }
    function _isZero(x) {
      return equal(add2(x, Complex2(1, 1)), add2(0, Complex2(1, 1)));
    }
    function _isZeros(arr) {
      return deepEqual(add2(arr, Complex2(1, 1)), add2(multiply(arr, 0), Complex2(1, 1)));
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
  function createComplexEigs(_ref) {
    var {
      addScalar,
      subtract,
      flatten: flatten2,
      multiply,
      multiplyScalar,
      divideScalar,
      sqrt: sqrt2,
      abs: abs2,
      bignumber,
      diag,
      inv,
      qr,
      usolve,
      usolveAll,
      equal,
      complex,
      larger,
      smaller,
      matrixFromColumns,
      dot
    } = _ref;
    function complexEigs(arr, N, prec, type, findVectors) {
      if (findVectors === void 0) {
        findVectors = true;
      }
      var R = balance(arr, N, prec, type, findVectors);
      reduceToHessenberg(arr, N, prec, type, findVectors, R);
      var {
        values: values2,
        C
      } = iterateUntilTriangular(arr, N, prec, type, findVectors);
      var vectors;
      if (findVectors) {
        vectors = findEigenvectors(arr, N, C, R, values2, prec, type);
        vectors = matrixFromColumns(...vectors);
      }
      return {
        values: values2,
        vectors
      };
    }
    function balance(arr, N, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var realzero = big ? bignumber(0) : 0;
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      var realone = big ? bignumber(1) : 1;
      var radix = big ? bignumber(10) : 2;
      var radixSq = multiplyScalar(radix, radix);
      var Rdiag;
      if (findVectors) {
        Rdiag = Array(N).fill(one);
      }
      var last = false;
      while (!last) {
        last = true;
        for (var i = 0; i < N; i++) {
          var colNorm = realzero;
          var rowNorm = realzero;
          for (var j = 0; j < N; j++) {
            if (i === j)
              continue;
            var c = abs2(arr[i][j]);
            colNorm = addScalar(colNorm, c);
            rowNorm = addScalar(rowNorm, c);
          }
          if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
            var f = realone;
            var _c = colNorm;
            var rowDivRadix = divideScalar(rowNorm, radix);
            var rowMulRadix = multiplyScalar(rowNorm, radix);
            while (smaller(_c, rowDivRadix)) {
              _c = multiplyScalar(_c, radixSq);
              f = multiplyScalar(f, radix);
            }
            while (larger(_c, rowMulRadix)) {
              _c = divideScalar(_c, radixSq);
              f = divideScalar(f, radix);
            }
            var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));
            if (condition) {
              last = false;
              var g = divideScalar(1, f);
              for (var _j = 0; _j < N; _j++) {
                if (i === _j) {
                  continue;
                }
                arr[i][_j] = multiplyScalar(arr[i][_j], f);
                arr[_j][i] = multiplyScalar(arr[_j][i], g);
              }
              if (findVectors) {
                Rdiag[i] = multiplyScalar(Rdiag[i], f);
              }
            }
          }
        }
      }
      return diag(Rdiag);
    }
    function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
      if (big) {
        prec = bignumber(prec);
      }
      for (var i = 0; i < N - 2; i++) {
        var maxIndex = 0;
        var max2 = zero;
        for (var j = i + 1; j < N; j++) {
          var el = arr[j][i];
          if (smaller(abs2(max2), abs2(el))) {
            max2 = el;
            maxIndex = j;
          }
        }
        if (smaller(abs2(max2), prec)) {
          continue;
        }
        if (maxIndex !== i + 1) {
          var tmp1 = arr[maxIndex];
          arr[maxIndex] = arr[i + 1];
          arr[i + 1] = tmp1;
          for (var _j2 = 0; _j2 < N; _j2++) {
            var tmp2 = arr[_j2][maxIndex];
            arr[_j2][maxIndex] = arr[_j2][i + 1];
            arr[_j2][i + 1] = tmp2;
          }
          if (findVectors) {
            var tmp3 = R[maxIndex];
            R[maxIndex] = R[i + 1];
            R[i + 1] = tmp3;
          }
        }
        for (var _j3 = i + 2; _j3 < N; _j3++) {
          var n = divideScalar(arr[_j3][i], max2);
          if (n === 0) {
            continue;
          }
          for (var k = 0; k < N; k++) {
            arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
          }
          for (var _k = 0; _k < N; _k++) {
            arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
          }
          if (findVectors) {
            for (var _k2 = 0; _k2 < N; _k2++) {
              R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
            }
          }
        }
      }
      return R;
    }
    function iterateUntilTriangular(A, N, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      if (big) {
        prec = bignumber(prec);
      }
      var arr = clone(A);
      var lambdas = [];
      var n = N;
      var Sdiag = [];
      var Qtotal = findVectors ? diag(Array(N).fill(one)) : void 0;
      var Qpartial = findVectors ? diag(Array(n).fill(one)) : void 0;
      var lastConvergenceBefore = 0;
      while (lastConvergenceBefore <= 100) {
        lastConvergenceBefore += 1;
        var k = 0;
        for (var i = 0; i < n; i++) {
          arr[i][i] = subtract(arr[i][i], k);
        }
        var {
          Q: Q2,
          R
        } = qr(arr);
        arr = multiply(R, Q2);
        for (var _i = 0; _i < n; _i++) {
          arr[_i][_i] = addScalar(arr[_i][_i], k);
        }
        if (findVectors) {
          Qpartial = multiply(Qpartial, Q2);
        }
        if (n === 1 || smaller(abs2(arr[n - 1][n - 2]), prec)) {
          lastConvergenceBefore = 0;
          lambdas.push(arr[n - 1][n - 1]);
          if (findVectors) {
            Sdiag.unshift([[1]]);
            inflateMatrix(Qpartial, N);
            Qtotal = multiply(Qtotal, Qpartial);
            if (n > 1) {
              Qpartial = diag(Array(n - 1).fill(one));
            }
          }
          n -= 1;
          arr.pop();
          for (var _i2 = 0; _i2 < n; _i2++) {
            arr[_i2].pop();
          }
        } else if (n === 2 || smaller(abs2(arr[n - 2][n - 3]), prec)) {
          lastConvergenceBefore = 0;
          var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
          lambdas.push(...ll);
          if (findVectors) {
            Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
            inflateMatrix(Qpartial, N);
            Qtotal = multiply(Qtotal, Qpartial);
            if (n > 2) {
              Qpartial = diag(Array(n - 2).fill(one));
            }
          }
          n -= 2;
          arr.pop();
          arr.pop();
          for (var _i3 = 0; _i3 < n; _i3++) {
            arr[_i3].pop();
            arr[_i3].pop();
          }
        }
        if (n === 0) {
          break;
        }
      }
      lambdas.sort((a, b) => +subtract(abs2(a), abs2(b)));
      if (lastConvergenceBefore > 100) {
        var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
        err.values = lambdas;
        err.vectors = [];
        throw err;
      }
      var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : void 0;
      return {
        values: lambdas,
        C
      };
    }
    function findEigenvectors(A, N, C, R, values2, prec, type) {
      var Cinv = inv(C);
      var U = multiply(Cinv, A, C);
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      var uniqueValues = [];
      var multiplicities = [];
      for (var \u03BB of values2) {
        var i = indexOf(uniqueValues, \u03BB, equal);
        if (i === -1) {
          uniqueValues.push(\u03BB);
          multiplicities.push(1);
        } else {
          multiplicities[i] += 1;
        }
      }
      var vectors = [];
      var len = uniqueValues.length;
      var b = Array(N).fill(zero);
      var E = diag(Array(N).fill(one));
      var failedLambdas = [];
      var _loop = function _loop2(_i42) {
        var \u03BB2 = uniqueValues[_i42];
        var S = subtract(U, multiply(\u03BB2, E));
        var solutions = usolveAll(S, b);
        solutions.shift();
        while (solutions.length < multiplicities[_i42]) {
          var approxVec = inverseIterate(S, N, solutions, prec, type);
          if (approxVec == null) {
            failedLambdas.push(\u03BB2);
            break;
          }
          solutions.push(approxVec);
        }
        var correction = multiply(inv(R), C);
        solutions = solutions.map((v) => multiply(correction, v));
        vectors.push(...solutions.map((v) => flatten2(v)));
      };
      for (var _i4 = 0; _i4 < len; _i4++) {
        _loop(_i4);
      }
      if (failedLambdas.length !== 0) {
        var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
        err.values = values2;
        err.vectors = vectors;
        throw err;
      }
      return vectors;
    }
    function eigenvalues2x2(a, b, c, d) {
      var trA = addScalar(a, d);
      var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
      var x = multiplyScalar(trA, 0.5);
      var y = multiplyScalar(sqrt2(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
      return [addScalar(x, y), subtract(x, y)];
    }
    function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      if (smaller(abs2(c), prec)) {
        return [[one, zero], [zero, one]];
      }
      if (larger(abs2(subtract(l1, l2)), prec)) {
        return [[subtract(l1, d), subtract(l2, d)], [c, c]];
      }
      var na = subtract(a, l1);
      var nb = subtract(b, l1);
      var nc = subtract(c, l1);
      var nd = subtract(d, l1);
      if (smaller(abs2(nb), prec)) {
        return [[na, one], [nc, zero]];
      } else {
        return [[nb, zero], [nd, one]];
      }
    }
    function inflateMatrix(arr, N) {
      for (var i = 0; i < arr.length; i++) {
        arr[i].push(...Array(N - arr[i].length).fill(0));
      }
      for (var _i5 = arr.length; _i5 < N; _i5++) {
        arr.push(Array(N).fill(0));
        arr[_i5][_i5] = 1;
      }
      return arr;
    }
    function blockDiag(arr, N) {
      var M = [];
      for (var i = 0; i < N; i++) {
        M[i] = Array(N).fill(0);
      }
      var I = 0;
      for (var sub2 of arr) {
        var n = sub2.length;
        for (var _i6 = 0; _i6 < n; _i6++) {
          for (var j = 0; j < n; j++) {
            M[I + _i6][I + j] = sub2[_i6][j];
          }
        }
        I += n;
      }
      return M;
    }
    function indexOf(arr, el, fn) {
      for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i], el)) {
          return i;
        }
      }
      return -1;
    }
    function inverseIterate(A, N, orthog, prec, type) {
      var largeNum = type === "BigNumber" ? bignumber(1e3) : 1e3;
      var b;
      var i = 0;
      while (true) {
        b = randomOrthogonalVector(N, orthog, type);
        b = usolve(A, b);
        if (larger(norm(b), largeNum)) {
          break;
        }
        if (++i >= 5) {
          return null;
        }
      }
      i = 0;
      while (true) {
        var c = usolve(A, b);
        if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
          break;
        }
        if (++i >= 10) {
          return null;
        }
        b = normalize(c);
      }
      return b;
    }
    function randomOrthogonalVector(N, orthog, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
      if (big) {
        v = v.map((n) => bignumber(n));
      }
      if (cplx) {
        v = v.map((n) => complex(n));
      }
      v = orthogonalComplement(v, orthog);
      return normalize(v, type);
    }
    function orthogonalComplement(v, orthog) {
      for (var w of orthog) {
        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
      }
      return v;
    }
    function norm(v) {
      return abs2(sqrt2(dot(v, v)));
    }
    function normalize(v, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      return multiply(divideScalar(one, norm(v)), v);
    }
    return complexEigs;
  }

  // node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
  function createRealSymmetric(_ref) {
    var {
      config: config2,
      addScalar,
      subtract,
      abs: abs2,
      atan: atan3,
      cos: cos2,
      sin: sin2,
      multiplyScalar,
      inv,
      bignumber,
      multiply,
      add: add2
    } = _ref;
    function main(arr, N) {
      var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config2.epsilon;
      var type = arguments.length > 3 ? arguments[3] : void 0;
      if (type === "number") {
        return diag(arr, prec);
      }
      if (type === "BigNumber") {
        return diagBig(arr, prec);
      }
      throw TypeError("Unsupported data type: " + type);
    }
    function diag(x, precision) {
      var N = x.length;
      var e0 = Math.abs(precision / N);
      var psi;
      var Sij = new Array(N);
      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1;
      }
      var Vab = getAij(x);
      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j = Vab[0][1];
        psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
        x = x1(x, psi, _i, j);
        Sij = Sij1(Sij, psi, _i, j);
        Vab = getAij(x);
      }
      var Ei = createArray(N, 0);
      for (var _i2 = 0; _i2 < N; _i2++) {
        Ei[_i2] = x[_i2][_i2];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function diagBig(x, precision) {
      var N = x.length;
      var e0 = abs2(precision / N);
      var psi;
      var Sij = new Array(N);
      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1;
      }
      var Vab = getAijBig(x);
      while (abs2(Vab[1]) >= abs2(e0)) {
        var _i3 = Vab[0][0];
        var j = Vab[0][1];
        psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
        x = x1Big(x, psi, _i3, j);
        Sij = Sij1Big(Sij, psi, _i3, j);
        Vab = getAijBig(x);
      }
      var Ei = createArray(N, 0);
      for (var _i4 = 0; _i4 < N; _i4++) {
        Ei[_i4] = x[_i4][_i4];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;
      if (Math.abs(denom) <= config2.epsilon) {
        return Math.PI / 4;
      } else {
        return 0.5 * Math.atan(2 * aij / (ajj - aii));
      }
    }
    function getThetaBig(aii, ajj, aij) {
      var denom = subtract(ajj, aii);
      if (abs2(denom) <= config2.epsilon) {
        return bignumber(-1).acos().div(4);
      } else {
        return multiplyScalar(0.5, atan3(multiply(2, aij, inv(denom))));
      }
    }
    function Sij1(Sij, theta, i, j) {
      var N = Sij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var Ski = createArray(N, 0);
      var Skj = createArray(N, 0);
      for (var k = 0; k < N; k++) {
        Ski[k] = c * Sij[k][i] - s * Sij[k][j];
        Skj[k] = s * Sij[k][i] + c * Sij[k][j];
      }
      for (var _k = 0; _k < N; _k++) {
        Sij[_k][i] = Ski[_k];
        Sij[_k][j] = Skj[_k];
      }
      return Sij;
    }
    function Sij1Big(Sij, theta, i, j) {
      var N = Sij.length;
      var c = cos2(theta);
      var s = sin2(theta);
      var Ski = createArray(N, bignumber(0));
      var Skj = createArray(N, bignumber(0));
      for (var k = 0; k < N; k++) {
        Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
        Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
      }
      for (var _k2 = 0; _k2 < N; _k2++) {
        Sij[_k2][i] = Ski[_k2];
        Sij[_k2][j] = Skj[_k2];
      }
      return Sij;
    }
    function x1Big(Hij, theta, i, j) {
      var N = Hij.length;
      var c = bignumber(cos2(theta));
      var s = bignumber(sin2(theta));
      var c2 = multiplyScalar(c, c);
      var s2 = multiplyScalar(s, s);
      var Aki = createArray(N, bignumber(0));
      var Akj = createArray(N, bignumber(0));
      var csHij = multiply(bignumber(2), c, s, Hij[i][j]);
      var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
      var Ajj = add2(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j]));
      for (var k = 0; k < N; k++) {
        Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
        Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
      }
      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = bignumber(0);
      Hij[j][i] = bignumber(0);
      for (var _k3 = 0; _k3 < N; _k3++) {
        if (_k3 !== i && _k3 !== j) {
          Hij[i][_k3] = Aki[_k3];
          Hij[_k3][i] = Aki[_k3];
          Hij[j][_k3] = Akj[_k3];
          Hij[_k3][j] = Akj[_k3];
        }
      }
      return Hij;
    }
    function x1(Hij, theta, i, j) {
      var N = Hij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var c2 = c * c;
      var s2 = s * s;
      var Aki = createArray(N, 0);
      var Akj = createArray(N, 0);
      var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
      var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
      for (var k = 0; k < N; k++) {
        Aki[k] = c * Hij[i][k] - s * Hij[j][k];
        Akj[k] = s * Hij[i][k] + c * Hij[j][k];
      }
      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = 0;
      Hij[j][i] = 0;
      for (var _k4 = 0; _k4 < N; _k4++) {
        if (_k4 !== i && _k4 !== j) {
          Hij[i][_k4] = Aki[_k4];
          Hij[_k4][i] = Aki[_k4];
          Hij[j][_k4] = Akj[_k4];
          Hij[_k4][j] = Akj[_k4];
        }
      }
      return Hij;
    }
    function getAij(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
            maxMij = Math.abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function getAijBig(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (abs2(maxMij) < abs2(Mij[i][j])) {
            maxMij = abs2(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function sorting(E, S) {
      var N = E.length;
      var values2 = Array(N);
      var vectors = Array(N);
      for (var k = 0; k < N; k++) {
        vectors[k] = Array(N);
      }
      for (var i = 0; i < N; i++) {
        var minID = 0;
        var minE = E[0];
        for (var j = 0; j < E.length; j++) {
          if (abs2(E[j]) < abs2(minE)) {
            minID = j;
            minE = E[minID];
          }
        }
        values2[i] = E.splice(minID, 1)[0];
        for (var _k5 = 0; _k5 < N; _k5++) {
          vectors[_k5][i] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
      return {
        values: values2,
        vectors
      };
    }
    function createArray(size, value) {
      var array = new Array(size);
      for (var i = 0; i < size; i++) {
        array[i] = value;
      }
      return array;
    }
    return main;
  }

  // node_modules/mathjs/lib/esm/function/matrix/eigs.js
  var name239 = "eigs";
  var dependencies240 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
  var createEigs = /* @__PURE__ */ factory(name239, dependencies240, (_ref) => {
    var {
      config: config2,
      typed,
      matrix,
      addScalar,
      subtract,
      equal,
      abs: abs2,
      atan: atan3,
      cos: cos2,
      sin: sin2,
      multiplyScalar,
      divideScalar,
      inv,
      bignumber,
      multiply,
      add: add2,
      larger,
      column,
      flatten: flatten2,
      number,
      complex,
      sqrt: sqrt2,
      diag,
      qr,
      usolve,
      usolveAll,
      im,
      re,
      smaller,
      matrixFromColumns,
      dot
    } = _ref;
    var doRealSymetric = createRealSymmetric({
      config: config2,
      addScalar,
      subtract,
      column,
      flatten: flatten2,
      equal,
      abs: abs2,
      atan: atan3,
      cos: cos2,
      sin: sin2,
      multiplyScalar,
      inv,
      bignumber,
      complex,
      multiply,
      add: add2
    });
    var doComplexEigs = createComplexEigs({
      config: config2,
      addScalar,
      subtract,
      multiply,
      multiplyScalar,
      flatten: flatten2,
      divideScalar,
      sqrt: sqrt2,
      abs: abs2,
      bignumber,
      diag,
      qr,
      inv,
      usolve,
      usolveAll,
      equal,
      complex,
      larger,
      smaller,
      matrixFromColumns,
      dot
    });
    return typed("eigs", {
      Array: function Array2(x) {
        var mat = matrix(x);
        return computeValuesAndVectors(mat);
      },
      "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
        var mat = matrix(x);
        return computeValuesAndVectors(mat, prec);
      },
      Matrix: function Matrix(mat) {
        var {
          values: values2,
          vectors
        } = computeValuesAndVectors(mat);
        return {
          values: matrix(values2),
          vectors: matrix(vectors)
        };
      },
      "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
        var {
          values: values2,
          vectors
        } = computeValuesAndVectors(mat, prec);
        return {
          values: matrix(values2),
          vectors: matrix(vectors)
        };
      }
    });
    function computeValuesAndVectors(mat, prec) {
      if (prec === void 0) {
        prec = config2.epsilon;
      }
      var size = mat.size();
      if (size.length !== 2 || size[0] !== size[1]) {
        throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
      }
      var arr = mat.toArray();
      var N = size[0];
      if (isReal(arr, N, prec)) {
        coerceReal(arr, N);
        if (isSymmetric(arr, N, prec)) {
          var _type = coerceTypes(mat, arr, N);
          return doRealSymetric(arr, N, prec, _type);
        }
      }
      var type = coerceTypes(mat, arr, N);
      return doComplexEigs(arr, N, prec, type);
    }
    function isSymmetric(arr, N, prec) {
      for (var i = 0; i < N; i++) {
        for (var j = i; j < N; j++) {
          if (larger(bignumber(abs2(subtract(arr[i][j], arr[j][i]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function isReal(arr, N, prec) {
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (larger(bignumber(abs2(im(arr[i][j]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function coerceReal(arr, N) {
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          arr[i][j] = re(arr[i][j]);
        }
      }
    }
    function coerceTypes(mat, arr, N) {
      var type = mat.datatype();
      if (type === "number" || type === "BigNumber" || type === "Complex") {
        return type;
      }
      var hasNumber = false;
      var hasBig = false;
      var hasComplex = false;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          var el = arr[i][j];
          if (isNumber(el) || isFraction(el)) {
            hasNumber = true;
          } else if (isBigNumber(el)) {
            hasBig = true;
          } else if (isComplex(el)) {
            hasComplex = true;
          } else {
            throw TypeError("Unsupported type in Matrix: " + typeOf(el));
          }
        }
      }
      if (hasBig && hasComplex) {
        console.warn("Complex BigNumbers not supported, this operation will lose precission.");
      }
      if (hasComplex) {
        for (var _i = 0; _i < N; _i++) {
          for (var _j = 0; _j < N; _j++) {
            arr[_i][_j] = complex(arr[_i][_j]);
          }
        }
        return "Complex";
      }
      if (hasBig) {
        for (var _i2 = 0; _i2 < N; _i2++) {
          for (var _j2 = 0; _j2 < N; _j2++) {
            arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
          }
        }
        return "BigNumber";
      }
      if (hasNumber) {
        for (var _i3 = 0; _i3 < N; _i3++) {
          for (var _j3 = 0; _j3 < N; _j3++) {
            arr[_i3][_j3] = number(arr[_i3][_j3]);
          }
        }
        return "number";
      } else {
        throw TypeError("Matrix contains unsupported types only.");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/expm.js
  var name240 = "expm";
  var dependencies241 = ["typed", "abs", "add", "identity", "inv", "multiply"];
  var createExpm = /* @__PURE__ */ factory(name240, dependencies241, (_ref) => {
    var {
      typed,
      abs: abs2,
      add: add2,
      identity,
      inv,
      multiply
    } = _ref;
    return typed(name240, {
      Matrix: function Matrix(A) {
        var size = A.size();
        if (size.length !== 2 || size[0] !== size[1]) {
          throw new RangeError("Matrix must be square (size: " + format3(size) + ")");
        }
        var n = size[0];
        var eps = 1e-15;
        var infNorm = infinityNorm(A);
        var params = findParams(infNorm, eps);
        var q = params.q;
        var j = params.j;
        var Apos = multiply(A, Math.pow(2, -j));
        var N = identity(n);
        var D = identity(n);
        var factor = 1;
        var AposToI = Apos;
        var alternate = -1;
        for (var i = 1; i <= q; i++) {
          if (i > 1) {
            AposToI = multiply(AposToI, Apos);
            alternate = -alternate;
          }
          factor = factor * (q - i + 1) / ((2 * q - i + 1) * i);
          N = add2(N, multiply(factor, AposToI));
          D = add2(D, multiply(factor * alternate, AposToI));
        }
        var R = multiply(inv(D), N);
        for (var _i = 0; _i < j; _i++) {
          R = multiply(R, R);
        }
        return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
      }
    });
    function infinityNorm(A) {
      var n = A.size()[0];
      var infNorm = 0;
      for (var i = 0; i < n; i++) {
        var rowSum = 0;
        for (var j = 0; j < n; j++) {
          rowSum += abs2(A.get([i, j]));
        }
        infNorm = Math.max(rowSum, infNorm);
      }
      return infNorm;
    }
    function findParams(infNorm, eps) {
      var maxSearchSize = 30;
      for (var k = 0; k < maxSearchSize; k++) {
        for (var q = 0; q <= k; q++) {
          var j = k - q;
          if (errorEstimate(infNorm, q, j) < eps) {
            return {
              q,
              j
            };
          }
        }
      }
      throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
    }
    function errorEstimate(infNorm, q, j) {
      var qfac = 1;
      for (var i = 2; i <= q; i++) {
        qfac *= i;
      }
      var twoqfac = qfac;
      for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
        twoqfac *= _i2;
      }
      var twoqp1fac = twoqfac * (2 * q + 1);
      return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
  var name241 = "sqrtm";
  var dependencies242 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
  var createSqrtm = /* @__PURE__ */ factory(name241, dependencies242, (_ref) => {
    var {
      typed,
      abs: abs2,
      add: add2,
      multiply,
      map: map2,
      sqrt: sqrt2,
      subtract,
      inv,
      size,
      max: max2,
      identity
    } = _ref;
    var _maxIterations = 1e3;
    var _tolerance = 1e-6;
    function _denmanBeavers(A) {
      var error;
      var iterations = 0;
      var Y = A;
      var Z = identity(size(A));
      do {
        var Yk = Y;
        Y = multiply(0.5, add2(Yk, inv(Z)));
        Z = multiply(0.5, add2(Z, inv(Yk)));
        error = max2(abs2(subtract(Y, Yk)));
        if (error > _tolerance && ++iterations > _maxIterations) {
          throw new Error("computing square root of matrix: iterative method could not converge");
        }
      } while (error > _tolerance);
      return Y;
    }
    return typed(name241, {
      "Array | Matrix": function ArrayMatrix(A) {
        var size2 = isMatrix(A) ? A.size() : arraySize(A);
        switch (size2.length) {
          case 1:
            if (size2[0] === 1) {
              return map2(A, sqrt2);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              return _denmanBeavers(A);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size2) + ")");
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divide.js
  var name242 = "divide";
  var dependencies243 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
  var createDivide = /* @__PURE__ */ factory(name242, dependencies243, (_ref) => {
    var {
      typed,
      matrix,
      multiply,
      equalScalar,
      divideScalar,
      inv
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed,
      equalScalar
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed
    });
    return typed("divide", extend({
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
        return multiply(x, inv(y));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return matAlgo14xDs(x, y, divideScalar, false);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return matAlgo11xS0s(x, y, divideScalar, false);
      },
      "Array, any": function ArrayAny(x, y) {
        return matAlgo14xDs(matrix(x), y, divideScalar, false).valueOf();
      },
      "any, Array | Matrix": function anyArrayMatrix(x, y) {
        return multiply(x, inv(y));
      }
    }, divideScalar.signatures));
  });

  // node_modules/mathjs/lib/esm/function/geometry/distance.js
  var name243 = "distance";
  var dependencies244 = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "unaryMinus", "sqrt", "abs"];
  var createDistance = /* @__PURE__ */ factory(name243, dependencies244, (_ref) => {
    var {
      typed,
      addScalar,
      subtract,
      multiplyScalar,
      divideScalar,
      unaryMinus,
      sqrt: sqrt2,
      abs: abs2
    } = _ref;
    return typed(name243, {
      "Array, Array, Array": function ArrayArrayArray(x, y, z) {
        if (x.length === 2 && y.length === 2 && z.length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_2d(y)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
          }
          if (!_2d(z)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
          }
          var m = divideScalar(subtract(z[1], z[0]), subtract(y[1], y[0]));
          var xCoeff = multiplyScalar(multiplyScalar(m, m), y[0]);
          var yCoeff = unaryMinus(multiplyScalar(m, y[0]));
          var constant = x[1];
          return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object, Object": function ObjectObjectObject(x, y, z) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
          }
          if (!_2d(y)) {
            throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
          }
          if (!_2d(z)) {
            throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
            var m = divideScalar(subtract(z.lineTwoPtY, z.lineTwoPtX), subtract(y.lineOnePtY, y.lineOnePtX));
            var xCoeff = multiplyScalar(multiplyScalar(m, m), y.lineOnePtX);
            var yCoeff = unaryMinus(multiplyScalar(m, y.lineOnePtX));
            var constant = x.pointX;
            return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Array, Array": function ArrayArray(x, y) {
        if (x.length === 2 && y.length === 3) {
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(y)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
        } else if (x.length === 3 && y.length === 6) {
          if (!_3d(x)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_parametricLine(y)) {
            throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
          }
          return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
        } else if (x.length === y.length && x.length > 0) {
          if (!_containsOnlyNumbers(x)) {
            throw new TypeError("All values of an array should be numbers or BigNumbers");
          }
          if (!_containsOnlyNumbers(y)) {
            throw new TypeError("All values of an array should be numbers or BigNumbers");
          }
          return _euclideanDistance(x, y);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object": function ObjectObject(x, y) {
        if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
          }
          if (!_3d(y)) {
            throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
            return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
          if (!_3d(x)) {
            throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
          }
          if (!_parametricLine(y)) {
            throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
            return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
          }
          if (!_2d(y)) {
            throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
            return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
          if (!_3d(x)) {
            throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
          }
          if (!_3d(y)) {
            throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
            return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      Array: function Array2(arr) {
        if (!_pairwise(arr)) {
          throw new TypeError("Incorrect array format entered for pairwise distance calculation");
        }
        return _distancePairwise(arr);
      }
    });
    function _isNumber(a) {
      return typeof a === "number" || isBigNumber(a);
    }
    function _2d(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]);
    }
    function _3d(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
    }
    function _containsOnlyNumbers(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      return a.every(_isNumber);
    }
    function _parametricLine(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
    }
    function _objectToArray(o) {
      var keys = Object.keys(o);
      var a = [];
      for (var i = 0; i < keys.length; i++) {
        a.push(o[keys[i]]);
      }
      return a;
    }
    function _pairwise(a) {
      if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
        if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
          return false;
        }
      } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
        if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
          return false;
        }
      } else {
        return false;
      }
      return true;
    }
    function _distancePointLine2D(x, y, a, b, c) {
      var num = abs2(addScalar(addScalar(multiplyScalar(a, x), multiplyScalar(b, y)), c));
      var den = sqrt2(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)));
      return divideScalar(num, den);
    }
    function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
      var num = [subtract(multiplyScalar(subtract(y0, y), c), multiplyScalar(subtract(z0, z), b)), subtract(multiplyScalar(subtract(z0, z), a), multiplyScalar(subtract(x0, x), c)), subtract(multiplyScalar(subtract(x0, x), b), multiplyScalar(subtract(y0, y), a))];
      num = sqrt2(addScalar(addScalar(multiplyScalar(num[0], num[0]), multiplyScalar(num[1], num[1])), multiplyScalar(num[2], num[2])));
      var den = sqrt2(addScalar(addScalar(multiplyScalar(a, a), multiplyScalar(b, b)), multiplyScalar(c, c)));
      return divideScalar(num, den);
    }
    function _euclideanDistance(x, y) {
      var vectorSize = x.length;
      var result = 0;
      var diff = 0;
      for (var i = 0; i < vectorSize; i++) {
        diff = subtract(x[i], y[i]);
        result = addScalar(multiplyScalar(diff, diff), result);
      }
      return sqrt2(result);
    }
    function _distancePairwise(a) {
      var result = [];
      var pointA = [];
      var pointB = [];
      for (var i = 0; i < a.length - 1; i++) {
        for (var j = i + 1; j < a.length; j++) {
          if (a[0].length === 2) {
            pointA = [a[i][0], a[i][1]];
            pointB = [a[j][0], a[j][1]];
          } else if (a[0].length === 3) {
            pointA = [a[i][0], a[i][1], a[i][2]];
            pointB = [a[j][0], a[j][1], a[j][2]];
          }
          result.push(_euclideanDistance(pointA, pointB));
        }
      }
      return result;
    }
  });

  // node_modules/mathjs/lib/esm/function/geometry/intersect.js
  var name244 = "intersect";
  var dependencies245 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
  var createIntersect = /* @__PURE__ */ factory(name244, dependencies245, (_ref) => {
    var {
      typed,
      config: config2,
      abs: abs2,
      add: add2,
      addScalar,
      matrix,
      multiply,
      multiplyScalar,
      divideScalar,
      subtract,
      smaller,
      equalScalar,
      flatten: flatten2,
      isZero,
      isNumeric
    } = _ref;
    return typed("intersect", {
      "Array, Array, Array": _AAA,
      "Array, Array, Array, Array": _AAAA,
      "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
        var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
        return arr === null ? null : matrix(arr);
      },
      "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
        var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
        return arr === null ? null : matrix(arr);
      }
    });
    function _AAA(x, y, plane) {
      x = _coerceArr(x);
      y = _coerceArr(y);
      plane = _coerceArr(plane);
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_4d(plane)) {
        throw new TypeError("Array with 4 numbers expected as third argument");
      }
      return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
    }
    function _AAAA(w, x, y, z) {
      w = _coerceArr(w);
      x = _coerceArr(x);
      y = _coerceArr(y);
      z = _coerceArr(z);
      if (w.length === 2) {
        if (!_2d(w)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
        }
        return _intersect2d(w, x, y, z);
      } else if (w.length === 3) {
        if (!_3d(w)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
        }
        if (!_3d(z)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
        }
        return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
      } else {
        throw new TypeError("Arrays with two or thee dimensional points expected");
      }
    }
    function _coerceArr(arr) {
      if (arr.length === 1)
        return arr[0];
      if (arr.length > 1 && Array.isArray(arr[0])) {
        if (arr.every((el) => Array.isArray(el) && el.length === 1))
          return flatten2(arr);
      }
      return arr;
    }
    function _2d(x) {
      return x.length === 2 && isNumeric(x[0]) && isNumeric(x[1]);
    }
    function _3d(x) {
      return x.length === 3 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]);
    }
    function _4d(x) {
      return x.length === 4 && isNumeric(x[0]) && isNumeric(x[1]) && isNumeric(x[2]) && isNumeric(x[3]);
    }
    function _intersect2d(p1a, p1b, p2a, p2b) {
      var o1 = p1a;
      var o2 = p2a;
      var d1 = subtract(o1, p1b);
      var d2 = subtract(o2, p2b);
      var det = subtract(multiplyScalar(d1[0], d2[1]), multiplyScalar(d2[0], d1[1]));
      if (isZero(det))
        return null;
      if (smaller(abs2(det), config2.epsilon)) {
        return null;
      }
      var d20o11 = multiplyScalar(d2[0], o1[1]);
      var d21o10 = multiplyScalar(d2[1], o1[0]);
      var d20o21 = multiplyScalar(d2[0], o2[1]);
      var d21o20 = multiplyScalar(d2[1], o2[0]);
      var t = divideScalar(addScalar(subtract(subtract(d20o11, d21o10), d20o21), d21o20), det);
      return add2(multiply(d1, t), o1);
    }
    function _intersect3dHelper(a, b, c, d, e2, f, g, h, i, j, k, l) {
      var add1 = multiplyScalar(subtract(a, b), subtract(c, d));
      var add22 = multiplyScalar(subtract(e2, f), subtract(g, h));
      var add3 = multiplyScalar(subtract(i, j), subtract(k, l));
      return addScalar(addScalar(add1, add22), add3);
    }
    function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
      var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
      var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
      var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
      var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
      var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
      var numerator = subtract(multiplyScalar(d1343, d4321), multiplyScalar(d1321, d4343));
      var denominator = subtract(multiplyScalar(d2121, d4343), multiplyScalar(d4321, d4321));
      if (isZero(denominator))
        return null;
      var ta = divideScalar(numerator, denominator);
      var tb = divideScalar(addScalar(d1343, multiplyScalar(ta, d4321)), d4343);
      var pax = addScalar(x1, multiplyScalar(ta, subtract(x2, x1)));
      var pay = addScalar(y1, multiplyScalar(ta, subtract(y2, y1)));
      var paz = addScalar(z1, multiplyScalar(ta, subtract(z2, z1)));
      var pbx = addScalar(x3, multiplyScalar(tb, subtract(x4, x3)));
      var pby = addScalar(y3, multiplyScalar(tb, subtract(y4, y3)));
      var pbz = addScalar(z3, multiplyScalar(tb, subtract(z4, z3)));
      if (equalScalar(pax, pbx) && equalScalar(pay, pby) && equalScalar(paz, pbz)) {
        return [pax, pay, paz];
      } else {
        return null;
      }
    }
    function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
      var x1x = multiplyScalar(x1, x);
      var x2x = multiplyScalar(x2, x);
      var y1y = multiplyScalar(y1, y);
      var y2y = multiplyScalar(y2, y);
      var z1z = multiplyScalar(z1, z);
      var z2z = multiplyScalar(z2, z);
      var numerator = subtract(subtract(subtract(c, x1x), y1y), z1z);
      var denominator = subtract(subtract(subtract(addScalar(addScalar(x2x, y2y), z2z), x1x), y1y), z1z);
      var t = divideScalar(numerator, denominator);
      var px = addScalar(x1, multiplyScalar(t, subtract(x2, x1)));
      var py = addScalar(y1, multiplyScalar(t, subtract(y2, y1)));
      var pz = addScalar(z1, multiplyScalar(t, subtract(z2, z1)));
      return [px, py, pz];
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/sum.js
  var name245 = "sum";
  var dependencies246 = ["typed", "config", "add", "numeric"];
  var createSum = /* @__PURE__ */ factory(name245, dependencies246, (_ref) => {
    var {
      typed,
      config: config2,
      add: add2,
      numeric: numeric2
    } = _ref;
    return typed(name245, {
      "Array | Matrix": _sum,
      "Array | Matrix, number | BigNumber": _nsumDim,
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function sum");
        }
        return _sum(args);
      }
    });
    function _sum(array) {
      var sum2;
      deepForEach(array, function(value) {
        try {
          sum2 = sum2 === void 0 ? value : add2(sum2, value);
        } catch (err) {
          throw improveErrorMessage(err, "sum", value);
        }
      });
      if (sum2 === void 0) {
        sum2 = numeric2(0, config2.number);
      }
      if (typeof sum2 === "string") {
        sum2 = numeric2(sum2, config2.number);
      }
      return sum2;
    }
    function _nsumDim(array, dim) {
      try {
        var sum2 = reduce(array, dim, add2);
        return sum2;
      } catch (err) {
        throw improveErrorMessage(err, "sum");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/cumsum.js
  var name246 = "cumsum";
  var dependencies247 = ["typed", "add", "unaryPlus"];
  var createCumSum = /* @__PURE__ */ factory(name246, dependencies247, (_ref) => {
    var {
      typed,
      add: add2,
      unaryPlus
    } = _ref;
    return typed(name246, {
      Array: _cumsum,
      Matrix: function Matrix(matrix) {
        return matrix.create(_cumsum(matrix.valueOf()));
      },
      "Array, number | BigNumber": _ncumSumDim,
      "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix, dim) {
        return matrix.create(_ncumSumDim(matrix.valueOf(), dim));
      },
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("All values expected to be scalar in function cumsum");
        }
        return _cumsum(args);
      }
    });
    function _cumsum(array) {
      try {
        return _cumsummap(array);
      } catch (err) {
        throw improveErrorMessage(err, name246);
      }
    }
    function _cumsummap(array) {
      if (array.length === 0) {
        return [];
      }
      var sums = [unaryPlus(array[0])];
      for (var i = 1; i < array.length; ++i) {
        sums.push(add2(sums[i - 1], array[i]));
      }
      return sums;
    }
    function _ncumSumDim(array, dim) {
      var size = arraySize(array);
      if (dim < 0 || dim >= size.length) {
        throw new IndexError(dim, size.length);
      }
      try {
        return _cumsumDimensional(array, dim);
      } catch (err) {
        throw improveErrorMessage(err, name246);
      }
    }
    function _cumsumDimensional(mat, dim) {
      var i, ret, tran;
      if (dim <= 0) {
        var initialValue = mat[0][0];
        if (!Array.isArray(initialValue)) {
          return _cumsummap(mat);
        } else {
          tran = _switch(mat);
          ret = [];
          for (i = 0; i < tran.length; i++) {
            ret[i] = _cumsumDimensional(tran[i], dim - 1);
          }
          return ret;
        }
      } else {
        ret = [];
        for (i = 0; i < mat.length; i++) {
          ret[i] = _cumsumDimensional(mat[i], dim - 1);
        }
        return ret;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mean.js
  var name247 = "mean";
  var dependencies248 = ["typed", "add", "divide"];
  var createMean = /* @__PURE__ */ factory(name247, dependencies248, (_ref) => {
    var {
      typed,
      add: add2,
      divide: divide2
    } = _ref;
    return typed(name247, {
      "Array | Matrix": _mean,
      "Array | Matrix, number | BigNumber": _nmeanDim,
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function mean");
        }
        return _mean(args);
      }
    });
    function _nmeanDim(array, dim) {
      try {
        var sum2 = reduce(array, dim, add2);
        var s = Array.isArray(array) ? arraySize(array) : array.size();
        return divide2(sum2, s[dim]);
      } catch (err) {
        throw improveErrorMessage(err, "mean");
      }
    }
    function _mean(array) {
      var sum2;
      var num = 0;
      deepForEach(array, function(value) {
        try {
          sum2 = sum2 === void 0 ? value : add2(sum2, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "mean", value);
        }
      });
      if (num === 0) {
        throw new Error("Cannot calculate the mean of an empty array");
      }
      return divide2(sum2, num);
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/median.js
  var name248 = "median";
  var dependencies249 = ["typed", "add", "divide", "compare", "partitionSelect"];
  var createMedian = /* @__PURE__ */ factory(name248, dependencies249, (_ref) => {
    var {
      typed,
      add: add2,
      divide: divide2,
      compare,
      partitionSelect
    } = _ref;
    function _median(array) {
      try {
        array = flatten(array.valueOf());
        var num = array.length;
        if (num === 0) {
          throw new Error("Cannot calculate median of an empty array");
        }
        if (num % 2 === 0) {
          var mid = num / 2 - 1;
          var right = partitionSelect(array, mid + 1);
          var left = array[mid];
          for (var i = 0; i < mid; ++i) {
            if (compare(array[i], left) > 0) {
              left = array[i];
            }
          }
          return middle2(left, right);
        } else {
          var m = partitionSelect(array, (num - 1) / 2);
          return middle(m);
        }
      } catch (err) {
        throw improveErrorMessage(err, "median");
      }
    }
    var middle = typed({
      "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
        return value;
      }
    });
    var middle2 = typed({
      "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
        return divide2(add2(left, right), 2);
      }
    });
    return typed(name248, {
      "Array | Matrix": _median,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        throw new Error("median(A, dim) is not yet supported");
      },
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function median");
        }
        return _median(args);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/statistics/mad.js
  var name249 = "mad";
  var dependencies250 = ["typed", "abs", "map", "median", "subtract"];
  var createMad = /* @__PURE__ */ factory(name249, dependencies250, (_ref) => {
    var {
      typed,
      abs: abs2,
      map: map2,
      median,
      subtract
    } = _ref;
    return typed(name249, {
      "Array | Matrix": _mad,
      "...": function _(args) {
        return _mad(args);
      }
    });
    function _mad(array) {
      array = flatten(array.valueOf());
      if (array.length === 0) {
        throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
      }
      try {
        var med = median(array);
        return median(map2(array, function(value) {
          return abs2(subtract(value, med));
        }));
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
          throw new TypeError(err.message.replace("median", "mad"));
        } else {
          throw improveErrorMessage(err, "mad");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/variance.js
  var DEFAULT_NORMALIZATION = "unbiased";
  var name250 = "variance";
  var dependencies251 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
  var createVariance = /* @__PURE__ */ factory(name250, dependencies251, (_ref) => {
    var {
      typed,
      add: add2,
      subtract,
      multiply,
      divide: divide2,
      apply,
      isNaN: isNaN2
    } = _ref;
    return typed(name250, {
      "Array | Matrix": function ArrayMatrix(array) {
        return _var(array, DEFAULT_NORMALIZATION);
      },
      "Array | Matrix, string": _var,
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return _varDim(array, dim, DEFAULT_NORMALIZATION);
      },
      "Array | Matrix, number | BigNumber, string": _varDim,
      "...": function _(args) {
        return _var(args, DEFAULT_NORMALIZATION);
      }
    });
    function _var(array, normalization) {
      var sum2;
      var num = 0;
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      deepForEach(array, function(value) {
        try {
          sum2 = sum2 === void 0 ? value : add2(sum2, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "variance", value);
        }
      });
      if (num === 0)
        throw new Error("Cannot calculate variance of an empty array");
      var mean = divide2(sum2, num);
      sum2 = void 0;
      deepForEach(array, function(value) {
        var diff = subtract(value, mean);
        sum2 = sum2 === void 0 ? multiply(diff, diff) : add2(sum2, multiply(diff, diff));
      });
      if (isNaN2(sum2)) {
        return sum2;
      }
      switch (normalization) {
        case "uncorrected":
          return divide2(sum2, num);
        case "biased":
          return divide2(sum2, num + 1);
        case "unbiased": {
          var zero = isBigNumber(sum2) ? sum2.mul(0) : 0;
          return num === 1 ? zero : divide2(sum2, num - 1);
        }
        default:
          throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
      }
    }
    function _varDim(array, dim, normalization) {
      try {
        if (array.length === 0) {
          throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
        }
        return apply(array, dim, (x) => _var(x, normalization));
      } catch (err) {
        throw improveErrorMessage(err, "variance");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
  var name251 = "quantileSeq";
  var dependencies252 = ["typed", "add", "multiply", "partitionSelect", "compare"];
  var createQuantileSeq = /* @__PURE__ */ factory(name251, dependencies252, (_ref) => {
    var {
      typed,
      add: add2,
      multiply,
      partitionSelect,
      compare
    } = _ref;
    function quantileSeq(data, probOrN, sorted) {
      var probArr, dataArr, one;
      if (arguments.length < 2 || arguments.length > 3) {
        throw new SyntaxError("Function quantileSeq requires two or three parameters");
      }
      if (isCollection(data)) {
        sorted = sorted || false;
        if (typeof sorted === "boolean") {
          dataArr = data.valueOf();
          if (isNumber(probOrN)) {
            if (probOrN < 0) {
              throw new Error("N/prob must be non-negative");
            }
            if (probOrN <= 1) {
              return _quantileSeq(dataArr, probOrN, sorted);
            }
            if (probOrN > 1) {
              if (!isInteger(probOrN)) {
                throw new Error("N must be a positive integer");
              }
              var nPlusOne = probOrN + 1;
              probArr = new Array(probOrN);
              for (var i = 0; i < probOrN; ) {
                probArr[i] = _quantileSeq(dataArr, ++i / nPlusOne, sorted);
              }
              return probArr;
            }
          }
          if (isBigNumber(probOrN)) {
            var BigNumber = probOrN.constructor;
            if (probOrN.isNegative()) {
              throw new Error("N/prob must be non-negative");
            }
            one = new BigNumber(1);
            if (probOrN.lte(one)) {
              return new BigNumber(_quantileSeq(dataArr, probOrN, sorted));
            }
            if (probOrN.gt(one)) {
              if (!probOrN.isInteger()) {
                throw new Error("N must be a positive integer");
              }
              var intN = probOrN.toNumber();
              if (intN > 4294967295) {
                throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
              }
              var _nPlusOne = new BigNumber(intN + 1);
              probArr = new Array(intN);
              for (var _i = 0; _i < intN; ) {
                probArr[_i] = new BigNumber(_quantileSeq(dataArr, new BigNumber(++_i).div(_nPlusOne), sorted));
              }
              return probArr;
            }
          }
          if (Array.isArray(probOrN)) {
            probArr = new Array(probOrN.length);
            for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
              var currProb = probOrN[_i2];
              if (isNumber(currProb)) {
                if (currProb < 0 || currProb > 1) {
                  throw new Error("Probability must be between 0 and 1, inclusive");
                }
              } else if (isBigNumber(currProb)) {
                one = new currProb.constructor(1);
                if (currProb.isNegative() || currProb.gt(one)) {
                  throw new Error("Probability must be between 0 and 1, inclusive");
                }
              } else {
                throw new TypeError("Unexpected type of argument in function quantileSeq");
              }
              probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
            }
            return probArr;
          }
          throw new TypeError("Unexpected type of argument in function quantileSeq");
        }
        throw new TypeError("Unexpected type of argument in function quantileSeq");
      }
      throw new TypeError("Unexpected type of argument in function quantileSeq");
    }
    function _quantileSeq(array, prob, sorted) {
      var flat = flatten(array);
      var len = flat.length;
      if (len === 0) {
        throw new Error("Cannot calculate quantile of an empty sequence");
      }
      if (isNumber(prob)) {
        var _index = prob * (len - 1);
        var _fracPart = _index % 1;
        if (_fracPart === 0) {
          var value = sorted ? flat[_index] : partitionSelect(flat, _index);
          validate2(value);
          return value;
        }
        var _integerPart = Math.floor(_index);
        var _left;
        var _right;
        if (sorted) {
          _left = flat[_integerPart];
          _right = flat[_integerPart + 1];
        } else {
          _right = partitionSelect(flat, _integerPart + 1);
          _left = flat[_integerPart];
          for (var i = 0; i < _integerPart; ++i) {
            if (compare(flat[i], _left) > 0) {
              _left = flat[i];
            }
          }
        }
        validate2(_left);
        validate2(_right);
        return add2(multiply(_left, 1 - _fracPart), multiply(_right, _fracPart));
      }
      var index = prob.times(len - 1);
      if (index.isInteger()) {
        index = index.toNumber();
        var _value = sorted ? flat[index] : partitionSelect(flat, index);
        validate2(_value);
        return _value;
      }
      var integerPart = index.floor();
      var fracPart = index.minus(integerPart);
      var integerPartNumber = integerPart.toNumber();
      var left;
      var right;
      if (sorted) {
        left = flat[integerPartNumber];
        right = flat[integerPartNumber + 1];
      } else {
        right = partitionSelect(flat, integerPartNumber + 1);
        left = flat[integerPartNumber];
        for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
          if (compare(flat[_i3], left) > 0) {
            left = flat[_i3];
          }
        }
      }
      validate2(left);
      validate2(right);
      var one = new fracPart.constructor(1);
      return add2(multiply(left, one.minus(fracPart)), multiply(right, fracPart));
    }
    var validate2 = typed({
      "number | BigNumber | Unit": function numberBigNumberUnit(x) {
        return x;
      }
    });
    return quantileSeq;
  });

  // node_modules/mathjs/lib/esm/function/statistics/std.js
  var name252 = "std";
  var dependencies253 = ["typed", "map", "sqrt", "variance"];
  var createStd = /* @__PURE__ */ factory(name252, dependencies253, (_ref) => {
    var {
      typed,
      map: map2,
      sqrt: sqrt2,
      variance
    } = _ref;
    return typed(name252, {
      "Array | Matrix": _std,
      "Array | Matrix, string": _std,
      "Array | Matrix, number | BigNumber": _std,
      "Array | Matrix, number | BigNumber, string": _std,
      "...": function _(args) {
        return _std(args);
      }
    });
    function _std(array, normalization) {
      if (array.length === 0) {
        throw new SyntaxError("Function std requires one or more parameters (0 provided)");
      }
      try {
        var v = variance.apply(null, arguments);
        if (isCollection(v)) {
          return map2(v, sqrt2);
        } else {
          return sqrt2(v);
        }
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
          throw new TypeError(err.message.replace(" variance", " std"));
        } else {
          throw err;
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/combinations.js
  var name253 = "combinations";
  var dependencies254 = ["typed"];
  var createCombinations = /* @__PURE__ */ factory(name253, dependencies254, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name253, {
      "number, number": combinationsNumber,
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var BigNumber = n.constructor;
        var result, i;
        var nMinusk = n.minus(k);
        var one = new BigNumber(1);
        if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
          throw new TypeError("Positive integer value expected in function combinations");
        }
        if (k.gt(n)) {
          throw new TypeError("k must be less than n in function combinations");
        }
        result = one;
        if (k.lt(nMinusk)) {
          for (i = one; i.lte(nMinusk); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusk.plus(i)).dividedBy(i);
          }
        }
        return result;
      }
    });
  });
  function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
  var name254 = "combinationsWithRep";
  var dependencies255 = ["typed"];
  var createCombinationsWithRep = /* @__PURE__ */ factory(name254, dependencies255, (_ref) => {
    var {
      typed
    } = _ref;
    return typed(name254, {
      "number, number": function numberNumber(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (n < 1) {
          throw new TypeError("k must be less than or equal to n + k - 1");
        }
        if (k < n - 1) {
          var _prodrange = product2(n, n + k - 1);
          return _prodrange / product2(1, k);
        }
        var prodrange = product2(k + 1, n + k - 1);
        return prodrange / product2(1, n - 1);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var BigNumber = n.constructor;
        var result, i;
        var one = new BigNumber(1);
        var nMinusOne = n.minus(one);
        if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (n.lt(one)) {
          throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
        }
        result = one;
        if (k.lt(nMinusOne)) {
          for (i = one; i.lte(nMinusOne); i = i.plus(one)) {
            result = result.times(k.plus(i)).dividedBy(i);
          }
        } else {
          for (i = one; i.lte(k); i = i.plus(one)) {
            result = result.times(nMinusOne.plus(i)).dividedBy(i);
          }
        }
        return result;
      }
    });
  });
  function isPositiveInteger2(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/gamma.js
  var name255 = "gamma";
  var dependencies256 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
  var createGamma = /* @__PURE__ */ factory(name255, dependencies256, (_ref) => {
    var {
      typed,
      config: config2,
      multiplyScalar,
      pow: pow2,
      BigNumber: _BigNumber,
      Complex: Complex2
    } = _ref;
    function gammaComplex(n) {
      if (n.im === 0) {
        return gammaNumber(n.re);
      }
      if (n.re < 0.5) {
        var _t = new Complex2(1 - n.re, -n.im);
        var r = new Complex2(Math.PI * n.re, Math.PI * n.im);
        return new Complex2(Math.PI).div(r.sin()).div(gammaComplex(_t));
      }
      n = new Complex2(n.re - 1, n.im);
      var x = new Complex2(gammaP[0], 0);
      for (var i = 1; i < gammaP.length; ++i) {
        var gammaPval = new Complex2(gammaP[i], 0);
        x = x.add(gammaPval.div(n.add(i)));
      }
      var t = new Complex2(n.re + gammaG + 0.5, n.im);
      var twoPiSqrt = Math.sqrt(2 * Math.PI);
      var tpow = t.pow(n.add(0.5));
      var expt = t.neg().exp();
      return x.mul(twoPiSqrt).mul(tpow).mul(expt);
    }
    return typed(name255, {
      number: gammaNumber,
      Complex: gammaComplex,
      BigNumber: function BigNumber(n) {
        if (n.isInteger()) {
          return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
        }
        if (!n.isFinite()) {
          return new _BigNumber(n.isNegative() ? NaN : Infinity);
        }
        throw new Error("Integer BigNumber expected");
      }
    });
    function bigFactorial(n) {
      if (n < 8) {
        return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
      }
      var precision = config2.precision + (Math.log(n.toNumber()) | 0);
      var Big = _BigNumber.clone({
        precision
      });
      if (n % 2 === 1) {
        return n.times(bigFactorial(new _BigNumber(n - 1)));
      }
      var p = n;
      var prod = new Big(n);
      var sum2 = n.toNumber();
      while (p > 2) {
        p -= 2;
        sum2 += p;
        prod = prod.times(sum2);
      }
      return new _BigNumber(prod.toPrecision(_BigNumber.precision));
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/lgamma.js
  var name256 = "lgamma";
  var dependencies257 = ["Complex", "typed"];
  var createLgamma = /* @__PURE__ */ factory(name256, dependencies257, (_ref) => {
    var {
      Complex: Complex2,
      typed
    } = _ref;
    var SMALL_RE = 7;
    var SMALL_IM = 7;
    var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
    return typed(name256, {
      number: lgammaNumber,
      Complex: lgammaComplex,
      BigNumber: function BigNumber() {
        throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
      }
    });
    function lgammaComplex(n) {
      var TWOPI = 6.283185307179586;
      var LOGPI = 1.1447298858494002;
      var REFLECTION = 0.1;
      if (n.isNaN()) {
        return new Complex2(NaN, NaN);
      } else if (n.im === 0) {
        return new Complex2(lgammaNumber(n.re), 0);
      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
        return lgammaStirling(n);
      } else if (n.re <= REFLECTION) {
        var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
        var a = n.mul(Math.PI).sin().log();
        var b = lgammaComplex(new Complex2(1 - n.re, -n.im));
        return new Complex2(LOGPI, tmp).sub(a).sub(b);
      } else if (n.im >= 0) {
        return lgammaRecurrence(n);
      } else {
        return lgammaRecurrence(n.conjugate()).conjugate();
      }
    }
    function lgammaStirling(z) {
      var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
      var rz = new Complex2(1, 0).div(z);
      var rzz = rz.div(z);
      var a = coeffs[0];
      var b = coeffs[1];
      var r = 2 * rzz.re;
      var s = rzz.re * rzz.re + rzz.im * rzz.im;
      for (var i = 2; i < 8; i++) {
        var tmp = b;
        b = -s * a + coeffs[i];
        a = r * a + tmp;
      }
      var rightPart = rz.mul(rzz.mul(a).add(b));
      return leftPart.add(rightPart);
    }
    function lgammaRecurrence(z) {
      var signflips = 0;
      var sb = 0;
      var shiftprod = z;
      z = z.add(1);
      while (z.re <= SMALL_RE) {
        shiftprod = shiftprod.mul(z);
        var nsb = shiftprod.im < 0 ? 1 : 0;
        if (nsb !== 0 && sb === 0)
          signflips++;
        sb = nsb;
        z = z.add(1);
      }
      return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex2(0, signflips * 2 * Math.PI * 1));
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/factorial.js
  var name257 = "factorial";
  var dependencies258 = ["typed", "gamma"];
  var createFactorial = /* @__PURE__ */ factory(name257, dependencies258, (_ref) => {
    var {
      typed,
      gamma
    } = _ref;
    return typed(name257, {
      number: function number(n) {
        if (n < 0) {
          throw new Error("Value must be non-negative");
        }
        return gamma(n + 1);
      },
      BigNumber: function BigNumber(n) {
        if (n.isNegative()) {
          throw new Error("Value must be non-negative");
        }
        return gamma(n.plus(1));
      },
      "Array | Matrix": typed.referToSelf((self2) => (n) => deepMap(n, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/probability/kldivergence.js
  var name258 = "kldivergence";
  var dependencies259 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
  var createKldivergence = /* @__PURE__ */ factory(name258, dependencies259, (_ref) => {
    var {
      typed,
      matrix,
      divide: divide2,
      sum: sum2,
      multiply,
      map: map2,
      dotDivide,
      log: log3,
      isNumeric
    } = _ref;
    return typed(name258, {
      "Array, Array": function ArrayArray(q, p) {
        return _kldiv(matrix(q), matrix(p));
      },
      "Matrix, Array": function MatrixArray(q, p) {
        return _kldiv(q, matrix(p));
      },
      "Array, Matrix": function ArrayMatrix(q, p) {
        return _kldiv(matrix(q), p);
      },
      "Matrix, Matrix": function MatrixMatrix(q, p) {
        return _kldiv(q, p);
      }
    });
    function _kldiv(q, p) {
      var plength = p.size().length;
      var qlength = q.size().length;
      if (plength > 1) {
        throw new Error("first object must be one dimensional");
      }
      if (qlength > 1) {
        throw new Error("second object must be one dimensional");
      }
      if (plength !== qlength) {
        throw new Error("Length of two vectors must be equal");
      }
      var sumq = sum2(q);
      if (sumq === 0) {
        throw new Error("Sum of elements in first object must be non zero");
      }
      var sump = sum2(p);
      if (sump === 0) {
        throw new Error("Sum of elements in second object must be non zero");
      }
      var qnorm = divide2(q, sum2(q));
      var pnorm = divide2(p, sum2(p));
      var result = sum2(multiply(qnorm, map2(dotDivide(qnorm, pnorm), (x) => log3(x))));
      if (isNumeric(result)) {
        return result;
      } else {
        return Number.NaN;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/multinomial.js
  var name259 = "multinomial";
  var dependencies260 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
  var createMultinomial = /* @__PURE__ */ factory(name259, dependencies260, (_ref) => {
    var {
      typed,
      add: add2,
      divide: divide2,
      multiply,
      factorial,
      isInteger: isInteger2,
      isPositive
    } = _ref;
    return typed(name259, {
      "Array | Matrix": function ArrayMatrix(a) {
        var sum2 = 0;
        var denom = 1;
        deepForEach(a, function(ai) {
          if (!isInteger2(ai) || !isPositive(ai)) {
            throw new TypeError("Positive integer value expected in function multinomial");
          }
          sum2 = add2(sum2, ai);
          denom = multiply(denom, factorial(ai));
        });
        return divide2(factorial(sum2), denom);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/probability/permutations.js
  var name260 = "permutations";
  var dependencies261 = ["typed", "factorial"];
  var createPermutations = /* @__PURE__ */ factory(name260, dependencies261, (_ref) => {
    var {
      typed,
      factorial
    } = _ref;
    return typed(name260, {
      "number | BigNumber": factorial,
      "number, number": function numberNumber(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (k > n) {
          throw new TypeError("second argument k must be less than or equal to first argument n");
        }
        return product2(n - k + 1, n);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var result, i;
        if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (k.gt(n)) {
          throw new TypeError("second argument k must be less than or equal to first argument n");
        }
        var one = n.mul(0).add(1);
        result = one;
        for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
          result = result.times(i);
        }
        return result;
      }
    });
  });
  function isPositiveInteger3(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
  var import_seedrandom = __toESM(require_seedrandom2(), 1);
  var singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
  function createRng(randomSeed) {
    var random2;
    function setSeed(seed) {
      random2 = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
    }
    setSeed(randomSeed);
    function rng() {
      return random2();
    }
    return rng;
  }

  // node_modules/mathjs/lib/esm/function/probability/pickRandom.js
  var name261 = "pickRandom";
  var dependencies262 = ["typed", "config", "?on"];
  var createPickRandom = /* @__PURE__ */ factory(name261, dependencies262, (_ref) => {
    var {
      typed,
      config: config2,
      on
    } = _ref;
    var rng = createRng(config2.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed(name261, {
      "Array | Matrix": function ArrayMatrix(possibles) {
        return _pickRandom(possibles, {});
      },
      "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
        return _pickRandom(possibles, options);
      },
      "Array | Matrix, number": function ArrayMatrixNumber(possibles, number) {
        return _pickRandom(possibles, {
          number
        });
      },
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
        return _pickRandom(possibles, {
          weights
        });
      },
      "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number) {
        return _pickRandom(possibles, {
          number,
          weights
        });
      },
      "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number, weights) {
        return _pickRandom(possibles, {
          number,
          weights
        });
      }
    });
    function _pickRandom(possibles, _ref2) {
      var {
        number,
        weights,
        elementWise = true
      } = _ref2;
      var single = typeof number === "undefined";
      if (single) {
        number = 1;
      }
      var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
      possibles = possibles.valueOf();
      if (weights) {
        weights = weights.valueOf();
      }
      if (elementWise === true) {
        possibles = flatten(possibles);
        weights = flatten(weights);
      }
      var totalWeights = 0;
      if (typeof weights !== "undefined") {
        if (weights.length !== possibles.length) {
          throw new Error("Weights must have the same length as possibles");
        }
        for (var i = 0, len = weights.length; i < len; i++) {
          if (!isNumber(weights[i]) || weights[i] < 0) {
            throw new Error("Weights must be an array of positive numbers");
          }
          totalWeights += weights[i];
        }
      }
      var length = possibles.length;
      var result = [];
      var pick;
      while (result.length < number) {
        if (typeof weights === "undefined") {
          pick = possibles[Math.floor(rng() * length)];
        } else {
          var randKey = rng() * totalWeights;
          for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
            randKey -= weights[_i];
            if (randKey < 0) {
              pick = possibles[_i];
              break;
            }
          }
        }
        result.push(pick);
      }
      return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
  function randomMatrix(size, random2) {
    var data = [];
    size = size.slice(0);
    if (size.length > 1) {
      for (var i = 0, length = size.shift(); i < length; i++) {
        data.push(randomMatrix(size, random2));
      }
    } else {
      for (var _i = 0, _length = size.shift(); _i < _length; _i++) {
        data.push(random2());
      }
    }
    return data;
  }

  // node_modules/mathjs/lib/esm/function/probability/random.js
  var name262 = "random";
  var dependencies263 = ["typed", "config", "?on"];
  var createRandom = /* @__PURE__ */ factory(name262, dependencies263, (_ref) => {
    var {
      typed,
      config: config2,
      on
    } = _ref;
    var rng = createRng(config2.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed(name262, {
      "": () => _random(0, 1),
      number: (max2) => _random(0, max2),
      "number, number": (min2, max2) => _random(min2, max2),
      "Array | Matrix": (size) => _randomMatrix(size, 0, 1),
      "Array | Matrix, number": (size, max2) => _randomMatrix(size, 0, max2),
      "Array | Matrix, number, number": (size, min2, max2) => _randomMatrix(size, min2, max2)
    });
    function _randomMatrix(size, min2, max2) {
      var res = randomMatrix(size.valueOf(), () => _random(min2, max2));
      return isMatrix(size) ? size.create(res) : res;
    }
    function _random(min2, max2) {
      return min2 + rng() * (max2 - min2);
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/randomInt.js
  var name263 = "randomInt";
  var dependencies264 = ["typed", "config", "?on"];
  var createRandomInt = /* @__PURE__ */ factory(name263, dependencies264, (_ref) => {
    var {
      typed,
      config: config2,
      on
    } = _ref;
    var rng = createRng(config2.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed(name263, {
      "": () => _randomInt(0, 1),
      number: (max2) => _randomInt(0, max2),
      "number, number": (min2, max2) => _randomInt(min2, max2),
      "Array | Matrix": (size) => _randomIntMatrix(size, 0, 1),
      "Array | Matrix, number": (size, max2) => _randomIntMatrix(size, 0, max2),
      "Array | Matrix, number, number": (size, min2, max2) => _randomIntMatrix(size, min2, max2)
    });
    function _randomIntMatrix(size, min2, max2) {
      var res = randomMatrix(size.valueOf(), () => _randomInt(min2, max2));
      return isMatrix(size) ? size.create(res) : res;
    }
    function _randomInt(min2, max2) {
      return Math.floor(min2 + rng() * (max2 - min2));
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
  var name264 = "stirlingS2";
  var dependencies265 = ["typed", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
  var createStirlingS2 = /* @__PURE__ */ factory(name264, dependencies265, (_ref) => {
    var {
      typed,
      addScalar,
      subtract,
      multiplyScalar,
      divideScalar,
      pow: pow2,
      factorial,
      combinations,
      isNegative,
      isInteger: isInteger2,
      number,
      bignumber,
      larger
    } = _ref;
    var smallCache = [];
    var bigCache = [];
    return typed(name264, {
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger2(n) || isNegative(n) || !isInteger2(k) || isNegative(k)) {
          throw new TypeError("Non-negative integer value expected in function stirlingS2");
        } else if (larger(k, n)) {
          throw new TypeError("k must be less than or equal to n in function stirlingS2");
        }
        var big = !(isNumber(n) && isNumber(k));
        var cache = big ? bigCache : smallCache;
        var make = big ? bignumber : number;
        var nn = number(n);
        var nk = number(k);
        if (cache[nn] && cache[nn].length > nk) {
          return cache[nn][nk];
        }
        for (var m = 0; m <= nn; ++m) {
          if (!cache[m]) {
            cache[m] = [m === 0 ? make(1) : make(0)];
          }
          if (m === 0)
            continue;
          var row = cache[m];
          var prev = cache[m - 1];
          for (var i = row.length; i <= m && i <= nk; ++i) {
            if (i === m) {
              row[i] = 1;
            } else {
              row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);
            }
          }
        }
        return cache[nn][nk];
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
  var name265 = "bellNumbers";
  var dependencies266 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
  var createBellNumbers = /* @__PURE__ */ factory(name265, dependencies266, (_ref) => {
    var {
      typed,
      addScalar,
      isNegative,
      isInteger: isInteger2,
      stirlingS2
    } = _ref;
    return typed(name265, {
      "number | BigNumber": function numberBigNumber(n) {
        if (!isInteger2(n) || isNegative(n)) {
          throw new TypeError("Non-negative integer value expected in function bellNumbers");
        }
        var result = 0;
        for (var i = 0; i <= n; i++) {
          result = addScalar(result, stirlingS2(n, i));
        }
        return result;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
  var name266 = "catalan";
  var dependencies267 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
  var createCatalan = /* @__PURE__ */ factory(name266, dependencies267, (_ref) => {
    var {
      typed,
      addScalar,
      divideScalar,
      multiplyScalar,
      combinations,
      isNegative,
      isInteger: isInteger2
    } = _ref;
    return typed(name266, {
      "number | BigNumber": function numberBigNumber(n) {
        if (!isInteger2(n) || isNegative(n)) {
          throw new TypeError("Non-negative integer value expected in function catalan");
        }
        return divideScalar(combinations(multiplyScalar(n, 2), n), addScalar(n, 1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/composition.js
  var name267 = "composition";
  var dependencies268 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
  var createComposition = /* @__PURE__ */ factory(name267, dependencies268, (_ref) => {
    var {
      typed,
      addScalar,
      combinations,
      isPositive,
      isNegative,
      isInteger: isInteger2,
      larger
    } = _ref;
    return typed(name267, {
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger2(n) || !isPositive(n) || !isInteger2(k) || !isPositive(k)) {
          throw new TypeError("Positive integer value expected in function composition");
        } else if (larger(k, n)) {
          throw new TypeError("k must be less than or equal to n in function composition");
        }
        return combinations(addScalar(n, -1), addScalar(k, -1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/leafCount.js
  var name268 = "leafCount";
  var dependencies269 = ["parse", "typed"];
  var createLeafCount = /* @__PURE__ */ factory(name268, dependencies269, (_ref) => {
    var {
      parse,
      typed
    } = _ref;
    function countLeaves(node) {
      var count = 0;
      node.forEach((n) => {
        count += countLeaves(n);
      });
      return count || 1;
    }
    return typed(name268, {
      Node: function Node(expr) {
        return countLeaves(expr);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var name269 = "simplifyUtil";
  var dependencies270 = ["FunctionNode", "OperatorNode", "SymbolNode"];
  var createUtil = /* @__PURE__ */ factory(name269, dependencies270, (_ref) => {
    var {
      FunctionNode,
      OperatorNode,
      SymbolNode
    } = _ref;
    var T = true;
    var F = false;
    var defaultName = "defaultF";
    var defaultContext = {
      add: {
        trivial: T,
        total: T,
        commutative: T,
        associative: T
      },
      unaryPlus: {
        trivial: T,
        total: T,
        commutative: T,
        associative: T
      },
      subtract: {
        trivial: F,
        total: T,
        commutative: F,
        associative: F
      },
      multiply: {
        trivial: T,
        total: T,
        commutative: T,
        associative: T
      },
      divide: {
        trivial: F,
        total: T,
        commutative: F,
        associative: F
      },
      paren: {
        trivial: T,
        total: T,
        commutative: T,
        associative: F
      },
      defaultF: {
        trivial: F,
        total: T,
        commutative: F,
        associative: F
      }
    };
    var realContext = {
      divide: {
        total: F
      },
      log: {
        total: F
      }
    };
    var positiveContext = {
      subtract: {
        total: F
      },
      abs: {
        trivial: T
      },
      log: {
        total: T
      }
    };
    function hasProperty(nodeOrName, property) {
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
      var name297 = defaultName;
      if (typeof nodeOrName === "string") {
        name297 = nodeOrName;
      } else if (isOperatorNode(nodeOrName)) {
        name297 = nodeOrName.fn.toString();
      } else if (isFunctionNode(nodeOrName)) {
        name297 = nodeOrName.name;
      } else if (isParenthesisNode(nodeOrName)) {
        name297 = "paren";
      }
      if (hasOwnProperty2(context, name297)) {
        var properties2 = context[name297];
        if (hasOwnProperty2(properties2, property)) {
          return properties2[property];
        }
        if (hasOwnProperty2(defaultContext, name297)) {
          return defaultContext[name297][property];
        }
      }
      if (hasOwnProperty2(context, defaultName)) {
        var _properties = context[defaultName];
        if (hasOwnProperty2(_properties, property)) {
          return _properties[property];
        }
        return defaultContext[defaultName][property];
      }
      if (hasOwnProperty2(defaultContext, name297)) {
        var _properties2 = defaultContext[name297];
        if (hasOwnProperty2(_properties2, property)) {
          return _properties2[property];
        }
      }
      return defaultContext[defaultName][property];
    }
    function isCommutative(node) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
      return hasProperty(node, "commutative", context);
    }
    function isAssociative(node) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
      return hasProperty(node, "associative", context);
    }
    function mergeContext(primary, secondary) {
      var merged = _objectSpread2({}, primary);
      for (var prop in secondary) {
        if (hasOwnProperty2(primary, prop)) {
          merged[prop] = _objectSpread2(_objectSpread2({}, secondary[prop]), primary[prop]);
        } else {
          merged[prop] = secondary[prop];
        }
      }
      return merged;
    }
    function flatten2(node, context) {
      if (!node.args || node.args.length === 0) {
        return node;
      }
      node.args = allChildren(node, context);
      for (var i = 0; i < node.args.length; i++) {
        flatten2(node.args[i], context);
      }
    }
    function allChildren(node, context) {
      var op;
      var children = [];
      var findChildren = function findChildren2(node2) {
        for (var i = 0; i < node2.args.length; i++) {
          var child = node2.args[i];
          if (isOperatorNode(child) && op === child.op) {
            findChildren2(child);
          } else {
            children.push(child);
          }
        }
      };
      if (isAssociative(node, context)) {
        op = node.op;
        findChildren(node);
        return children;
      } else {
        return node.args;
      }
    }
    function unflattenr(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;
      for (var i = 0; i < l; i++) {
        unflattenr(node.args[i], context);
      }
      if (l > 2 && isAssociative(node, context)) {
        var curnode = node.args.pop();
        while (node.args.length > 0) {
          curnode = makeNode([node.args.pop(), curnode]);
        }
        node.args = curnode.args;
      }
    }
    function unflattenl(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;
      for (var i = 0; i < l; i++) {
        unflattenl(node.args[i], context);
      }
      if (l > 2 && isAssociative(node, context)) {
        var curnode = node.args.shift();
        while (node.args.length > 0) {
          curnode = makeNode([curnode, node.args.shift()]);
        }
        node.args = curnode.args;
      }
    }
    function createMakeNodeFunction(node) {
      if (isOperatorNode(node)) {
        return function(args) {
          try {
            return new OperatorNode(node.op, node.fn, args, node.implicit);
          } catch (err) {
            console.error(err);
            return [];
          }
        };
      } else {
        return function(args) {
          return new FunctionNode(new SymbolNode(node.name), args);
        };
      }
    }
    return {
      createMakeNodeFunction,
      hasProperty,
      isCommutative,
      isAssociative,
      mergeContext,
      flatten: flatten2,
      allChildren,
      unflattenr,
      unflattenl,
      defaultContext,
      realContext,
      positiveContext
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify.js
  var name270 = "simplify";
  var dependencies271 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createSimplify = /* @__PURE__ */ factory(name270, dependencies271, (_ref) => {
    var {
      config: config2,
      typed,
      parse,
      add: add2,
      subtract,
      multiply,
      divide: divide2,
      pow: pow2,
      isZero,
      equal,
      resolve,
      simplifyConstant,
      simplifyCore,
      fraction,
      bignumber,
      mathWithTransform,
      matrix,
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode
    } = _ref;
    var {
      hasProperty,
      isCommutative,
      isAssociative,
      mergeContext,
      flatten: flatten2,
      unflattenr,
      unflattenl,
      createMakeNodeFunction,
      defaultContext,
      realContext,
      positiveContext
    } = createUtil({
      FunctionNode,
      OperatorNode,
      SymbolNode
    });
    typed.addConversion({
      from: "Object",
      to: "Map",
      convert: createMap
    });
    var simplify = typed("simplify", {
      Node: _simplify,
      "Node, Map": (expr, scope) => _simplify(expr, false, scope),
      "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
      "Node, Array": _simplify,
      "Node, Array, Map": _simplify,
      "Node, Array, Map, Object": _simplify
    });
    typed.removeConversion({
      from: "Object",
      to: "Map",
      convert: createMap
    });
    simplify.defaultContext = defaultContext;
    simplify.realContext = realContext;
    simplify.positiveContext = positiveContext;
    function removeParens(node) {
      return node.transform(function(node2, path, parent) {
        return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
      });
    }
    var SUPPORTED_CONSTANTS = {
      true: true,
      false: true,
      e: true,
      i: true,
      Infinity: true,
      LN2: true,
      LN10: true,
      LOG2E: true,
      LOG10E: true,
      NaN: true,
      phi: true,
      pi: true,
      SQRT1_2: true,
      SQRT2: true,
      tau: true
    };
    simplify.rules = [
      simplifyCore,
      {
        l: "log(e)",
        r: "1"
      },
      {
        s: "n-n1 -> n+-n1",
        assuming: {
          subtract: {
            total: true
          }
        }
      },
      {
        s: "n-n -> 0",
        assuming: {
          subtract: {
            total: false
          }
        }
      },
      {
        s: "-(c*v) -> v * (-c)",
        assuming: {
          multiply: {
            commutative: true
          },
          subtract: {
            total: true
          }
        }
      },
      {
        s: "-(c*v) -> (-c) * v",
        assuming: {
          multiply: {
            commutative: false
          },
          subtract: {
            total: true
          }
        }
      },
      {
        s: "-(v*c) -> v * (-c)",
        assuming: {
          multiply: {
            commutative: false
          },
          subtract: {
            total: true
          }
        }
      },
      {
        l: "-(n1/n2)",
        r: "-n1/n2"
      },
      {
        l: "-v",
        r: "v * (-1)"
      },
      {
        l: "(n1 + n2)*(-1)",
        r: "n1*(-1) + n2*(-1)",
        repeat: true
      },
      {
        l: "n/n1^n2",
        r: "n*n1^-n2"
      },
      {
        l: "n/n1",
        r: "n*n1^-1"
      },
      {
        s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
        assuming: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        l: " v   * ( v   * n1 + n2)",
        r: "v^2       * n1 +  v   * n2"
      },
      {
        s: " v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        s: "v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        s: "v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        l: "n*n",
        r: "n^2"
      },
      {
        s: "n * n^n1 -> n^(n1+1)",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        s: "n^n1 * n^n2 -> n^(n1+n2)",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      simplifyConstant,
      {
        s: "n+n -> 2*n",
        assuming: {
          add: {
            total: true
          }
        }
      },
      {
        l: "n+-n",
        r: "0"
      },
      {
        l: "v*n + v",
        r: "v*(n+1)"
      },
      {
        l: "n3*n1 + n3*n2",
        r: "n3*(n1+n2)"
      },
      {
        l: "n3^(-n4)*n1 +   n3  * n2",
        r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
      },
      {
        l: "n3^(-n4)*n1 + n3^n5 * n2",
        r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
      },
      {
        s: "n*v + v -> (n+1)*v",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        l: "n*c + c",
        r: "(n+1)*c"
      },
      {
        s: "c*n + c -> c*(n+1)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      simplifyConstant,
      {
        s: "(-n)*n1 -> -(n*n1)",
        assuming: {
          subtract: {
            total: true
          }
        }
      },
      {
        s: "n1*(-n) -> -(n1*n)",
        assuming: {
          subtract: {
            total: true
          },
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "c+v -> v+c",
        assuming: {
          add: {
            commutative: true
          }
        },
        imposeContext: {
          add: {
            commutative: false
          }
        }
      },
      {
        s: "v*c -> c*v",
        assuming: {
          multiply: {
            commutative: true
          }
        },
        imposeContext: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        l: "n+-n1",
        r: "n-n1"
      },
      {
        s: "n*(n1^-1) -> n/n1",
        assuming: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        s: "n*n1^-n2 -> n/n1^n2",
        assuming: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        s: "n^-1 -> 1/n",
        assuming: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        l: "n^1",
        r: "n"
      },
      {
        s: "n*(n1/n2) -> (n*n1)/n2",
        assuming: {
          multiply: {
            associative: true
          }
        }
      },
      {
        s: "n-(n1+n2) -> n-n1-n2",
        assuming: {
          addition: {
            associative: true,
            commutative: true
          }
        }
      },
      {
        l: "1*n",
        r: "n",
        imposeContext: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        s: "n1/(n2/n3) -> (n1*n3)/n2",
        assuming: {
          multiply: {
            associative: true
          }
        }
      },
      {
        l: "n1/(-n2)",
        r: "-n1/n2"
      }
    ];
    function _canonicalizeRule(ruleObject, context) {
      var newRule = {};
      if (ruleObject.s) {
        var lr = ruleObject.s.split("->");
        if (lr.length === 2) {
          newRule.l = lr[0];
          newRule.r = lr[1];
        } else {
          throw SyntaxError("Could not parse rule: " + ruleObject.s);
        }
      } else {
        newRule.l = ruleObject.l;
        newRule.r = ruleObject.r;
      }
      newRule.l = removeParens(parse(newRule.l));
      newRule.r = removeParens(parse(newRule.r));
      for (var prop of ["imposeContext", "repeat", "assuming"]) {
        if (prop in ruleObject) {
          newRule[prop] = ruleObject[prop];
        }
      }
      if (ruleObject.evaluate) {
        newRule.evaluate = parse(ruleObject.evaluate);
      }
      if (isAssociative(newRule.l, context)) {
        var makeNode = createMakeNodeFunction(newRule.l);
        var expandsym = _getExpandPlaceholderSymbol();
        newRule.expanded = {};
        newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);
        flatten2(newRule.expanded.l, context);
        unflattenr(newRule.expanded.l, context);
        newRule.expanded.r = makeNode([newRule.r, expandsym]);
      }
      return newRule;
    }
    function _buildRules(rules, context) {
      var ruleSet = [];
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var newRule = void 0;
        var ruleType = typeof rule;
        switch (ruleType) {
          case "string":
            rule = {
              s: rule
            };
          case "object":
            newRule = _canonicalizeRule(rule, context);
            break;
          case "function":
            newRule = rule;
            break;
          default:
            throw TypeError("Unsupported type of rule: " + ruleType);
        }
        ruleSet.push(newRule);
      }
      return ruleSet;
    }
    var _lastsym = 0;
    function _getExpandPlaceholderSymbol() {
      return new SymbolNode("_p" + _lastsym++);
    }
    function _simplify(expr, rules) {
      var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var debug = options.consoleDebug;
      rules = _buildRules(rules || simplify.rules, options.context);
      var res = resolve(expr, scope);
      res = removeParens(res);
      var visited = {};
      var str = res.toString({
        parenthesis: "all"
      });
      while (!visited[str]) {
        visited[str] = true;
        _lastsym = 0;
        var laststr = str;
        if (debug)
          console.log("Working on: ", str);
        for (var i = 0; i < rules.length; i++) {
          var rulestr = "";
          if (typeof rules[i] === "function") {
            res = rules[i](res, options);
            if (debug)
              rulestr = rules[i].name;
          } else {
            flatten2(res, options.context);
            res = applyRule(res, rules[i], options.context);
            if (debug) {
              rulestr = "".concat(rules[i].l.toString(), " -> ").concat(rules[i].r.toString());
            }
          }
          if (debug) {
            var newstr = res.toString({
              parenthesis: "all"
            });
            if (newstr !== laststr) {
              console.log("Applying", rulestr, "produced", newstr);
              laststr = newstr;
            }
          }
          unflattenl(res, options.context);
        }
        str = res.toString({
          parenthesis: "all"
        });
      }
      return res;
    }
    function mapRule(nodes, rule, context) {
      var resNodes = nodes;
      if (nodes) {
        for (var i = 0; i < nodes.length; ++i) {
          var newNode = applyRule(nodes[i], rule, context);
          if (newNode !== nodes[i]) {
            if (resNodes === nodes) {
              resNodes = nodes.slice();
            }
            resNodes[i] = newNode;
          }
        }
      }
      return resNodes;
    }
    function applyRule(node, rule, context) {
      if (rule.assuming) {
        for (var symbol in rule.assuming) {
          for (var property in rule.assuming[symbol]) {
            if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
              return node;
            }
          }
        }
      }
      var mergedContext = mergeContext(rule.imposeContext, context);
      var res = node;
      if (res instanceof OperatorNode || res instanceof FunctionNode) {
        var newArgs = mapRule(res.args, rule, context);
        if (newArgs !== res.args) {
          res = res.clone();
          res.args = newArgs;
        }
      } else if (res instanceof ParenthesisNode) {
        if (res.content) {
          var newContent = applyRule(res.content, rule, context);
          if (newContent !== res.content) {
            res = new ParenthesisNode(newContent);
          }
        }
      } else if (res instanceof ArrayNode) {
        var newItems = mapRule(res.items, rule, context);
        if (newItems !== res.items) {
          res = new ArrayNode(newItems);
        }
      } else if (res instanceof AccessorNode) {
        var newObj = res.object;
        if (res.object) {
          newObj = applyRule(res.object, rule, context);
        }
        var newIndex = res.index;
        if (res.index) {
          newIndex = applyRule(res.index, rule, context);
        }
        if (newObj !== res.object || newIndex !== res.index) {
          res = new AccessorNode(newObj, newIndex);
        }
      } else if (res instanceof IndexNode) {
        var newDims = mapRule(res.dimensions, rule, context);
        if (newDims !== res.dimensions) {
          res = new IndexNode(newDims);
        }
      } else if (res instanceof ObjectNode) {
        var changed = false;
        var newProps = {};
        for (var prop in res.properties) {
          newProps[prop] = applyRule(res.properties[prop], rule, context);
          if (newProps[prop] !== res.properties[prop]) {
            changed = true;
          }
        }
        if (changed) {
          res = new ObjectNode(newProps);
        }
      }
      var repl = rule.r;
      var matches = _ruleMatch(rule.l, res, mergedContext)[0];
      if (!matches && rule.expanded) {
        repl = rule.expanded.r;
        matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
      }
      if (matches) {
        var implicit = res.implicit;
        res = repl.clone();
        if (implicit && "implicit" in repl) {
          res.implicit = true;
        }
        res = res.transform(function(node2) {
          if (node2.isSymbolNode && hasOwnProperty2(matches.placeholders, node2.name)) {
            return matches.placeholders[node2.name].clone();
          } else {
            return node2;
          }
        });
      }
      if (rule.repeat && res !== node) {
        res = applyRule(res, rule, context);
      }
      return res;
    }
    function getSplits(node, context) {
      var res = [];
      var right, rightArgs;
      var makeNode = createMakeNodeFunction(node);
      if (isCommutative(node, context)) {
        for (var i = 0; i < node.args.length; i++) {
          rightArgs = node.args.slice(0);
          rightArgs.splice(i, 1);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([node.args[i], right]));
        }
      } else {
        for (var _i = 1; _i < node.args.length; _i++) {
          var left = node.args[0];
          if (_i > 1) {
            left = makeNode(node.args.slice(0, _i));
          }
          rightArgs = node.args.slice(_i);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([left, right]));
        }
      }
      return res;
    }
    function mergeMatch(match1, match2) {
      var res = {
        placeholders: {}
      };
      if (!match1.placeholders && !match2.placeholders) {
        return res;
      } else if (!match1.placeholders) {
        return match2;
      } else if (!match2.placeholders) {
        return match1;
      }
      for (var key in match1.placeholders) {
        if (hasOwnProperty2(match1.placeholders, key)) {
          res.placeholders[key] = match1.placeholders[key];
          if (hasOwnProperty2(match2.placeholders, key)) {
            if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
              return null;
            }
          }
        }
      }
      for (var _key in match2.placeholders) {
        if (hasOwnProperty2(match2.placeholders, _key)) {
          res.placeholders[_key] = match2.placeholders[_key];
        }
      }
      return res;
    }
    function combineChildMatches(list1, list2) {
      var res = [];
      if (list1.length === 0 || list2.length === 0) {
        return res;
      }
      var merged;
      for (var i1 = 0; i1 < list1.length; i1++) {
        for (var i2 = 0; i2 < list2.length; i2++) {
          merged = mergeMatch(list1[i1], list2[i2]);
          if (merged) {
            res.push(merged);
          }
        }
      }
      return res;
    }
    function mergeChildMatches(childMatches) {
      if (childMatches.length === 0) {
        return childMatches;
      }
      var sets = childMatches.reduce(combineChildMatches);
      var uniqueSets = [];
      var unique = {};
      for (var i = 0; i < sets.length; i++) {
        var s = JSON.stringify(sets[i]);
        if (!unique[s]) {
          unique[s] = true;
          uniqueSets.push(sets[i]);
        }
      }
      return uniqueSets;
    }
    function _ruleMatch(rule, node, context, isSplit) {
      var res = [{
        placeholders: {}
      }];
      if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {
        if (rule instanceof OperatorNode) {
          if (rule.op !== node.op || rule.fn !== node.fn) {
            return [];
          }
        } else if (rule instanceof FunctionNode) {
          if (rule.name !== node.name) {
            return [];
          }
        }
        if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
          var childMatches = [];
          for (var i = 0; i < rule.args.length; i++) {
            var childMatch = _ruleMatch(rule.args[i], node.args[i], context);
            if (childMatch.length === 0) {
              break;
            }
            childMatches.push(childMatch);
          }
          if (childMatches.length !== rule.args.length) {
            if (!isCommutative(node, context) || rule.args.length === 1) {
              return [];
            }
            if (rule.args.length > 2) {
              throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
            }
            var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
            if (leftMatch.length === 0) {
              return [];
            }
            var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
            if (rightMatch.length === 0) {
              return [];
            }
            childMatches = [leftMatch, rightMatch];
          }
          res = mergeChildMatches(childMatches);
        } else if (node.args.length >= 2 && rule.args.length === 2) {
          var splits = getSplits(node, context);
          var splitMatches = [];
          for (var _i2 = 0; _i2 < splits.length; _i2++) {
            var matchSet = _ruleMatch(rule, splits[_i2], context, true);
            splitMatches = splitMatches.concat(matchSet);
          }
          return splitMatches;
        } else if (rule.args.length > 2) {
          throw Error("Unexpected non-binary associative function: " + rule.toString());
        } else {
          return [];
        }
      } else if (rule instanceof SymbolNode) {
        if (rule.name.length === 0) {
          throw new Error("Symbol in rule has 0 length...!?");
        }
        if (SUPPORTED_CONSTANTS[rule.name]) {
          if (rule.name !== node.name) {
            return [];
          }
        } else if (rule.name[0] === "n" || rule.name.substring(0, 2) === "_p") {
          res[0].placeholders[rule.name] = node;
        } else if (rule.name[0] === "v") {
          if (!isConstantNode(node)) {
            res[0].placeholders[rule.name] = node;
          } else {
            return [];
          }
        } else if (rule.name[0] === "c") {
          if (node instanceof ConstantNode) {
            res[0].placeholders[rule.name] = node;
          } else {
            return [];
          }
        } else {
          throw new Error("Invalid symbol in rule: " + rule.name);
        }
      } else if (rule instanceof ConstantNode) {
        if (!equal(rule.value, node.value)) {
          return [];
        }
      } else {
        return [];
      }
      return res;
    }
    function _exactMatch(p, q) {
      if (p instanceof ConstantNode && q instanceof ConstantNode) {
        if (!equal(p.value, q.value)) {
          return false;
        }
      } else if (p instanceof SymbolNode && q instanceof SymbolNode) {
        if (p.name !== q.name) {
          return false;
        }
      } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {
        if (p instanceof OperatorNode) {
          if (p.op !== q.op || p.fn !== q.fn) {
            return false;
          }
        } else if (p instanceof FunctionNode) {
          if (p.name !== q.name) {
            return false;
          }
        }
        if (p.args.length !== q.args.length) {
          return false;
        }
        for (var i = 0; i < p.args.length; i++) {
          if (!_exactMatch(p.args[i], q.args[i])) {
            return false;
          }
        }
      } else {
        return false;
      }
      return true;
    }
    return simplify;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
  var name271 = "simplifyConstant";
  var dependencies272 = ["typed", "parse", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
  var createSimplifyConstant = /* @__PURE__ */ factory(name271, dependencies272, (_ref) => {
    var {
      typed,
      parse,
      config: config2,
      mathWithTransform,
      matrix,
      fraction,
      bignumber,
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      SymbolNode
    } = _ref;
    var {
      isCommutative,
      isAssociative,
      allChildren,
      createMakeNodeFunction
    } = createUtil({
      FunctionNode,
      OperatorNode,
      SymbolNode
    });
    var simplifyConstant = typed("simplifyConstant", {
      Node: (node) => _ensureNode(foldFraction(node, {})),
      "Node, Object": function NodeObject(expr, options) {
        return _ensureNode(foldFraction(expr, options));
      }
    });
    function _removeFractions(thing) {
      if (isFraction(thing)) {
        return thing.valueOf();
      }
      if (thing instanceof Array) {
        return thing.map(_removeFractions);
      }
      if (isMatrix(thing)) {
        return matrix(_removeFractions(thing.valueOf()));
      }
      return thing;
    }
    function _eval(fnname, args, options) {
      try {
        return mathWithTransform[fnname].apply(null, args);
      } catch (ignore) {
        args = args.map(_removeFractions);
        return _toNumber(mathWithTransform[fnname].apply(null, args), options);
      }
    }
    var _toNode = typed({
      Fraction: _fractionToNode,
      number: function number(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      BigNumber: function BigNumber(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode(-n));
        }
        return new ConstantNode(n);
      },
      Complex: function Complex2(s) {
        throw new Error("Cannot convert Complex number to Node");
      },
      string: function string(s) {
        return new ConstantNode(s);
      },
      Matrix: function Matrix(m) {
        return new ArrayNode(m.valueOf().map((e2) => _toNode(e2)));
      }
    });
    function _ensureNode(thing) {
      if (isNode(thing)) {
        return thing;
      }
      return _toNode(thing);
    }
    function _exactFraction(n, options) {
      var exactFractions = options && options.exactFractions !== false;
      if (exactFractions && isFinite(n) && fraction) {
        var f = fraction(n);
        var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
        if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
          return f;
        }
      }
      return n;
    }
    var _toNumber = typed({
      "string, Object": function stringObject(s, options) {
        if (config2.number === "BigNumber") {
          if (bignumber === void 0) {
            noBignumber();
          }
          return bignumber(s);
        } else if (config2.number === "Fraction") {
          if (fraction === void 0) {
            noFraction();
          }
          return fraction(s);
        } else {
          var n = parseFloat(s);
          return _exactFraction(n, options);
        }
      },
      "Fraction, Object": function FractionObject(s, options) {
        return s;
      },
      "BigNumber, Object": function BigNumberObject(s, options) {
        return s;
      },
      "number, Object": function numberObject(s, options) {
        return _exactFraction(s, options);
      },
      "Complex, Object": function ComplexObject(s, options) {
        if (s.im !== 0) {
          return s;
        }
        return _exactFraction(s.re, options);
      },
      "Matrix, Object": function MatrixObject(s, options) {
        return matrix(_exactFraction(s.valueOf()));
      },
      "Array, Object": function ArrayObject(s, options) {
        return s.map(_exactFraction);
      }
    });
    function unaryMinusNode(n) {
      return new OperatorNode("-", "unaryMinus", [n]);
    }
    function _fractionToNode(f) {
      var n;
      var vn = f.s * f.n;
      if (vn < 0) {
        n = new OperatorNode("-", "unaryMinus", [new ConstantNode(-vn)]);
      } else {
        n = new ConstantNode(vn);
      }
      if (f.d === 1) {
        return n;
      }
      return new OperatorNode("/", "divide", [n, new ConstantNode(f.d)]);
    }
    function _foldAccessor(obj, index, options) {
      if (!isIndexNode(index)) {
        return new AccessorNode(_ensureNode(obj), _ensureNode(index));
      }
      if (isArrayNode(obj) || isMatrix(obj)) {
        var remainingDims = Array.from(index.dimensions);
        while (remainingDims.length > 0) {
          if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
            var first = _toNumber(remainingDims.shift().value, options);
            if (isArrayNode(obj)) {
              obj = obj.items[first - 1];
            } else {
              obj = obj.valueOf()[first - 1];
              if (obj instanceof Array) {
                obj = matrix(obj);
              }
            }
          } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
            var second = _toNumber(remainingDims[1].value, options);
            var tryItems = [];
            var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
            for (var item of fromItems) {
              if (isArrayNode(item)) {
                tryItems.push(item.items[second - 1]);
              } else if (isMatrix(obj)) {
                tryItems.push(item[second - 1]);
              } else {
                break;
              }
            }
            if (tryItems.length === fromItems.length) {
              if (isArrayNode(obj)) {
                obj = new ArrayNode(tryItems);
              } else {
                obj = matrix(tryItems);
              }
              remainingDims.splice(1, 1);
            } else {
              break;
            }
          } else {
            break;
          }
        }
        if (remainingDims.length === index.dimensions.length) {
          return new AccessorNode(_ensureNode(obj), index);
        }
        if (remainingDims.length > 0) {
          index = new IndexNode(remainingDims);
          return new AccessorNode(_ensureNode(obj), index);
        }
        return obj;
      }
      if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {
        var key = index.dimensions[0].value;
        if (key in obj.properties) {
          return obj.properties[key];
        }
        return new ConstantNode();
      }
      return new AccessorNode(_ensureNode(obj), index);
    }
    function foldOp(fn, args, makeNode, options) {
      return args.reduce(function(a, b) {
        if (!isNode(a) && !isNode(b)) {
          try {
            return _eval(fn, [a, b], options);
          } catch (ignoreandcontinue) {
          }
          a = _toNode(a);
          b = _toNode(b);
        } else if (!isNode(a)) {
          a = _toNode(a);
        } else if (!isNode(b)) {
          b = _toNode(b);
        }
        return makeNode([a, b]);
      });
    }
    function foldFraction(node, options) {
      switch (node.type) {
        case "SymbolNode":
          return node;
        case "ConstantNode":
          switch (typeof node.value) {
            case "number":
              return _toNumber(node.value, options);
            case "string":
              return node.value;
            default:
              if (!isNaN(node.value))
                return _toNumber(node.value, options);
          }
          return node;
        case "FunctionNode":
          if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {
            return node;
          }
          {
            var operatorFunctions = ["add", "multiply"];
            if (operatorFunctions.indexOf(node.name) === -1) {
              var args = node.args.map((arg) => foldFraction(arg, options));
              if (!args.some(isNode)) {
                try {
                  return _eval(node.name, args, options);
                } catch (ignoreandcontinue) {
                }
              }
              if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
                var sz = [];
                var section = args[0];
                while (isArrayNode(section)) {
                  sz.push(section.items.length);
                  section = section.items[0];
                }
                return matrix(sz);
              }
              return new FunctionNode(node.name, args.map(_ensureNode));
            } else {
            }
          }
        case "OperatorNode": {
          var fn = node.fn.toString();
          var _args;
          var res;
          var makeNode = createMakeNodeFunction(node);
          if (isOperatorNode(node) && node.isUnary()) {
            _args = [foldFraction(node.args[0], options)];
            if (!isNode(_args[0])) {
              res = _eval(fn, _args, options);
            } else {
              res = makeNode(_args);
            }
          } else if (isAssociative(node, options.context)) {
            _args = allChildren(node, options.context);
            _args = _args.map((arg) => foldFraction(arg, options));
            if (isCommutative(fn, options.context)) {
              var consts = [];
              var vars = [];
              for (var i = 0; i < _args.length; i++) {
                if (!isNode(_args[i])) {
                  consts.push(_args[i]);
                } else {
                  vars.push(_args[i]);
                }
              }
              if (consts.length > 1) {
                res = foldOp(fn, consts, makeNode, options);
                vars.unshift(res);
                res = foldOp(fn, vars, makeNode, options);
              } else {
                res = foldOp(fn, _args, makeNode, options);
              }
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            _args = node.args.map((arg) => foldFraction(arg, options));
            res = foldOp(fn, _args, makeNode, options);
          }
          return res;
        }
        case "ParenthesisNode":
          return foldFraction(node.content, options);
        case "AccessorNode":
          return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
        case "ArrayNode": {
          var foldItems = node.items.map((item) => foldFraction(item, options));
          if (foldItems.some(isNode)) {
            return new ArrayNode(foldItems.map(_ensureNode));
          }
          return matrix(foldItems);
        }
        case "IndexNode": {
          return new IndexNode(node.dimensions.map((n) => simplifyConstant(n, options)));
        }
        case "ObjectNode": {
          var foldProps = {};
          for (var prop in node.properties) {
            foldProps[prop] = simplifyConstant(node.properties[prop], options);
          }
          return new ObjectNode(foldProps);
        }
        case "AssignmentNode":
        case "BlockNode":
        case "FunctionAssignmentNode":
        case "RangeNode":
        case "ConditionalNode":
        default:
          throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
      }
    }
    return simplifyConstant;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
  var name272 = "simplifyCore";
  var dependencies273 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createSimplifyCore = /* @__PURE__ */ factory(name272, dependencies273, (_ref) => {
    var {
      typed,
      parse,
      equal,
      isZero,
      add: add2,
      subtract,
      multiply,
      divide: divide2,
      pow: pow2,
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode
    } = _ref;
    var node0 = new ConstantNode(0);
    var node1 = new ConstantNode(1);
    var nodeT = new ConstantNode(true);
    var nodeF = new ConstantNode(false);
    function isAlwaysBoolean(node) {
      return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
    }
    var {
      hasProperty,
      isCommutative
    } = createUtil({
      FunctionNode,
      OperatorNode,
      SymbolNode
    });
    function _simplifyCore(nodeToSimplify) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var context = options ? options.context : void 0;
      if (hasProperty(nodeToSimplify, "trivial", context)) {
        if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
          return _simplifyCore(nodeToSimplify.args[0], options);
        }
        var simpChild = false;
        var childCount = 0;
        nodeToSimplify.forEach((c) => {
          ++childCount;
          if (childCount === 1) {
            simpChild = _simplifyCore(c, options);
          }
        });
        if (childCount === 1) {
          return simpChild;
        }
      }
      var node = nodeToSimplify;
      if (isFunctionNode(node)) {
        var op = getOperator(node.name);
        if (op) {
          if (node.args.length > 2 && hasProperty(node, "associative", context)) {
            while (node.args.length > 2) {
              var last = node.args.pop();
              var seclast = node.args.pop();
              node.args.push(new OperatorNode(op, node.name, [last, seclast]));
            }
          }
          node = new OperatorNode(op, node.name, node.args);
        } else {
          return new FunctionNode(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
        }
      }
      if (isOperatorNode(node) && node.isUnary()) {
        var a0 = _simplifyCore(node.args[0], options);
        if (node.op === "~") {
          if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
            return a0.args[0];
          }
        }
        if (node.op === "not") {
          if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
            if (isAlwaysBoolean(a0.args[0])) {
              return a0.args[0];
            }
          }
        }
        var finish = true;
        if (node.op === "-") {
          if (isOperatorNode(a0)) {
            if (a0.isBinary() && a0.fn === "subtract") {
              node = new OperatorNode("-", "subtract", [a0.args[1], a0.args[0]]);
              finish = false;
            }
            if (a0.isUnary() && a0.op === "-") {
              return a0.args[0];
            }
          }
        }
        if (finish)
          return new OperatorNode(node.op, node.fn, [a0]);
      }
      if (isOperatorNode(node) && node.isBinary()) {
        var _a = _simplifyCore(node.args[0], options);
        var a1 = _simplifyCore(node.args[1], options);
        if (node.op === "+") {
          if (isConstantNode(_a) && isZero(_a.value)) {
            return a1;
          }
          if (isConstantNode(a1) && isZero(a1.value)) {
            return _a;
          }
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            a1 = a1.args[0];
            node = new OperatorNode("-", "subtract", [_a, a1]);
          }
        }
        if (node.op === "-") {
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            return _simplifyCore(new OperatorNode("+", "add", [_a, a1.args[0]]), options);
          }
          if (isConstantNode(_a) && isZero(_a.value)) {
            return _simplifyCore(new OperatorNode("-", "unaryMinus", [a1]));
          }
          if (isConstantNode(a1) && isZero(a1.value)) {
            return _a;
          }
          return new OperatorNode(node.op, node.fn, [_a, a1]);
        }
        if (node.op === "*") {
          if (isConstantNode(_a)) {
            if (isZero(_a.value)) {
              return node0;
            } else if (equal(_a.value, 1)) {
              return a1;
            }
          }
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node0;
            } else if (equal(a1.value, 1)) {
              return _a;
            }
            if (isCommutative(node, context)) {
              return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit);
            }
          }
          return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);
        }
        if (node.op === "/") {
          if (isConstantNode(_a) && isZero(_a.value)) {
            return node0;
          }
          if (isConstantNode(a1) && equal(a1.value, 1)) {
            return _a;
          }
          return new OperatorNode(node.op, node.fn, [_a, a1]);
        }
        if (node.op === "^") {
          if (isConstantNode(a1)) {
            if (isZero(a1.value)) {
              return node1;
            } else if (equal(a1.value, 1)) {
              return _a;
            }
          }
        }
        if (node.op === "and") {
          if (isConstantNode(_a)) {
            if (_a.value) {
              if (isAlwaysBoolean(a1))
                return a1;
            } else {
              return nodeF;
            }
          }
          if (isConstantNode(a1)) {
            if (a1.value) {
              if (isAlwaysBoolean(_a))
                return _a;
            } else {
              return nodeF;
            }
          }
        }
        if (node.op === "or") {
          if (isConstantNode(_a)) {
            if (_a.value) {
              return nodeT;
            } else {
              if (isAlwaysBoolean(a1))
                return a1;
            }
          }
          if (isConstantNode(a1)) {
            if (a1.value) {
              return nodeT;
            } else {
              if (isAlwaysBoolean(_a))
                return _a;
            }
          }
        }
        return new OperatorNode(node.op, node.fn, [_a, a1]);
      }
      if (isOperatorNode(node)) {
        return new OperatorNode(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options)));
      }
      if (isArrayNode(node)) {
        return new ArrayNode(node.items.map((n) => _simplifyCore(n, options)));
      }
      if (isAccessorNode(node)) {
        return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
      }
      if (isIndexNode(node)) {
        return new IndexNode(node.dimensions.map((n) => _simplifyCore(n, options)));
      }
      if (isObjectNode(node)) {
        var newProps = {};
        for (var prop in node.properties) {
          newProps[prop] = _simplifyCore(node.properties[prop], options);
        }
        return new ObjectNode(newProps);
      }
      return node;
    }
    return typed(name272, {
      Node: _simplifyCore,
      "Node,Object": _simplifyCore
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/resolve.js
  var name273 = "resolve";
  var dependencies274 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
  var createResolve = /* @__PURE__ */ factory(name273, dependencies274, (_ref) => {
    var {
      typed,
      parse,
      ConstantNode,
      FunctionNode,
      OperatorNode,
      ParenthesisNode
    } = _ref;
    function _resolve(node, scope) {
      var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
      if (!scope) {
        return node;
      }
      if (isSymbolNode(node)) {
        if (within.has(node.name)) {
          var variables = Array.from(within).join(", ");
          throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
        }
        var value = scope.get(node.name);
        if (isNode(value)) {
          var nextWithin = new Set(within);
          nextWithin.add(node.name);
          return _resolve(value, scope, nextWithin);
        } else if (typeof value === "number") {
          return parse(String(value));
        } else if (value !== void 0) {
          return new ConstantNode(value);
        } else {
          return node;
        }
      } else if (isOperatorNode(node)) {
        var args = node.args.map(function(arg) {
          return _resolve(arg, scope, within);
        });
        return new OperatorNode(node.op, node.fn, args, node.implicit);
      } else if (isParenthesisNode(node)) {
        return new ParenthesisNode(_resolve(node.content, scope, within));
      } else if (isFunctionNode(node)) {
        var _args = node.args.map(function(arg) {
          return _resolve(arg, scope, within);
        });
        return new FunctionNode(node.name, _args);
      }
      return node.map((child) => _resolve(child, scope, within));
    }
    return typed("resolve", {
      Node: _resolve,
      "Node, Map | null | undefined": _resolve,
      "Node, Object": (n, scope) => _resolve(n, createMap(scope)),
      "Array | Matrix": typed.referToSelf((self2) => (A) => A.map((n) => self2(n))),
      "Array | Matrix, null | undefined": typed.referToSelf((self2) => (A) => A.map((n) => self2(n))),
      "Array, Object": typed.referTo("Array,Map", (selfAM) => (A, scope) => selfAM(A, createMap(scope))),
      "Matrix, Object": typed.referTo("Matrix,Map", (selfMM) => (A, scope) => selfMM(A, createMap(scope))),
      "Array | Matrix, Map": typed.referToSelf((self2) => (A, scope) => A.map((n) => self2(n, scope)))
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
  var name274 = "symbolicEqual";
  var dependencies275 = ["parse", "simplify", "typed", "OperatorNode"];
  var createSymbolicEqual = /* @__PURE__ */ factory(name274, dependencies275, (_ref) => {
    var {
      parse,
      simplify,
      typed,
      OperatorNode
    } = _ref;
    function _symbolicEqual(e1, e2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var diff = new OperatorNode("-", "subtract", [e1, e2]);
      var simplified = simplify(diff, {}, options);
      return isConstantNode(simplified) && !simplified.value;
    }
    return typed(name274, {
      "Node, Node": _symbolicEqual,
      "Node, Node, Object": _symbolicEqual
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/derivative.js
  var name275 = "derivative";
  var dependencies276 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createDerivative = /* @__PURE__ */ factory(name275, dependencies276, (_ref) => {
    var {
      typed,
      config: config2,
      parse,
      simplify,
      equal,
      isZero,
      numeric: numeric2,
      ConstantNode,
      FunctionNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode
    } = _ref;
    function plainDerivative(expr, variable) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        simplify: true
      };
      var constNodes = {};
      constTag(constNodes, expr, variable.name);
      var res = _derivative(expr, constNodes);
      return options.simplify ? simplify(res) : res;
    }
    typed.addConversion({
      from: "identifier",
      to: "SymbolNode",
      convert: parse
    });
    var derivative = typed(name275, {
      "Node, SymbolNode": plainDerivative,
      "Node, SymbolNode, Object": plainDerivative
    });
    typed.removeConversion({
      from: "identifier",
      to: "SymbolNode",
      convert: parse
    });
    derivative._simplify = true;
    derivative.toTex = function(deriv) {
      return _derivTex.apply(null, deriv.args);
    };
    var _derivTex = typed("_derivTex", {
      "Node, SymbolNode": function NodeSymbolNode(expr, x) {
        if (isConstantNode(expr) && typeOf(expr.value) === "string") {
          return _derivTex(parse(expr.value).toString(), x.toString(), 1);
        } else {
          return _derivTex(expr.toTex(), x.toString(), 1);
        }
      },
      "Node, ConstantNode": function NodeConstantNode(expr, x) {
        if (typeOf(x.value) === "string") {
          return _derivTex(expr, parse(x.value));
        } else {
          throw new Error("The second parameter to 'derivative' is a non-string constant");
        }
      },
      "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
        return _derivTex(expr.toString(), x.name, order.value);
      },
      "string, string, number": function stringStringNumber(expr, x, order) {
        var d;
        if (order === 1) {
          d = "{d\\over d" + x + "}";
        } else {
          d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
        }
        return d + "\\left[".concat(expr, "\\right]");
      }
    });
    var constTag = typed("constTag", {
      "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
        constNodes[node] = true;
        return true;
      },
      "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
        if (node.name !== varName) {
          constNodes[node] = true;
          return true;
        }
        return false;
      },
      "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
        return constTag(constNodes, node.content, varName);
      },
      "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
        if (node.params.indexOf(varName) === -1) {
          constNodes[node] = true;
          return true;
        }
        return constTag(constNodes, node.expr, varName);
      },
      "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
        if (node.args.length > 0) {
          var isConst = constTag(constNodes, node.args[0], varName);
          for (var i = 1; i < node.args.length; ++i) {
            isConst = constTag(constNodes, node.args[i], varName) && isConst;
          }
          if (isConst) {
            constNodes[node] = true;
            return true;
          }
        }
        return false;
      }
    });
    var _derivative = typed("_derivative", {
      "ConstantNode, Object": function ConstantNodeObject(node) {
        return createConstantNode2(0);
      },
      "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        return createConstantNode2(1);
      },
      "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
        return new ParenthesisNode(_derivative(node.content, constNodes));
      },
      "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        return _derivative(node.expr, constNodes);
      },
      "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
        if (node.args.length !== 1) {
          funcArgsCheck(node);
        }
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        var arg0 = node.args[0];
        var arg1;
        var div2 = false;
        var negative = false;
        var funcDerivative;
        switch (node.name) {
          case "cbrt":
            div2 = true;
            funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(3), new OperatorNode("^", "pow", [arg0, new OperatorNode("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
            break;
          case "sqrt":
          case "nthRoot":
            if (node.args.length === 1) {
              div2 = true;
              funcDerivative = new OperatorNode("*", "multiply", [createConstantNode2(2), new FunctionNode("sqrt", [arg0])]);
            } else if (node.args.length === 2) {
              arg1 = new OperatorNode("/", "divide", [createConstantNode2(1), node.args[1]]);
              constNodes[arg1] = constNodes[node.args[1]];
              return _derivative(new OperatorNode("^", "pow", [arg0, arg1]), constNodes);
            }
            break;
          case "log10":
            arg1 = createConstantNode2(10);
          case "log":
            if (!arg1 && node.args.length === 1) {
              funcDerivative = arg0.clone();
              div2 = true;
            } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
              funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("log", [arg1 || node.args[1]])]);
              div2 = true;
            } else if (node.args.length === 2) {
              return _derivative(new OperatorNode("/", "divide", [new FunctionNode("log", [arg0]), new FunctionNode("log", [node.args[1]])]), constNodes);
            }
            break;
          case "pow":
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode("^", "pow", [arg0, node.args[1]]), constNodes);
          case "exp":
            funcDerivative = new FunctionNode("exp", [arg0.clone()]);
            break;
          case "sin":
            funcDerivative = new FunctionNode("cos", [arg0.clone()]);
            break;
          case "cos":
            funcDerivative = new OperatorNode("-", "unaryMinus", [new FunctionNode("sin", [arg0.clone()])]);
            break;
          case "tan":
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sec", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "sec":
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tan", [arg0.clone()])]);
            break;
          case "csc":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("cot", [arg0.clone()])]);
            break;
          case "cot":
            negative = true;
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csc", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "asin":
            div2 = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
            break;
          case "acos":
            div2 = true;
            negative = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
            break;
          case "atan":
            div2 = true;
            funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
            break;
          case "asec":
            div2 = true;
            funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acsc":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acot":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
            break;
          case "sinh":
            funcDerivative = new FunctionNode("cosh", [arg0.clone()]);
            break;
          case "cosh":
            funcDerivative = new FunctionNode("sinh", [arg0.clone()]);
            break;
          case "tanh":
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("sech", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "sech":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("tanh", [arg0.clone()])]);
            break;
          case "csch":
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [node, new FunctionNode("coth", [arg0.clone()])]);
            break;
          case "coth":
            negative = true;
            funcDerivative = new OperatorNode("^", "pow", [new FunctionNode("csch", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "asinh":
            div2 = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
            break;
          case "acosh":
            div2 = true;
            funcDerivative = new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
            break;
          case "atanh":
            div2 = true;
            funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
            break;
          case "asech":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [arg0.clone(), new FunctionNode("sqrt", [new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
            break;
          case "acsch":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode("*", "multiply", [new FunctionNode("abs", [arg0.clone()]), new FunctionNode("sqrt", [new OperatorNode("+", "add", [new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acoth":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode("-", "subtract", [createConstantNode2(1), new OperatorNode("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
            break;
          case "abs":
            funcDerivative = new OperatorNode("/", "divide", [new FunctionNode(new SymbolNode("abs"), [arg0.clone()]), arg0.clone()]);
            break;
          case "gamma":
          default:
            throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
        }
        var op, func;
        if (div2) {
          op = "/";
          func = "divide";
        } else {
          op = "*";
          func = "multiply";
        }
        var chainDerivative = _derivative(arg0, constNodes);
        if (negative) {
          chainDerivative = new OperatorNode("-", "unaryMinus", [chainDerivative]);
        }
        return new OperatorNode(op, func, [chainDerivative, funcDerivative]);
      },
      "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        if (node.op === "+") {
          return new OperatorNode(node.op, node.fn, node.args.map(function(arg) {
            return _derivative(arg, constNodes);
          }));
        }
        if (node.op === "-") {
          if (node.isUnary()) {
            return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
          }
          if (node.isBinary()) {
            return new OperatorNode(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
          }
        }
        if (node.op === "*") {
          var constantTerms = node.args.filter(function(arg) {
            return constNodes[arg] !== void 0;
          });
          if (constantTerms.length > 0) {
            var nonConstantTerms = node.args.filter(function(arg) {
              return constNodes[arg] === void 0;
            });
            var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode("*", "multiply", nonConstantTerms);
            var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
            return new OperatorNode("*", "multiply", newArgs);
          }
          return new OperatorNode("+", "add", node.args.map(function(argOuter) {
            return new OperatorNode("*", "multiply", node.args.map(function(argInner) {
              return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
            }));
          }));
        }
        if (node.op === "/" && node.isBinary()) {
          var arg0 = node.args[0];
          var arg1 = node.args[1];
          if (constNodes[arg1] !== void 0) {
            return new OperatorNode("/", "divide", [_derivative(arg0, constNodes), arg1]);
          }
          if (constNodes[arg0] !== void 0) {
            return new OperatorNode("*", "multiply", [new OperatorNode("-", "unaryMinus", [arg0]), new OperatorNode("/", "divide", [_derivative(arg1, constNodes), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
          }
          return new OperatorNode("/", "divide", [new OperatorNode("-", "subtract", [new OperatorNode("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
        }
        if (node.op === "^" && node.isBinary()) {
          var _arg = node.args[0];
          var _arg2 = node.args[1];
          if (constNodes[_arg] !== void 0) {
            if (isConstantNode(_arg) && (isZero(_arg.value) || equal(_arg.value, 1))) {
              return createConstantNode2(0);
            }
            return new OperatorNode("*", "multiply", [node, new OperatorNode("*", "multiply", [new FunctionNode("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
          }
          if (constNodes[_arg2] !== void 0) {
            if (isConstantNode(_arg2)) {
              if (isZero(_arg2.value)) {
                return createConstantNode2(0);
              }
              if (equal(_arg2.value, 1)) {
                return _derivative(_arg, constNodes);
              }
            }
            var powMinusOne = new OperatorNode("^", "pow", [_arg.clone(), new OperatorNode("-", "subtract", [_arg2, createConstantNode2(1)])]);
            return new OperatorNode("*", "multiply", [_arg2.clone(), new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
          }
          return new OperatorNode("*", "multiply", [new OperatorNode("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode("+", "add", [new OperatorNode("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode("log", [_arg.clone()])])])]);
        }
        throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
      }
    });
    function funcArgsCheck(node) {
      if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
        return;
      }
      for (var i = 0; i < node.args.length; ++i) {
        node.args[i] = createConstantNode2(0);
      }
      node.compile().evaluate();
      throw new Error("Expected TypeError, but none found");
    }
    function createConstantNode2(value, valueType) {
      return new ConstantNode(numeric2(value, valueType || config2.number));
    }
    return derivative;
  });

  // node_modules/mathjs/lib/esm/function/algebra/rationalize.js
  var name276 = "rationalize";
  var dependencies277 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
  var createRationalize = /* @__PURE__ */ factory(name276, dependencies277, (_ref) => {
    var {
      config: config2,
      typed,
      equal,
      isZero,
      add: add2,
      subtract,
      multiply,
      divide: divide2,
      pow: pow2,
      parse,
      simplifyConstant,
      simplifyCore,
      simplify,
      fraction,
      bignumber,
      mathWithTransform,
      matrix,
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      SymbolNode,
      ParenthesisNode
    } = _ref;
    function _rationalize(expr) {
      var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var setRules = rulesRationalize();
      var polyRet = polynomial(expr, scope, true, setRules.firstRules);
      var nVars = polyRet.variables.length;
      var noExactFractions = {
        exactFractions: false
      };
      var withExactFractions = {
        exactFractions: true
      };
      expr = polyRet.expression;
      if (nVars >= 1) {
        expr = expandPower(expr);
        var sBefore;
        var rules;
        var eDistrDiv = true;
        var redoInic = false;
        expr = simplify(expr, setRules.firstRules, {}, noExactFractions);
        var s;
        while (true) {
          rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
          expr = simplify(expr, rules, {}, withExactFractions);
          eDistrDiv = !eDistrDiv;
          s = expr.toString();
          if (s === sBefore) {
            break;
          }
          redoInic = true;
          sBefore = s;
        }
        if (redoInic) {
          expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);
        }
        expr = simplify(expr, setRules.finalRules, {}, noExactFractions);
      }
      var coefficients = [];
      var retRationalize = {};
      if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
        if (nVars === 1) {
          expr.args[0] = polyToCanonical(expr.args[0], coefficients);
          expr.args[1] = polyToCanonical(expr.args[1]);
        }
        if (detailed) {
          retRationalize.numerator = expr.args[0];
          retRationalize.denominator = expr.args[1];
        }
      } else {
        if (nVars === 1) {
          expr = polyToCanonical(expr, coefficients);
        }
        if (detailed) {
          retRationalize.numerator = expr;
          retRationalize.denominator = null;
        }
      }
      if (!detailed)
        return expr;
      retRationalize.coefficients = coefficients;
      retRationalize.variables = polyRet.variables;
      retRationalize.expression = expr;
      return retRationalize;
    }
    return typed(name276, {
      Node: _rationalize,
      "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
      "Node, Object": _rationalize,
      "Node, Object, boolean": _rationalize
    });
    function polynomial(expr, scope, extended, rules) {
      var variables = [];
      var node = simplify(expr, rules, scope, {
        exactFractions: false
      });
      extended = !!extended;
      var oper = "+-*" + (extended ? "/" : "");
      recPoly(node);
      var retFunc = {};
      retFunc.expression = node;
      retFunc.variables = variables;
      return retFunc;
      function recPoly(node2) {
        var tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if (node2.op === "^") {
            if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
              throw new Error("There is a non-integer exponent");
            } else {
              recPoly(node2.args[0]);
            }
          } else {
            if (oper.indexOf(node2.op) === -1) {
              throw new Error("Operator " + node2.op + " invalid in polynomial expression");
            }
            for (var i = 0; i < node2.args.length; i++) {
              recPoly(node2.args[i]);
            }
          }
        } else if (tp === "SymbolNode") {
          var _name = node2.name;
          var pos = variables.indexOf(_name);
          if (pos === -1) {
            variables.push(_name);
          }
        } else if (tp === "ParenthesisNode") {
          recPoly(node2.content);
        } else if (tp !== "ConstantNode") {
          throw new Error("type " + tp + " is not allowed in polynomial expression");
        }
      }
    }
    function rulesRationalize() {
      var oldRules = [
        simplifyCore,
        {
          l: "n+n",
          r: "2*n"
        },
        {
          l: "n+-n",
          r: "0"
        },
        simplifyConstant,
        {
          l: "n*(n1^-1)",
          r: "n/n1"
        },
        {
          l: "n*n1^-n2",
          r: "n/n1^n2"
        },
        {
          l: "n1^-1",
          r: "1/n1"
        },
        {
          l: "n*(n1/n2)",
          r: "(n*n1)/n2"
        },
        {
          l: "1*n",
          r: "n"
        }
      ];
      var rulesFirst = [
        {
          l: "(-n1)/(-n2)",
          r: "n1/n2"
        },
        {
          l: "(-n1)*(-n2)",
          r: "n1*n2"
        },
        {
          l: "n1--n2",
          r: "n1+n2"
        },
        {
          l: "n1-n2",
          r: "n1+(-n2)"
        },
        {
          l: "(n1+n2)*n3",
          r: "(n1*n3 + n2*n3)"
        },
        {
          l: "n1*(n2+n3)",
          r: "(n1*n2+n1*n3)"
        },
        {
          l: "c1*n + c2*n",
          r: "(c1+c2)*n"
        },
        {
          l: "c1*n + n",
          r: "(c1+1)*n"
        },
        {
          l: "c1*n - c2*n",
          r: "(c1-c2)*n"
        },
        {
          l: "c1*n - n",
          r: "(c1-1)*n"
        },
        {
          l: "v/c",
          r: "(1/c)*v"
        },
        {
          l: "v/-c",
          r: "-(1/c)*v"
        },
        {
          l: "-v*-c",
          r: "c*v"
        },
        {
          l: "-v*c",
          r: "-c*v"
        },
        {
          l: "v*-c",
          r: "-c*v"
        },
        {
          l: "v*c",
          r: "c*v"
        },
        {
          l: "-(-n1*n2)",
          r: "(n1*n2)"
        },
        {
          l: "-(n1*n2)",
          r: "(-n1*n2)"
        },
        {
          l: "-(-n1+n2)",
          r: "(n1-n2)"
        },
        {
          l: "-(n1+n2)",
          r: "(-n1-n2)"
        },
        {
          l: "(n1^n2)^n3",
          r: "(n1^(n2*n3))"
        },
        {
          l: "-(-n1/n2)",
          r: "(n1/n2)"
        },
        {
          l: "-(n1/n2)",
          r: "(-n1/n2)"
        }
      ];
      var rulesDistrDiv = [
        {
          l: "(n1/n2 + n3/n4)",
          r: "((n1*n4 + n3*n2)/(n2*n4))"
        },
        {
          l: "(n1/n2 + n3)",
          r: "((n1 + n3*n2)/n2)"
        },
        {
          l: "(n1 + n2/n3)",
          r: "((n1*n3 + n2)/n3)"
        }
      ];
      var rulesSucDiv = [
        {
          l: "(n1/(n2/n3))",
          r: "((n1*n3)/n2)"
        },
        {
          l: "(n1/n2/n3)",
          r: "(n1/(n2*n3))"
        }
      ];
      var setRules = {};
      setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
      setRules.distrDivRules = rulesDistrDiv;
      setRules.sucDivRules = rulesSucDiv;
      setRules.firstRulesAgain = oldRules.concat(rulesFirst);
      setRules.finalRules = [
        simplifyCore,
        {
          l: "n*-n",
          r: "-n^2"
        },
        {
          l: "n*n",
          r: "n^2"
        },
        simplifyConstant,
        {
          l: "n*-n^n1",
          r: "-n^(n1+1)"
        },
        {
          l: "n*n^n1",
          r: "n^(n1+1)"
        },
        {
          l: "n^n1*-n^n2",
          r: "-n^(n1+n2)"
        },
        {
          l: "n^n1*n^n2",
          r: "n^(n1+n2)"
        },
        {
          l: "n^n1*-n",
          r: "-n^(n1+1)"
        },
        {
          l: "n^n1*n",
          r: "n^(n1+1)"
        },
        {
          l: "n^n1/-n",
          r: "-n^(n1-1)"
        },
        {
          l: "n^n1/n",
          r: "n^(n1-1)"
        },
        {
          l: "n/-n^n1",
          r: "-n^(1-n1)"
        },
        {
          l: "n/n^n1",
          r: "n^(1-n1)"
        },
        {
          l: "n^n1/-n^n2",
          r: "n^(n1-n2)"
        },
        {
          l: "n^n1/n^n2",
          r: "n^(n1-n2)"
        },
        {
          l: "n1+(-n2*n3)",
          r: "n1-n2*n3"
        },
        {
          l: "v*(-c)",
          r: "-c*v"
        },
        {
          l: "n1+-n2",
          r: "n1-n2"
        },
        {
          l: "v*c",
          r: "c*v"
        },
        {
          l: "(n1^n2)^n3",
          r: "(n1^(n2*n3))"
        }
      ];
      return setRules;
    }
    function expandPower(node, parent, indParent) {
      var tp = node.type;
      var internal = arguments.length > 1;
      if (tp === "OperatorNode" && node.isBinary()) {
        var does = false;
        var val;
        if (node.op === "^") {
          if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
            val = parseFloat(node.args[1].value);
            does = val >= 2 && isInteger(val);
          }
        }
        if (does) {
          if (val > 2) {
            var nEsqTopo = node.args[0];
            var nDirTopo = new OperatorNode("^", "pow", [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);
            node = new OperatorNode("*", "multiply", [nEsqTopo, nDirTopo]);
          } else {
            node = new OperatorNode("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
          }
          if (internal) {
            if (indParent === "content") {
              parent.content = node;
            } else {
              parent.args[indParent] = node;
            }
          }
        }
      }
      if (tp === "ParenthesisNode") {
        expandPower(node.content, node, "content");
      } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
        for (var i = 0; i < node.args.length; i++) {
          expandPower(node.args[i], node, i);
        }
      }
      if (!internal) {
        return node;
      }
    }
    function polyToCanonical(node, coefficients) {
      if (coefficients === void 0) {
        coefficients = [];
      }
      coefficients[0] = 0;
      var o = {};
      o.cte = 1;
      o.oper = "+";
      o.fire = "";
      var maxExpo = 0;
      var varname = "";
      recurPol(node, null, o);
      maxExpo = coefficients.length - 1;
      var first = true;
      var no;
      for (var i = maxExpo; i >= 0; i--) {
        if (coefficients[i] === 0)
          continue;
        var n16 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));
        var op = coefficients[i] < 0 ? "-" : "+";
        if (i > 0) {
          var n25 = new SymbolNode(varname);
          if (i > 1) {
            var n3 = new ConstantNode(i);
            n25 = new OperatorNode("^", "pow", [n25, n3]);
          }
          if (coefficients[i] === -1 && first) {
            n16 = new OperatorNode("-", "unaryMinus", [n25]);
          } else if (Math.abs(coefficients[i]) === 1) {
            n16 = n25;
          } else {
            n16 = new OperatorNode("*", "multiply", [n16, n25]);
          }
        }
        if (first) {
          no = n16;
        } else if (op === "+") {
          no = new OperatorNode("+", "add", [no, n16]);
        } else {
          no = new OperatorNode("-", "subtract", [no, n16]);
        }
        first = false;
      }
      if (first) {
        return new ConstantNode(0);
      } else {
        return no;
      }
      function recurPol(node2, noPai, o2) {
        var tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if ("+-*^".indexOf(node2.op) === -1)
            throw new Error("Operator " + node2.op + " invalid");
          if (noPai !== null) {
            if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
              throw new Error("Invalid " + node2.op + " placing");
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
              throw new Error("Invalid " + node2.op + " placing");
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
              throw new Error("Invalid " + node2.op + " placing");
            }
          }
          if (node2.op === "^" || node2.op === "*") {
            o2.fire = node2.op;
          }
          for (var _i = 0; _i < node2.args.length; _i++) {
            if (node2.fn === "unaryMinus")
              o2.oper = "-";
            if (node2.op === "+" || node2.fn === "subtract") {
              o2.fire = "";
              o2.cte = 1;
              o2.oper = _i === 0 ? "+" : node2.op;
            }
            o2.noFil = _i;
            recurPol(node2.args[_i], node2, o2);
          }
        } else if (tp === "SymbolNode") {
          if (node2.name !== varname && varname !== "") {
            throw new Error("There is more than one variable");
          }
          varname = node2.name;
          if (noPai === null) {
            coefficients[1] = 1;
            return;
          }
          if (noPai.op === "^" && o2.noFil !== 0) {
            throw new Error("In power the variable should be the first parameter");
          }
          if (noPai.op === "*" && o2.noFil !== 1) {
            throw new Error("In multiply the variable should be the second parameter");
          }
          if (o2.fire === "" || o2.fire === "*") {
            if (maxExpo < 1)
              coefficients[1] = 0;
            coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
            maxExpo = Math.max(1, maxExpo);
          }
        } else if (tp === "ConstantNode") {
          var valor = parseFloat(node2.value);
          if (noPai === null) {
            coefficients[0] = valor;
            return;
          }
          if (noPai.op === "^") {
            if (o2.noFil !== 1)
              throw new Error("Constant cannot be powered");
            if (!isInteger(valor) || valor <= 0) {
              throw new Error("Non-integer exponent is not allowed");
            }
            for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {
              coefficients[_i2] = 0;
            }
            if (valor > maxExpo)
              coefficients[valor] = 0;
            coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
            maxExpo = Math.max(valor, maxExpo);
            return;
          }
          o2.cte = valor;
          if (o2.fire === "") {
            coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
          }
        } else {
          throw new Error("Type " + tp + " is not allowed");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/json/reviver.js
  var name277 = "reviver";
  var dependencies278 = ["classes"];
  var createReviver = /* @__PURE__ */ factory(name277, dependencies278, (_ref) => {
    var {
      classes
    } = _ref;
    return function reviver(key, value) {
      var constructor = classes[value && value.mathjs];
      if (constructor && typeof constructor.fromJSON === "function") {
        return constructor.fromJSON(value);
      }
      return value;
    };
  });

  // node_modules/mathjs/lib/esm/json/replacer.js
  var name278 = "replacer";
  var dependencies279 = [];
  var createReplacer = /* @__PURE__ */ factory(name278, dependencies279, () => {
    return function replacer(key, value) {
      if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
        return {
          mathjs: "number",
          value: String(value)
        };
      }
      return value;
    };
  });

  // node_modules/mathjs/lib/esm/version.js
  var version = "11.3.2";

  // node_modules/mathjs/lib/esm/constants.js
  var createTrue = /* @__PURE__ */ factory("true", [], () => true);
  var createFalse = /* @__PURE__ */ factory("false", [], () => false);
  var createNull = /* @__PURE__ */ factory("null", [], () => null);
  var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
    var {
      config: config2,
      BigNumber
    } = _ref;
    return config2.number === "BigNumber" ? new BigNumber(Infinity) : Infinity;
  });
  var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
    var {
      config: config2,
      BigNumber
    } = _ref2;
    return config2.number === "BigNumber" ? new BigNumber(NaN) : NaN;
  });
  var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
    var {
      config: config2,
      BigNumber
    } = _ref3;
    return config2.number === "BigNumber" ? createBigNumberPi(BigNumber) : pi;
  });
  var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
    var {
      config: config2,
      BigNumber
    } = _ref4;
    return config2.number === "BigNumber" ? createBigNumberTau(BigNumber) : tau;
  });
  var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
    var {
      config: config2,
      BigNumber
    } = _ref5;
    return config2.number === "BigNumber" ? createBigNumberE(BigNumber) : e;
  });
  var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
    var {
      config: config2,
      BigNumber
    } = _ref6;
    return config2.number === "BigNumber" ? createBigNumberPhi(BigNumber) : phi;
  });
  var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
    var {
      config: config2,
      BigNumber
    } = _ref7;
    return config2.number === "BigNumber" ? new BigNumber(2).ln() : Math.LN2;
  });
  var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
    var {
      config: config2,
      BigNumber
    } = _ref8;
    return config2.number === "BigNumber" ? new BigNumber(10).ln() : Math.LN10;
  });
  var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
    var {
      config: config2,
      BigNumber
    } = _ref9;
    return config2.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(2).ln()) : Math.LOG2E;
  });
  var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
    var {
      config: config2,
      BigNumber
    } = _ref10;
    return config2.number === "BigNumber" ? new BigNumber(1).div(new BigNumber(10).ln()) : Math.LOG10E;
  });
  var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
    "SQRT1_2",
    ["config", "?BigNumber"],
    (_ref11) => {
      var {
        config: config2,
        BigNumber
      } = _ref11;
      return config2.number === "BigNumber" ? new BigNumber("0.5").sqrt() : Math.SQRT1_2;
    }
  );
  var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
    var {
      config: config2,
      BigNumber
    } = _ref12;
    return config2.number === "BigNumber" ? new BigNumber(2).sqrt() : Math.SQRT2;
  });
  var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
    var {
      Complex: Complex2
    } = _ref13;
    return Complex2.I;
  });
  var createUppercasePi = /* @__PURE__ */ factory("PI", ["pi"], (_ref14) => {
    var {
      pi: pi2
    } = _ref14;
    return pi2;
  });
  var createUppercaseE = /* @__PURE__ */ factory("E", ["e"], (_ref15) => {
    var {
      e: e2
    } = _ref15;
    return e2;
  });
  var createVersion = /* @__PURE__ */ factory("version", [], () => version);
  function recreateFactory(name297, dependencies298, create2) {
    return factory(name297, dependencies298, create2, {
      recreateOnConfigChange: true
    });
  }

  // node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
  var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
  var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
  var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
  var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
  var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
  var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
  var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
  var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
  var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
  var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
  var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
  var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
  var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
  var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
  var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
  var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
  var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
  var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
  var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
  var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
  var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
  var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
  var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
  var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
  var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
  var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
  var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
  var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
  var createEfimovFactor = numberFactory("efimovFactor", 22.7);
  var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
  var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
  var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
  var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
  var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
  var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
  var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
  var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
  var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
  var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
  var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
  var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
  var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
  var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
  var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
  var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
  var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
  var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
  var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
  var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
  var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
  function unitFactory(name297, valueStr, unitStr) {
    var dependencies298 = ["config", "Unit", "BigNumber"];
    return factory(name297, dependencies298, (_ref) => {
      var {
        config: config2,
        Unit,
        BigNumber
      } = _ref;
      var value = config2.number === "BigNumber" ? new BigNumber(valueStr) : parseFloat(valueStr);
      var unit = new Unit(value, unitStr);
      unit.fixPrefix = true;
      return unit;
    });
  }
  function numberFactory(name297, value) {
    var dependencies298 = ["config", "BigNumber"];
    return factory(name297, dependencies298, (_ref2) => {
      var {
        config: config2,
        BigNumber
      } = _ref2;
      return config2.number === "BigNumber" ? new BigNumber(value) : value;
    });
  }

  // node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
  var name279 = "apply";
  var dependencies280 = ["typed", "isInteger"];
  var createApplyTransform = /* @__PURE__ */ factory(name279, dependencies280, (_ref) => {
    var {
      typed,
      isInteger: isInteger2
    } = _ref;
    var apply = createApply({
      typed,
      isInteger: isInteger2
    });
    return typed("apply", {
      "...any": function any(args) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
        try {
          return apply.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/column.transform.js
  var name280 = "column";
  var dependencies281 = ["typed", "Index", "matrix", "range"];
  var createColumnTransform = /* @__PURE__ */ factory(name280, dependencies281, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    var column = createColumn({
      typed,
      Index,
      matrix,
      range
    });
    return typed("column", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return column.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
  function compileInlineExpression(expression, math2, scope) {
    var symbol = expression.filter(function(node) {
      return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
    })[0];
    if (!symbol) {
      throw new Error('No undefined variable found in inline expression "' + expression + '"');
    }
    var name297 = symbol.name;
    var subScope = createSubScope(scope);
    var eq = expression.compile();
    return function inlineExpression(x) {
      subScope.set(name297, x);
      return eq.evaluate(subScope);
    };
  }

  // node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
  var name281 = "filter";
  var dependencies282 = ["typed"];
  var createFilterTransform = /* @__PURE__ */ factory(name281, dependencies282, (_ref) => {
    var {
      typed
    } = _ref;
    function filterTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return filter2(x, callback);
    }
    filterTransform.rawArgs = true;
    var filter2 = typed("filter", {
      "Array, function": _filter,
      "Matrix, function": function MatrixFunction(x, test) {
        return x.create(_filter(x.toArray(), test));
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
    return filterTransform;
  }, {
    isTransformFunction: true
  });
  function _filter(x, callback) {
    var args = maxArgumentCount(callback);
    return filter(x, function(value, index, array) {
      if (args === 1) {
        return callback(value);
      } else if (args === 2) {
        return callback(value, [index + 1]);
      } else {
        return callback(value, [index + 1], array);
      }
    });
  }

  // node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
  var name282 = "forEach";
  var dependencies283 = ["typed"];
  var createForEachTransform = /* @__PURE__ */ factory(name282, dependencies283, (_ref) => {
    var {
      typed
    } = _ref;
    function forEachTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return _forEach2(x, callback);
    }
    forEachTransform.rawArgs = true;
    var _forEach2 = typed("forEach", {
      "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
        var args = maxArgumentCount(callback);
        var recurse = function recurse2(value, index) {
          if (Array.isArray(value)) {
            forEach(value, function(child, i) {
              recurse2(child, index.concat(i + 1));
            });
          } else {
            if (args === 1) {
              callback(value);
            } else if (args === 2) {
              callback(value, index);
            } else {
              callback(value, index, array);
            }
          }
        };
        recurse(array.valueOf(), []);
      }
    });
    return forEachTransform;
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/index.transform.js
  var name283 = "index";
  var dependencies284 = ["Index"];
  var createIndexTransform = /* @__PURE__ */ factory(name283, dependencies284, (_ref) => {
    var {
      Index
    } = _ref;
    return function indexTransform() {
      var args = [];
      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];
        if (isRange(arg)) {
          arg.start--;
          arg.end -= arg.step > 0 ? 0 : 2;
        } else if (arg && arg.isSet === true) {
          arg = arg.map(function(v) {
            return v - 1;
          });
        } else if (isArray(arg) || isMatrix(arg)) {
          arg = arg.map(function(v) {
            return v - 1;
          });
        } else if (isNumber(arg)) {
          arg--;
        } else if (isBigNumber(arg)) {
          arg = arg.toNumber() - 1;
        } else if (typeof arg === "string") {
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
        args[i] = arg;
      }
      var res = new Index();
      Index.apply(res, args);
      return res;
    };
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/map.transform.js
  var name284 = "map";
  var dependencies285 = ["typed"];
  var createMapTransform = /* @__PURE__ */ factory(name284, dependencies285, (_ref) => {
    var {
      typed
    } = _ref;
    function mapTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return map2(x, callback);
    }
    mapTransform.rawArgs = true;
    var map2 = typed("map", {
      "Array, function": function ArrayFunction(x, callback) {
        return _map2(x, callback, x);
      },
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.create(_map2(x.valueOf(), callback, x));
      }
    });
    return mapTransform;
  }, {
    isTransformFunction: true
  });
  function _map2(array, callback, orig) {
    var argsCount = maxArgumentCount(callback);
    function recurse(value, index) {
      if (Array.isArray(value)) {
        return map(value, function(child, i) {
          return recurse(child, index.concat(i + 1));
        });
      } else {
        if (argsCount === 1) {
          return callback(value);
        } else if (argsCount === 2) {
          return callback(value, index);
        } else {
          return callback(value, index, orig);
        }
      }
    }
    return recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
  function lastDimToZeroBase(args) {
    if (args.length === 2 && isCollection(args[0])) {
      args = args.slice();
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
    }
    return args;
  }

  // node_modules/mathjs/lib/esm/expression/transform/max.transform.js
  var name285 = "max";
  var dependencies286 = ["typed", "config", "numeric", "larger"];
  var createMaxTransform = /* @__PURE__ */ factory(name285, dependencies286, (_ref) => {
    var {
      typed,
      config: config2,
      numeric: numeric2,
      larger
    } = _ref;
    var max2 = createMax({
      typed,
      config: config2,
      numeric: numeric2,
      larger
    });
    return typed("max", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return max2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
  var name286 = "mean";
  var dependencies287 = ["typed", "add", "divide"];
  var createMeanTransform = /* @__PURE__ */ factory(name286, dependencies287, (_ref) => {
    var {
      typed,
      add: add2,
      divide: divide2
    } = _ref;
    var mean = createMean({
      typed,
      add: add2,
      divide: divide2
    });
    return typed("mean", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return mean.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/min.transform.js
  var name287 = "min";
  var dependencies288 = ["typed", "config", "numeric", "smaller"];
  var createMinTransform = /* @__PURE__ */ factory(name287, dependencies288, (_ref) => {
    var {
      typed,
      config: config2,
      numeric: numeric2,
      smaller
    } = _ref;
    var min2 = createMin({
      typed,
      config: config2,
      numeric: numeric2,
      smaller
    });
    return typed("min", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return min2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/range.transform.js
  var name288 = "range";
  var dependencies289 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
  var createRangeTransform = /* @__PURE__ */ factory(name288, dependencies289, (_ref) => {
    var {
      typed,
      config: config2,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    } = _ref;
    var range = createRange({
      typed,
      config: config2,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    });
    return typed("range", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (typeof last !== "boolean") {
          args.push(true);
        }
        return range.apply(null, args);
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/row.transform.js
  var name289 = "row";
  var dependencies290 = ["typed", "Index", "matrix", "range"];
  var createRowTransform = /* @__PURE__ */ factory(name289, dependencies290, (_ref) => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;
    var row = createRow({
      typed,
      Index,
      matrix,
      range
    });
    return typed("row", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return row.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
  var name290 = "subset";
  var dependencies291 = ["typed", "matrix"];
  var createSubsetTransform = /* @__PURE__ */ factory(name290, dependencies291, (_ref) => {
    var {
      typed,
      matrix
    } = _ref;
    var subset = createSubset({
      typed,
      matrix
    });
    return typed("subset", {
      "...any": function any(args) {
        try {
          return subset.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
  var name291 = "concat";
  var dependencies292 = ["typed", "matrix", "isInteger"];
  var createConcatTransform = /* @__PURE__ */ factory(name291, dependencies292, (_ref) => {
    var {
      typed,
      matrix,
      isInteger: isInteger2
    } = _ref;
    var concat = createConcat({
      typed,
      matrix,
      isInteger: isInteger2
    });
    return typed("concat", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        } else if (isBigNumber(last)) {
          args[lastIndex] = last.minus(1);
        }
        try {
          return concat.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
  var name292 = "diff";
  var dependencies293 = ["typed", "matrix", "subtract", "number", "bignumber"];
  var createDiffTransform = /* @__PURE__ */ factory(name292, dependencies293, (_ref) => {
    var {
      typed,
      matrix,
      subtract,
      number,
      bignumber
    } = _ref;
    var diff = createDiff({
      typed,
      matrix,
      subtract,
      number,
      bignumber
    });
    return typed(name292, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return diff.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/std.transform.js
  var name293 = "std";
  var dependencies294 = ["typed", "map", "sqrt", "variance"];
  var createStdTransform = /* @__PURE__ */ factory(name293, dependencies294, (_ref) => {
    var {
      typed,
      map: map2,
      sqrt: sqrt2,
      variance
    } = _ref;
    var std = createStd({
      typed,
      map: map2,
      sqrt: sqrt2,
      variance
    });
    return typed("std", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return std.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
  var name294 = "sum";
  var dependencies295 = ["typed", "config", "add", "numeric"];
  var createSumTransform = /* @__PURE__ */ factory(name294, dependencies295, (_ref) => {
    var {
      typed,
      config: config2,
      add: add2,
      numeric: numeric2
    } = _ref;
    var sum2 = createSum({
      typed,
      config: config2,
      add: add2,
      numeric: numeric2
    });
    return typed(name294, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return sum2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
  var name295 = "cumsum";
  var dependencies296 = ["typed", "add", "unaryPlus"];
  var createCumSumTransform = /* @__PURE__ */ factory(name295, dependencies296, (_ref) => {
    var {
      typed,
      add: add2,
      unaryPlus
    } = _ref;
    var cumsum = createCumSum({
      typed,
      add: add2,
      unaryPlus
    });
    return typed(name295, {
      "...any": function any(args) {
        if (args.length === 2 && isCollection(args[0])) {
          var dim = args[1];
          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }
        try {
          return cumsum.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
  var name296 = "variance";
  var dependencies297 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
  var createVarianceTransform = /* @__PURE__ */ factory(name296, dependencies297, (_ref) => {
    var {
      typed,
      add: add2,
      subtract,
      multiply,
      divide: divide2,
      apply,
      isNaN: isNaN2
    } = _ref;
    var variance = createVariance({
      typed,
      add: add2,
      subtract,
      multiply,
      divide: divide2,
      apply,
      isNaN: isNaN2
    });
    return typed(name296, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return variance.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/entry/allFactoriesAny.js
  var all = factoriesAny_exports;

  // node_modules/mathjs/lib/esm/core/create.js
  var import_typed_function2 = __toESM(require_typed_function(), 1);

  // node_modules/mathjs/lib/esm/utils/emitter.js
  var import_tiny_emitter = __toESM(require_tiny_emitter(), 1);
  function mixin(obj) {
    var emitter = new import_tiny_emitter.default();
    obj.on = emitter.on.bind(emitter);
    obj.off = emitter.off.bind(emitter);
    obj.once = emitter.once.bind(emitter);
    obj.emit = emitter.emit.bind(emitter);
    return obj;
  }

  // node_modules/mathjs/lib/esm/core/function/import.js
  function importFactory(typed, load, math2, importedFactories) {
    function mathImport(functions, options) {
      var num = arguments.length;
      if (num !== 1 && num !== 2) {
        throw new ArgumentsError("import", num, 1, 2);
      }
      if (!options) {
        options = {};
      }
      function flattenImports(flatValues2, value2, name298) {
        if (Array.isArray(value2)) {
          value2.forEach((item) => flattenImports(flatValues2, item));
        } else if (typeof value2 === "object") {
          for (var _name in value2) {
            if (hasOwnProperty2(value2, _name)) {
              flattenImports(flatValues2, value2[_name], _name);
            }
          }
        } else if (isFactory(value2) || name298 !== void 0) {
          var flatName = isFactory(value2) ? isTransformFunctionFactory(value2) ? value2.fn + ".transform" : value2.fn : name298;
          if (hasOwnProperty2(flatValues2, flatName) && flatValues2[flatName] !== value2 && !options.silent) {
            throw new Error('Cannot import "' + flatName + '" twice');
          }
          flatValues2[flatName] = value2;
        } else {
          if (!options.silent) {
            throw new TypeError("Factory, Object, or Array expected");
          }
        }
      }
      var flatValues = {};
      flattenImports(flatValues, functions);
      for (var name297 in flatValues) {
        if (hasOwnProperty2(flatValues, name297)) {
          var value = flatValues[name297];
          if (isFactory(value)) {
            _importFactory(value, options);
          } else if (isSupportedType(value)) {
            _import(name297, value, options);
          } else {
            if (!options.silent) {
              throw new TypeError("Factory, Object, or Array expected");
            }
          }
        }
      }
    }
    function _import(name297, value, options) {
      if (options.wrap && typeof value === "function") {
        value = _wrap(value);
      }
      if (hasTypedFunctionSignature(value)) {
        value = typed(name297, {
          [value.signature]: value
        });
      }
      if (typed.isTypedFunction(math2[name297]) && typed.isTypedFunction(value)) {
        if (options.override) {
          value = typed(name297, value.signatures);
        } else {
          value = typed(math2[name297], value);
        }
        math2[name297] = value;
        delete importedFactories[name297];
        _importTransform(name297, value);
        math2.emit("import", name297, function resolver() {
          return value;
        });
        return;
      }
      if (math2[name297] === void 0 || options.override) {
        math2[name297] = value;
        delete importedFactories[name297];
        _importTransform(name297, value);
        math2.emit("import", name297, function resolver() {
          return value;
        });
        return;
      }
      if (!options.silent) {
        throw new Error('Cannot import "' + name297 + '": already exists');
      }
    }
    function _importTransform(name297, value) {
      if (value && typeof value.transform === "function") {
        math2.expression.transform[name297] = value.transform;
        if (allowedInExpressions(name297)) {
          math2.expression.mathWithTransform[name297] = value.transform;
        }
      } else {
        delete math2.expression.transform[name297];
        if (allowedInExpressions(name297)) {
          math2.expression.mathWithTransform[name297] = value;
        }
      }
    }
    function _deleteTransform(name297) {
      delete math2.expression.transform[name297];
      if (allowedInExpressions(name297)) {
        math2.expression.mathWithTransform[name297] = math2[name297];
      } else {
        delete math2.expression.mathWithTransform[name297];
      }
    }
    function _wrap(fn) {
      var wrapper = function wrapper2() {
        var args = [];
        for (var i = 0, len = arguments.length; i < len; i++) {
          var arg = arguments[i];
          args[i] = arg && arg.valueOf();
        }
        return fn.apply(math2, args);
      };
      if (fn.transform) {
        wrapper.transform = fn.transform;
      }
      return wrapper;
    }
    function _importFactory(factory2, options) {
      var name297 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : factory2.fn;
      if (contains2(name297, ".")) {
        throw new Error("Factory name should not contain a nested path. Name: " + JSON.stringify(name297));
      }
      var namespace = isTransformFunctionFactory(factory2) ? math2.expression.transform : math2;
      var existingTransform = name297 in math2.expression.transform;
      var existing = hasOwnProperty2(namespace, name297) ? namespace[name297] : void 0;
      var resolver = function resolver2() {
        var dependencies298 = {};
        factory2.dependencies.map(stripOptionalNotation).forEach((dependency) => {
          if (contains2(dependency, ".")) {
            throw new Error("Factory dependency should not contain a nested path. Name: " + JSON.stringify(dependency));
          }
          if (dependency === "math") {
            dependencies298.math = math2;
          } else if (dependency === "mathWithTransform") {
            dependencies298.mathWithTransform = math2.expression.mathWithTransform;
          } else if (dependency === "classes") {
            dependencies298.classes = math2;
          } else {
            dependencies298[dependency] = math2[dependency];
          }
        });
        var instance = /* @__PURE__ */ factory2(dependencies298);
        if (instance && typeof instance.transform === "function") {
          throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path="expression.transform"');
        }
        if (existing === void 0 || options.override) {
          return instance;
        }
        if (typed.isTypedFunction(existing) && typed.isTypedFunction(instance)) {
          return typed(existing, instance);
        }
        if (options.silent) {
          return existing;
        } else {
          throw new Error('Cannot import "' + name297 + '": already exists');
        }
      };
      if (!factory2.meta || factory2.meta.lazy !== false) {
        lazy(namespace, name297, resolver);
        if (existing && existingTransform) {
          _deleteTransform(name297);
        } else {
          if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
            lazy(math2.expression.mathWithTransform, name297, () => namespace[name297]);
          }
        }
      } else {
        namespace[name297] = resolver();
        if (existing && existingTransform) {
          _deleteTransform(name297);
        } else {
          if (isTransformFunctionFactory(factory2) || factoryAllowedInExpressions(factory2)) {
            lazy(math2.expression.mathWithTransform, name297, () => namespace[name297]);
          }
        }
      }
      importedFactories[name297] = factory2;
      math2.emit("import", name297, resolver);
    }
    function isSupportedType(object) {
      return typeof object === "function" || typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object === null || isUnit(object) || isComplex(object) || isBigNumber(object) || isFraction(object) || isMatrix(object) || Array.isArray(object);
    }
    function hasTypedFunctionSignature(fn) {
      return typeof fn === "function" && typeof fn.signature === "string";
    }
    function allowedInExpressions(name297) {
      return !hasOwnProperty2(unsafe, name297);
    }
    function factoryAllowedInExpressions(factory2) {
      return factory2.fn.indexOf(".") === -1 && !hasOwnProperty2(unsafe, factory2.fn) && (!factory2.meta || !factory2.meta.isClass);
    }
    function isTransformFunctionFactory(factory2) {
      return factory2 !== void 0 && factory2.meta !== void 0 && factory2.meta.isTransformFunction === true || false;
    }
    var unsafe = {
      expression: true,
      type: true,
      docs: true,
      error: true,
      json: true,
      chain: true
    };
    return mathImport;
  }

  // node_modules/mathjs/lib/esm/core/create.js
  function create(factories, config2) {
    var configInternal = _extends({}, DEFAULT_CONFIG, config2);
    if (typeof Object.create !== "function") {
      throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");
    }
    var math2 = mixin({
      isNumber,
      isComplex,
      isBigNumber,
      isFraction,
      isUnit,
      isString,
      isArray,
      isMatrix,
      isCollection,
      isDenseMatrix,
      isSparseMatrix,
      isRange,
      isIndex,
      isBoolean,
      isResultSet,
      isHelp,
      isFunction,
      isDate,
      isRegExp,
      isObject,
      isNull,
      isUndefined,
      isAccessorNode,
      isArrayNode,
      isAssignmentNode,
      isBlockNode,
      isConditionalNode,
      isConstantNode,
      isFunctionAssignmentNode,
      isFunctionNode,
      isIndexNode,
      isNode,
      isObjectNode,
      isOperatorNode,
      isParenthesisNode,
      isRangeNode,
      isRelationalNode,
      isSymbolNode,
      isChain
    });
    math2.config = configFactory(configInternal, math2.emit);
    math2.expression = {
      transform: {},
      mathWithTransform: {
        config: math2.config
      }
    };
    var legacyFactories = [];
    var legacyInstances = [];
    function load(factory2) {
      if (isFactory(factory2)) {
        return factory2(math2);
      }
      var firstProperty = factory2[Object.keys(factory2)[0]];
      if (isFactory(firstProperty)) {
        return firstProperty(math2);
      }
      if (!isLegacyFactory(factory2)) {
        console.warn("Factory object with properties `type`, `name`, and `factory` expected", factory2);
        throw new Error("Factory object with properties `type`, `name`, and `factory` expected");
      }
      var index = legacyFactories.indexOf(factory2);
      var instance;
      if (index === -1) {
        if (factory2.math === true) {
          instance = factory2.factory(math2.type, configInternal, load, math2.typed, math2);
        } else {
          instance = factory2.factory(math2.type, configInternal, load, math2.typed);
        }
        legacyFactories.push(factory2);
        legacyInstances.push(instance);
      } else {
        instance = legacyInstances[index];
      }
      return instance;
    }
    var importedFactories = {};
    function lazyTyped() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return math2.typed.apply(math2.typed, args);
    }
    lazyTyped.isTypedFunction = import_typed_function2.default.isTypedFunction;
    var internalImport = importFactory(lazyTyped, load, math2, importedFactories);
    math2.import = internalImport;
    math2.on("config", () => {
      values(importedFactories).forEach((factory2) => {
        if (factory2 && factory2.meta && factory2.meta.recreateOnConfigChange) {
          internalImport(factory2, {
            override: true
          });
        }
      });
    });
    math2.create = create.bind(null, factories);
    math2.factory = factory;
    math2.import(values(deepFlatten(factories)));
    math2.ArgumentsError = ArgumentsError;
    math2.DimensionError = DimensionError;
    math2.IndexError = IndexError;
    return math2;
  }

  // node_modules/react-div-100vh/dist/esm/index.js
  var import_react = __toESM(require_react());
  var __assign = function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __rest = function(s, e2) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var warned = false;
  var Div100vh = (0, import_react.forwardRef)(function(_a, ref) {
    var style = _a.style, other = __rest(_a, ["style"]);
    var height = use100vh();
    if (!warned && (style === null || style === void 0 ? void 0 : style.height)) {
      warned = true;
      console.warn("<Div100vh /> overrides the height property of the style prop");
    }
    var styleWithRealHeight = __assign(__assign({}, style), { height: height ? height + "px" : "100vh" });
    return import_react.default.createElement("div", __assign({ ref, style: styleWithRealHeight }, other));
  });
  Div100vh.displayName = "Div100vh";
  var esm_default = Div100vh;
  function use100vh() {
    var _a = (0, import_react.useState)(measureHeight), height = _a[0], setHeight = _a[1];
    var wasRenderedOnClientAtLeastOnce = useWasRenderedOnClientAtLeastOnce();
    (0, import_react.useEffect)(function() {
      if (!wasRenderedOnClientAtLeastOnce)
        return;
      function setMeasuredHeight() {
        var measuredHeight = measureHeight();
        setHeight(measuredHeight);
      }
      window.addEventListener("resize", setMeasuredHeight);
      return function() {
        return window.removeEventListener("resize", setMeasuredHeight);
      };
    }, [wasRenderedOnClientAtLeastOnce]);
    return wasRenderedOnClientAtLeastOnce ? height : null;
  }
  function measureHeight() {
    if (!isClient())
      return null;
    return window.innerHeight;
  }
  function useWasRenderedOnClientAtLeastOnce() {
    var _a = (0, import_react.useState)(false), wasRenderedOnClientAtLeastOnce = _a[0], setWasRenderedOnClientAtLeastOnce = _a[1];
    (0, import_react.useEffect)(function() {
      if (isClient()) {
        setWasRenderedOnClientAtLeastOnce(true);
      }
    }, []);
    return wasRenderedOnClientAtLeastOnce;
  }
  function isClient() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }

  // src/utils.ts
  function closeBracket(input) {
    let openBracket = 0;
    let closeBracket2 = 0;
    for (let i = 0; i < input.length; i++) {
      let c = input[i];
      if (c == "(") {
        openBracket++;
      } else if (c == ")") {
        closeBracket2++;
      }
    }
    let restCloseBracket = openBracket - closeBracket2;
    if (restCloseBracket > 0) {
      input += ")".repeat(restCloseBracket);
    }
    console.log("input", input);
    return input;
  }
  function formatNumber(input) {
    let numberInput = Number(input);
    if (numberInput < 1e-99 && numberInput > -1e-99) {
      return "0";
    }
    if (input.indexOf("e") != -1 || input.indexOf("E") != -1) {
      return input;
    }
    let inputs = input.split(".");
    if (inputs[0]) {
      let number = inputs[0];
      number = new Intl.NumberFormat("en-EN").format(Number(number));
      number = number.replace(/,/g, " ");
      if (inputs.length == 2) {
        return number + "." + inputs[1];
      } else {
        return number;
      }
    }
    return inputs.join(".");
  }

  // src/main.tsx
  var math = create(all, {
    epsilon: 1e-100,
    number: "BigNumber",
    precision: 101,
    predictable: true,
    randomSeed: null
  });
  var parser = math.parser();
  parser.evaluate("sqrt3(x) = x ^ (1/3)");
  parser.evaluate("ln(x) = log(x)");
  parser.evaluate("ans = 0");
  parser.evaluate("mem = 0");
  parser.evaluate("add(x) = mem + x");
  parser.evaluate("sub(x) = mem - x");
  parser.evaluate("memclear() = 0");
  parser.evaluate("memadd(x) = mem");
  parser.evaluate("memsub(x) = mem");
  var App = class extends React2.Component {
    constructor(props) {
      super(props);
      this.calWidth = () => {
        if (!this.refOp.current || !this.refCo.current) {
          return;
        }
        let nodesRow = this.refOp.current.childNodes;
        nodesRow.forEach((nodeRow) => {
          nodeRow.childNodes.forEach((nodeB) => {
            let nodeBtn = nodeB;
            const MARGING = 6;
            let devicer = 10;
            if (window.innerWidth < 700 && window.innerWidth > 300) {
              devicer = 14;
            }
            let height = this.refCo.current.clientHeight / devicer - MARGING;
            let width = nodeBtn.clientWidth;
            if (width < height) {
              height = width;
            }
            nodeBtn.style.height = height + "px";
          });
        });
      };
      this.isExp = (input) => {
        input = input.trim();
        let last1char = input.substring(input.length - 1);
        let last4char = input.substring(input.length - 4);
        let last5char = input.substring(input.length - 5);
        if (last1char == "^") {
          return true;
        }
        if (last5char == "^(-1)") {
          return true;
        }
        if (last4char == "^(2)" || last4char == "^(3)") {
          return true;
        }
        return false;
      };
      this.input = (btn, event) => {
        this.setState((prevState) => {
          let isEqualBtn = btn.trim() == "=";
          if (btn == "AC") {
            return {
              resize: false,
              input: "",
              isCal: false,
              exp: false
            };
          }
          if (btn == "memadd") {
            let input = prevState.input;
            if (prevState.isCal) {
              input = this.lastAns.replace(/ /g, "");
            }
            input = input || "0";
            let evaluation = this.getEvalutionBeforeParse(input);
            try {
              let ans = parser.evaluate("mem = add(" + evaluation + ")");
              let ansStr = this.getAnsFromEvalutionResult(ans);
              this.mem = ansStr;
            } catch (e2) {
              this.mem = "0";
              return {
                resize: false,
                input: "Parse error",
                isCal: true,
                exp: false
              };
            }
            return {
              resize: false,
              input: "memadd(" + input + ")",
              isCal: true,
              exp: false
            };
          }
          if (btn == "memsub") {
            let input = prevState.input;
            if (prevState.isCal) {
              input = this.lastAns.replace(/ /g, "");
            }
            input = input || "0";
            let evaluation = this.getEvalutionBeforeParse(input);
            try {
              let ans = parser.evaluate("mem = sub(" + evaluation + ")");
              let ansStr = this.getAnsFromEvalutionResult(ans);
              this.mem = ansStr;
            } catch (e2) {
              this.mem = "0";
              return {
                resize: false,
                input: "Parse error",
                isCal: true,
                exp: false
              };
            }
            return {
              resize: false,
              input: "memsub(" + input + ")",
              isCal: true,
              exp: false
            };
          }
          if (btn == "memclear") {
            parser.evaluate("mem = 0");
            this.mem = "0";
            return {
              resize: false,
              input: "memclear()",
              isCal: true,
              exp: false
            };
          }
          if (btn == "DEL") {
            console.log("input = '" + prevState.input + "'");
            let removeChar = 1;
            if (prevState.input[prevState.input.length - 1] == " ") {
              removeChar = 2;
            }
            let last3char = prevState.input.substring(prevState.input.length - 3);
            let last4char = prevState.input.substring(prevState.input.length - 4);
            let last5char = prevState.input.substring(prevState.input.length - 5);
            let last6char = prevState.input.substring(prevState.input.length - 6);
            if (last4char == "sin(" || last4char == "cos(" || last4char == "tan(") {
              removeChar = 4;
            }
            if (last5char == "sinh(" || last5char == "cosh(" || last5char == "tanh(" || last5char == "asin(" || last5char == "acos(" || last5char == "atan(") {
              removeChar = 5;
            }
            if (last6char == "asinh(" || last6char == "acosh(" || last6char == "atanh(") {
              removeChar = 6;
            }
            if (last3char == "ln(") {
              removeChar = 3;
            }
            if (last5char == "log2(") {
              removeChar = 5;
            }
            if (last6char == "log10(") {
              removeChar = 6;
            }
            if (last5char == "^(-1)") {
              removeChar = 5;
            }
            if (last4char == "^(2)" || last4char == "^(3)") {
              removeChar = 4;
            }
            let newInput2 = prevState.input.substring(0, prevState.input.length - removeChar);
            newInput2 = newInput2.trim();
            return {
              resize: false,
              input: newInput2,
              isCal: false,
              exp: this.isExp(newInput2)
            };
          }
          if (isEqualBtn && prevState.input.search("ans") != -1) {
            return {
              resize: false,
              input: prevState.input,
              isCal: isEqualBtn,
              exp: this.isExp(prevState.input)
            };
          }
          if (isEqualBtn && prevState.isCal) {
            return {};
          }
          if (this.isFuncBtn(btn) && (prevState.isCal || prevState.input == "")) {
            btn = this.lastAns.replace(/ /g, "") + btn;
          }
          let newInput = prevState.input;
          if (prevState.isCal) {
            newInput = btn;
          } else {
            newInput += btn;
          }
          return {
            resize: false,
            input: newInput,
            isCal: isEqualBtn,
            exp: this.isExp(newInput)
          };
        });
        let target = event.target;
        target.classList.add("click");
      };
      this.inputUp = (event) => {
        let target = event.target;
        target.classList.remove("click");
      };
      this.isFuncBtn = (btn) => {
        btn = btn.trim();
        if (btn == "\xD7" || btn == "+" || btn == "\xF7" || btn == "%" || btn == "^" || btn == "^(2)" || btn == "^(3)" || btn == "^(-1)" || btn == "^ (1/" || btn == "!" || btn == "/") {
          return true;
        }
        return false;
      };
      this.inputToEval = (input) => {
        input = input.trim();
        let evaluation = "";
        for (let i = 0; i < input.length; i++) {
          let char = input[i];
          if (char == "\xD7") {
            evaluation += " * ";
          } else if (char == "\xF7") {
            evaluation += " / ";
          } else if (char == "\u221A") {
            evaluation += "sqrt( ";
          } else if (char == "\u221B") {
            evaluation += "sqrt3( ";
          } else if (char == "\xB0") {
            evaluation += " deg ";
          } else if (char == "\u03C0") {
            evaluation += " pi ";
          } else if (char == "E") {
            evaluation += " *10^ ";
          } else if (char == "=") {
            evaluation += "";
          } else {
            evaluation += char;
          }
        }
        return evaluation;
      };
      this.getEvalutionBeforeParse = (input) => {
        if (input[input.length - 1] == "=") {
          input = input.substring(0, input.length - 1);
        }
        let evalution = closeBracket(this.inputToEval(input));
        return evalution;
      };
      this.getAnsFromEvalutionResult = (ans) => {
        let ansStr = math.format(ans, {
          precision: 10,
          upperExp: 10
        });
        if (ansStr == "undefined") {
          return "0";
        }
        return ansStr;
      };
      this.getAnsStr = (input) => {
        if (this.state.resize) {
          return this.lastAns;
        }
        try {
          let evalution = closeBracket(this.inputToEval(input));
          console.log("evalution", evalution);
          let ans = parser.evaluate(evalution);
          let ansStr = this.getAnsFromEvalutionResult(ans);
          console.log("ans11", ansStr);
          parser.evaluate("ans = " + ansStr);
          ansStr = formatNumber(ansStr);
          this.lastAns = ansStr;
          return ansStr;
        } catch (e2) {
          console.error(e2);
          this.lastAns = "0";
          return "Parse error";
        }
      };
      this.toggleTwofunc = () => {
        this.setState((prevState) => {
          return {
            twoFunc: !prevState.twoFunc
          };
        });
      };
      this.displayInput = (input) => {
        input = input || "0";
        if (input.trim() == "=") {
          return "";
        }
        input = input.replace(/log10/g, "log");
        input = input.replace(/log2/g, "log<sub>2</sub>");
        input = input.replace(/\^\(-1\)/g, "<sup>-1</sup>");
        input = input.replace(/\^\(2\)/g, "<sup>2</sup>");
        input = input.replace(/\^\(3\)/g, "<sup>3</sup>");
        input = input.replace(/asin\(/g, "sin<sup>-1</sup>(");
        input = input.replace(/acos\(/g, "cos<sup>-1</sup>(");
        input = input.replace(/atan\(/g, "tan<sup>-1</sup>(");
        input = input.replace(/asinh\(/g, "sinh<sup>-1</sup>(");
        input = input.replace(/acosh\(/g, "cosh<sup>-1</sup>(");
        input = input.replace(/atanh\(/g, "tanh<sup>-1</sup>(");
        return input;
      };
      this.refOp = React2.createRef();
      this.refCo = React2.createRef();
      this.history = [];
      this.state = {
        input: "",
        isCal: false,
        twoFunc: false,
        resize: false,
        exp: false
      };
      this.lastAns = "0";
      this.mem = "0";
    }
    componentDidMount() {
      document.addEventListener("orientationchange", (e2) => {
        this.calWidth();
        this.setState({
          resize: true
        });
      });
      window.onorientationchange = () => {
        this.calWidth();
        this.setState({
          resize: true
        });
      };
      window.addEventListener("resize", (e2) => {
        this.calWidth();
        this.setState({
          resize: true
        });
      });
      if (screen && screen.orientation) {
        screen.orientation.addEventListener("change", () => {
          this.calWidth();
          this.setState({
            resize: true
          });
        });
      }
      this.calWidth();
    }
    render() {
      let disabledExp = {};
      if (this.state.exp) {
        disabledExp = {
          disabled: "disabled"
        };
      }
      return /* @__PURE__ */ React2.createElement(esm_default, null, /* @__PURE__ */ React2.createElement("div", {
        className: "wrap-container",
        ref: this.refCo
      }, /* @__PURE__ */ React2.createElement("div", {
        className: "wrap-input"
      }, /* @__PURE__ */ React2.createElement("div", {
        className: "item"
      }, this.state.isCal && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("div", {
        className: "input",
        dangerouslySetInnerHTML: { __html: this.displayInput(this.state.input) }
      }), /* @__PURE__ */ React2.createElement("div", {
        className: "answer"
      }, this.getAnsStr(this.state.input))), !this.state.isCal && /* @__PURE__ */ React2.createElement("div", {
        className: "answer",
        dangerouslySetInnerHTML: { __html: this.displayInput(this.state.input) }
      }), this.mem != "0" && /* @__PURE__ */ React2.createElement("div", {
        className: "mem"
      }, "mem = ", formatNumber(this.mem)))), /* @__PURE__ */ React2.createElement("div", {
        className: "wrap-operator noselect",
        ref: this.refOp
      }, /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, !this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "sin("),
        className: "btn func func2 sm-font"
      }, "sin"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "cos("),
        className: "btn func func2 sm-font"
      }, "cos"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "tan("),
        className: "btn func func2 sm-font"
      }, "tan")), this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "asin("),
        className: "btn func func2 sm-font"
      }, "sin", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "acos("),
        className: "btn func func2 sm-font"
      }, "cos", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "atan("),
        className: "btn func func2 sm-font"
      }, "tan", /* @__PURE__ */ React2.createElement("sup", null, "-1"))), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\xB0"),
        className: "btn func func2"
      }, "\xB0"), /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "^(-1)"),
        className: "btn func func2 sm-font"
      }, "x", /* @__PURE__ */ React2.createElement("sup", null, "-1"))), /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, !this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "log10("),
        className: "btn func func2 sm-font"
      }, "log", /* @__PURE__ */ React2.createElement("sub", null, "10")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "ln("),
        className: "btn func func2 sm-font"
      }, "ln")), this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "10^"),
        className: "btn func func2 sm-font"
      }, "10", /* @__PURE__ */ React2.createElement("sup", null, "x")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "e^"),
        className: "btn func func2 sm-font"
      }, "e", /* @__PURE__ */ React2.createElement("sup", null, "x"))), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "("),
        className: "btn func func2 sm-font"
      }, "("), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, ")"),
        className: "btn func func2 sm-font"
      }, ")"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.toggleTwofunc,
        className: this.state.twoFunc ? "btn btn-enable func func2 sm-font" : "btn func func2 sm-font"
      }, "inv")), /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "("),
        className: "btn func"
      }, "("), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, ")"),
        className: "btn func"
      }, ")"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "memclear"),
        className: "btn func"
      }, "mc"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "memadd"),
        className: "btn func"
      }, "m+"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "memsub"),
        className: "btn func"
      }, "m-"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "mem"),
        className: "btn func"
      }, "mr"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "! "),
        className: "btn func func2"
      }, "!"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "AC"),
        className: "sys btn sm-font"
      }, "AC"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "DEL"),
        className: "sys btn sm-font delete"
      }, "DEL"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "%"),
        className: "sys btn sm-font"
      }, "%"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " \xF7 "),
        className: "ops btn"
      }, "\xF7")), /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.toggleTwofunc,
        className: this.state.twoFunc ? "btn btn-enable func sm-font" : "btn func sm-font"
      }, "inv"), /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "^(2)"),
        className: "btn func"
      }, "x", /* @__PURE__ */ React2.createElement("sup", null, "2")), /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "^(3)"),
        className: "btn func"
      }, "x", /* @__PURE__ */ React2.createElement("sup", null, "3")), /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " ^ "),
        className: "btn func"
      }, "x", /* @__PURE__ */ React2.createElement("sup", null, "y")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "e^"),
        className: "btn func"
      }, "e", /* @__PURE__ */ React2.createElement("sup", null, "x")), !this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "10^"),
        className: "btn func"
      }, "10", /* @__PURE__ */ React2.createElement("sup", null, "x")), this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "2^"),
        className: "btn func"
      }, "2", /* @__PURE__ */ React2.createElement("sup", null, "x")), /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " ^ "),
        className: "btn func func2"
      }, "^"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "7"),
        className: "btn"
      }, "7"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "8"),
        className: "btn"
      }, "8"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "9"),
        className: "btn"
      }, "9"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " \xD7 "),
        className: "btn ops"
      }, "\xD7")), /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "^(-1)"),
        className: "btn func"
      }, "x", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\u221A("),
        className: "btn func"
      }, "\u221A"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\u221B("),
        className: "btn func"
      }, "\u221B"), /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " ^ (1/"),
        className: "btn func"
      }, "y\u221Ax"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "ln("),
        className: "btn func"
      }, "ln"), !this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "log10("),
        className: "btn func sm-font"
      }, "log", /* @__PURE__ */ React2.createElement("sub", null, "10")), this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "log2("),
        className: "btn func sm-font"
      }, "log", /* @__PURE__ */ React2.createElement("sub", null, "2")), !this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\u221A("),
        className: "btn func func2"
      }, "\u221A"), this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        ...disabledExp,
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "^(2)"),
        className: "btn func func2 sm-font"
      }, "x", /* @__PURE__ */ React2.createElement("sup", null, "2")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "4"),
        className: "btn"
      }, "4"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "5"),
        className: "btn"
      }, "5"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "6"),
        className: "btn"
      }, "6"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " - "),
        className: "btn ops"
      }, "-")), /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "!"),
        className: "btn func"
      }, "x!"), !this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "sin("),
        className: "btn func sm-font"
      }, "sin"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "cos("),
        className: "btn func sm-font"
      }, "cos"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "tan("),
        className: "btn func sm-font"
      }, "tan")), this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "asin("),
        className: "btn func sm-font"
      }, "sin", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "acos("),
        className: "btn func sm-font"
      }, "cos", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "atan("),
        className: "btn func sm-font"
      }, "tan", /* @__PURE__ */ React2.createElement("sup", null, "-1"))), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "e"),
        className: "btn func"
      }, "e"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "E"),
        className: "btn func"
      }, "E"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\u03C0"),
        className: "btn func func2"
      }, "\u03C0"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "1"),
        className: "btn"
      }, "1"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "2"),
        className: "btn"
      }, "2"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "3"),
        className: "btn"
      }, "3"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " + "),
        className: "btn ops"
      }, "+")), /* @__PURE__ */ React2.createElement("div", {
        className: "row"
      }, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "/"),
        className: "btn func"
      }, "/"), !this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "sinh("),
        className: "btn func sm-font"
      }, "sinh"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "cosh("),
        className: "btn func sm-font"
      }, "cosh"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "tanh("),
        className: "btn func sm-font"
      }, "tanh")), this.state.twoFunc && /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "asinh("),
        className: "btn func sm-font"
      }, "sinh", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "acosh("),
        className: "btn func sm-font"
      }, "cosh", /* @__PURE__ */ React2.createElement("sup", null, "-1")), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "atanh("),
        className: "btn func sm-font"
      }, "tanh", /* @__PURE__ */ React2.createElement("sup", null, "-1"))), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\u03C0"),
        className: "btn func"
      }, "\u03C0"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "\xB0"),
        className: "btn func"
      }, "\xB0"), !this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "E"),
        className: "btn func func2"
      }, "E"), this.state.twoFunc && /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "e"),
        className: "btn func func2"
      }, "e"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "0"),
        className: "btn"
      }, "0"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "."),
        className: "btn"
      }, "."), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, "ans"),
        className: "btn sm-font"
      }, "ans"), /* @__PURE__ */ React2.createElement("button", {
        onTouchEnd: this.inputUp.bind(this),
        onTouchStart: this.input.bind(this, " ="),
        className: "btn ops"
      }, "=")))));
    }
  };
  var rootElement = document.getElementById("root");
  var root = ReactDOM.createRoot(rootElement);
  root.render(
    /* @__PURE__ */ React2.createElement(App, null)
  );
})();
/*!
 *  decimal.js v10.4.2
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
//# sourceMappingURL=out.js.map
